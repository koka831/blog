{"pageProps":{"post":{"slug":"2021-10-20-testable-architecture-flutter","title":"テスト容易性を考慮したFlutterのアーキテクチャ考察","categories":["Programming"],"image":"https://koka831.github.io/img/icon.png","tags":["Flutter"],"content":"<p>ここ半年ほどFlutterを書いていて，アプリケーションのアーキテクチャで試行錯誤してます．状態管理ムズくない？<br>\nなのでいっそ表に出して意見もらえたらな，と思ったので書きます．</p>\n<p>本記事では，Flutterアプリケーションにおいてテスト容易性を向上するためにはどうすればいいか，サンプルアプリケーションを例題にアーキテクチャレベルで検討します．</p>\n<h2 id=\"アーキテクチャの目的\"><a href=\"#%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%81%AE%E7%9B%AE%E7%9A%84\">アーキテクチャの目的</a></h2>\n<p>今回は<strong>テスト容易性</strong>を主軸に置いたアーキテクチャ選定を行いました．\n特にFlutterの単体テストはネットワークリクエストが遮断されるので，副作用を伴う処理を行うレイヤを適切に分離し，テストが容易になるよう設計を行うこととしました．</p>\n<p>アーキテクチャは何かしら課題を解決するために設計されるもの(だと思っている)なので，今回示す例が必ずしもベストなものとは限らないです．</p>\n<h3 id=\"テスト容易性とは\"><a href=\"#%E3%83%86%E3%82%B9%E3%83%88%E5%AE%B9%E6%98%93%E6%80%A7%E3%81%A8%E3%81%AF\">テスト容易性とは</a></h3>\n<p>テスト容易性とは，James Bachが提唱した<a href=\"https://www.satisfice.com/download/heuristics-of-software-testability\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Heuristics of Software Testability</a>(テスタビリティ・テスト容易性のモデル)に示される，テストの品質を測る指標です．\nそれぞれの説明は<a href=\"https://www.praha-inc.com/lab/posts/testability\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">優れたテスト容易性を実現するためのポイント - PrAha ENGINEER LAB</a>に詳しいです．<br>\nこちらの記事でも示されている通り，テスト容易性の向上にはテスト容易性を低下させる要因を抑えることが必要不可欠です．そしてその要因はコードレベルに留まらずアーキテクチャレベルで抑えることが求められます．</p>\n<h2 id=\"全体像\"><a href=\"#%E5%85%A8%E4%BD%93%E5%83%8F\">全体像</a></h2>\n<p>ざっくり以下の機能を持つアプリケーションを例にとります．</p>\n<ul>\n<li>APIサーバからデータ<code>Foo</code>のリストを取得してデータを描画する</li>\n<li>データ<code>Foo</code>を作成し，描画されるリストを更新する</li>\n<li>pull-to-refreshでのデータ再取得機能を持つ</li>\n</ul>\n<p>また，今回用いるレイヤは以下のようになります;</p>\n<ul>\n<li><strong>API Client</strong>: APIサーバからのデータ取得+モデルへのdeserializeを行う\n<ul>\n<li>実装: <code>GetRequestProtocol</code> + <code>ListFooRequest</code></li>\n</ul>\n</li>\n<li><strong>Repository</strong>: API Client(+<a href=\"https://pub.dev/packages/shared_preferences\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">shared_preferences</a>)を利用してデータ取得・更新を行う\n<ul>\n<li>実装: <code>FooRepository</code> + <code>fooRepositoryProvider</code></li>\n</ul>\n</li>\n<li><strong>Service</strong>: ドメインロジック担当(もしくはTransaction Script)\n<ul>\n<li>実装は省略</li>\n</ul>\n</li>\n<li><strong>ViewModel</strong>: Viewの描画以外の責務全て\n<ul>\n<li>実装: <code>FooViewModel</code> + <code>fooViewModelProvider</code></li>\n</ul>\n</li>\n<li><strong>View</strong>: 描画+イベントとViewModelのイベントハンドラの糊付け\n<ul>\n<li>実装は省略</li>\n</ul>\n</li>\n</ul>\n<p>テスト容易性を念頭に置いた際にどのレイヤの分割が必要か判断した結果，基本的なMVVMアーキテクチャとなりました．<br>\nテスト容易性のためには特にViewをいかに薄く保てるかがキモで，そのためにViewModelはやや責務過多になる傾向にあります．\nしたがってViewModelの肥大化を防ぐためにドメインロジックをViewModelからServiceクラスへ委譲し，また描画用のデータ管理とステートレスなドメインロジックを分離してテストできるようにします．<br>\nViewModelと共に扱われることの多い，StreamやReactiveな双方向データバインディングは扱いません．</p>\n<p>以下では各レイヤ毎に簡易実装及びそのテストコードを示し，そのレイヤにおける責務と設計基準を説明します．<br>\n実際の設計時はテストコードから書いて書き心地を試しつつの実装を行いましたが，説明の都合で実装->テストの順で示します．</p>\n<p>また，Widgetについての設計はここでは述べません．\nテスト容易性の観点からViewを薄く保つことを念頭に置いているため，ViewはViewModelまでの設計と異なる目的での設計を取りうるためです．</p>\n<h2 id=\"api-client\"><a href=\"#api-client\">API Client</a></h2>\n<p>APIクライアントクラスはネットワーク越しのリクエストを行い，アプリ内でのモデルへのdeserializeを行います．</p>\n<p>ここではREST APIを仮定したクラス設計を行いますが，gRPCやGraphQLの場合でも実装が異なるだけで責務自体は変わらないと思います．<br>\nAPIレスポンスは対応するモデルクラスにマッピングし，<code>dynamic</code>型として存在する期間を極力短く保ちます．</p>\n<p>モデルクラスは適当な集約単位で作成し，レスポンスを正規化して持つようにします．\n<a href=\"https://pub.dev/packages/json_serializable\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">json_serializable</a>と組み合わせて<code>deserialize</code>の実装をModelのconstructorとして任せると楽です．</p>\n<p><div class=\"remark-container info\"><div class=\"remark-container__title\">immutable</div>Dartで構造体や関数以外への型エイリアスが定義できないのでclassとして定義するしかない．\nただ内部状態を変更できるクラスメソッドを書けてしまうと変更検知が辛くなってしまう．</div></p>\n<div class=\"remark-highlight\"><pre data-file=\"foo.dart\" class=\"language-dart  line-numbers\"><code class=\"language-dart\"><span class=\"token metadata symbol\">@freezed</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Foo</span> <span class=\"token keyword\">with</span> _$<span class=\"token class-name\">Foo</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">factory</span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">.</span><span class=\"token function\">fromJson</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&#x3C;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">dynamic</span><span class=\"token punctuation\">></span></span> json<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> _$<span class=\"token class-name\">FooFromJson</span><span class=\"token punctuation\">(</span>json<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span></span>\n</code></pre></div>\n<p>APIリクエストクラスは，実際のリクエスト処理の隠蔽及びテスト時のDIインターフェース統一のためにプロトコルで縛るようにします．\nプロトコルはmixinとして定義し，リクエスト処理を行う<code>request</code>メソッドのみmixin側に実装します．<br>\nここでは簡単のため<code>url</code>以外の定義を省略していますが，クエリパラメータやヘッダなど，想定されるユースケースに応じた設定が行えるようにインターフェースを設計します．</p>\n<p>今回はGETリクエストを想定した<code>GetRequestProtocol</code>を定義し，またそのユースケースとして<code>ListFooRequest</code>を実装します．<br>\nまた，<code>HttpClient</code>はHTTPリクエストを担う<a href=\"https://pub.dev/packages/http\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">http</a>や<a href=\"https://pub.dev/packages/dio\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">dio</a>，またはいずれかをwrapしたクラスです．</p>\n<div class=\"remark-highlight\"><pre data-file=\"api_protocol.dart\" class=\"language-dart  line-numbers\"><code class=\"language-dart\"><span class=\"token comment\">// `package:meta` に [@mustOverride] annotation が入ったら嬉しい</span>\n<span class=\"token comment\">// @see: <a href=\"https://github.com/dart-lang/sdk/issues/30175\" class=\"token url-link\">https://github.com/dart-lang/sdk/issues/30175</a></span>\n<span class=\"token keyword\">mixin</span> <span class=\"token class-name\">GetRequestProtocol</span><span class=\"token generics\"><span class=\"token punctuation\">&#x3C;</span><span class=\"token class-name\">M</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token metadata symbol\">@protected</span>\n  <span class=\"token class-name\">String</span> <span class=\"token keyword\">get</span> url <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token keyword\">throw</span> <span class=\"token class-name\">UnimplementedError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&#x3C;</span><span class=\"token class-name\">M</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">request</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">HttpClient</span> client<span class=\"token punctuation\">)</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> json <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> client<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span><span class=\"token comment\">/* api request */</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">_deserialize</span><span class=\"token punctuation\">(</span>json<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token metadata symbol\">@protected</span>\n  <span class=\"token class-name\">M</span> <span class=\"token function\">_deserialize</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Response</span> json<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span></span>\n</code></pre></div>\n<p>ユースケース側は<code>GetRequestProtocol</code>を取り込んだRequestクラスを定義し，<code>request</code>メソッドが返すレスポンスをモデルへ変換する<code>deserialize</code>メソッドを実装します．</p>\n<p>ここでは簡単のため<code>url</code>を固定値としていますが，実際には<a href=\"https://pub.dev/packages/flutter_dotenv\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">flutter_dotenv</a>を用いて環境変数としてAPIエンドポイントの管理を行います．\nこれは設定と実装の分離の観点からももちろん好ましいのですが，読み込む<code>.env</code>ファイルをテスト時に差し替えられる利点が大きいです．詳細は後述します．</p>\n<div class=\"remark-highlight\"><pre data-file=\"list_foo_request.dart\" class=\"language-dart  line-numbers\"><code class=\"language-dart\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">ListFooRequest</span> <span class=\"token keyword\">with</span> <span class=\"token class-name\">GetRequestProtocol</span><span class=\"token generics\"><span class=\"token punctuation\">&#x3C;</span><span class=\"token class-name\">List</span><span class=\"token punctuation\">&#x3C;</span><span class=\"token class-name\">Foo</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token metadata symbol\">@override</span>\n  <span class=\"token class-name\">String</span> <span class=\"token keyword\">get</span> url <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token string\">'<a href=\"https://example.com/foos\" class=\"token url-link\">https://example.com/foos</a>'</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token metadata symbol\">@override</span>\n  <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&#x3C;</span><span class=\"token class-name\">Foo</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">_deserialize</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Response</span> json<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// レスポンスのJSONが`foos`をキーとして[Foo]の配列を持つと仮定</span>\n    <span class=\"token comment\">// constructor の tear-off が入ると `.map(Foo.fromJson)`のようにかける</span>\n    <span class=\"token comment\">// @see: <a href=\"https://twitter.com/remi_rousselet/status/1438207417154686980?s=20\" class=\"token url-link\">https://twitter.com/remi_rousselet/status/1438207417154686980?s=20</a></span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>json<span class=\"token punctuation\">[</span><span class=\"token string\">'foos'</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">as</span> <span class=\"token class-name\">List</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token class-name\">Foo</span><span class=\"token punctuation\">.</span><span class=\"token function\">fromJson</span><span class=\"token punctuation\">(</span>f <span class=\"token operator\">as</span> <span class=\"token class-name\">Map</span><span class=\"token generics\"><span class=\"token punctuation\">&#x3C;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">dynamic</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">toList</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span></span>\n</code></pre></div>\n<h3 id=\"test\"><a href=\"#test\">test</a></h3>\n<p>APIクライアントクラスはネットワークリクエストを行い，レスポンスをモデルに変換するところまでを責務としました．<br>\nFlutterのテストライブラリ<a href=\"https://api.flutter.dev/flutter/flutter_test/flutter_test-library.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">flutter_test</a>ではネットワークリクエストが遮断されるため，APIクライアントクラスに対するテストは<code>request</code>メソッドの返り値が対応するモデルインスタンスであるかどうかを評価することになります．<br>\nモックのアプローチとしては以下の2パターンが考えられます;</p>\n<ul>\n<li>A. <a href=\"https://pub.dev/packages/mockito\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">mockito</a>を用いて<code>HttpClient</code>のモックオブジェクトを生成し，対応するレスポンスをスタブする</li>\n<li>B. <a href=\"https://pub.dev/packages/mock_web_server\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">mock_http_server</a>を用いてテスト用APIサーバを構築し，閉じたネットワークでのテストを行う</li>\n</ul>\n<p>mockitoを用いる場合，今回の例題では<code>HttpClient</code>クラスの<code>get</code>メソッドをスタブすれば良さそうですが，HTTPリクエストを担うレイヤはinterceptorなどの機構を用いてロガーやエラーハンドラなどを注入するケースが多々あります．<br>\nそのためテスト時に生成される<code>HttpClient</code>のモックオブジェクトと実際のリクエスト時に渡される<code>HttpClient</code>のインスタンスはスタブされている箇所以外にも設定が異なってしまうことが懸念されます．\nしたがって<code>HttpClient</code>の挙動がランタイムと乖離しないように，ネットワークリクエスト先をすげ替えるBの方針を取ることにします．</p>\n<div class=\"remark-highlight\"><pre data-file=\"list_foo_request_test.dart\" class=\"language-dart  line-numbers\"><code class=\"language-dart\"><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">final</span> server <span class=\"token operator\">=</span> <span class=\"token class-name\">MockWebServer</span><span class=\"token punctuation\">(</span>port<span class=\"token punctuation\">:</span> <span class=\"token number\">8081</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">setUp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// APIエンドポイントを[MockWebServer]にすげ替えるためにテスト用の.envファイルを読み込む．</span>\n    <span class=\"token comment\">// HttpClientがbaseUrlを保持するパターンもあるが，全てのAPIが単一のbaseUrlからされない場合もあるので</span>\n    <span class=\"token comment\">// このようにしておく．</span>\n    <span class=\"token keyword\">await</span> dotenv<span class=\"token punctuation\">.</span><span class=\"token function\">load</span><span class=\"token punctuation\">(</span>fileName<span class=\"token punctuation\">:</span> <span class=\"token string\">'.env.test'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    server<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token function\">tearDown</span><span class=\"token punctuation\">(</span>server<span class=\"token punctuation\">.</span>shutdown<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// エラー時のテストケースについては，エラーハンドラを`request`メソッドの実装に持たせたり</span>\n  <span class=\"token comment\">// interceptorで挟んだりするためHttpClientやmixinのテストで記述する．</span>\n  <span class=\"token comment\">// したがって個々のRequestクラスのテストケースはシンプルに保つことができる．</span>\n  <span class=\"token function\">test</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ListFooRequest returns list of Foo'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// ここではJSONの構築に[dart:convert#jsonEncode]を用いた．</span>\n    <span class=\"token comment\">// `json_serializable` が生成する`toJson`メソッドで適当なレスポンスを組み立ててもよい．</span>\n    <span class=\"token keyword\">final</span> body <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token string\">'foos'</span><span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span><span class=\"token comment\">/* Foo モデル */</span><span class=\"token punctuation\">]</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n    server<span class=\"token punctuation\">.</span><span class=\"token function\">enqueue</span><span class=\"token punctuation\">(</span>httpCode<span class=\"token punctuation\">:</span> <span class=\"token number\">200</span><span class=\"token punctuation\">,</span> body<span class=\"token punctuation\">:</span> <span class=\"token function\">jsonEncode</span><span class=\"token punctuation\">(</span>body<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">final</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token class-name\">ListFooRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">request</span><span class=\"token punctuation\">(</span>httpClient<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">,</span> isA<span class=\"token generics\"><span class=\"token punctuation\">&#x3C;</span><span class=\"token class-name\">List</span><span class=\"token punctuation\">&#x3C;</span><span class=\"token class-name\">Foo</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span></span>\n</code></pre></div>\n<h2 id=\"repository\"><a href=\"#repository\">Repository</a></h2>\n<p>Repositoryクラスはデータ取得及びデータの更新操作を行います．<br>\nここではAPIからのリモートデータリソースのみを扱っていますが，<a href=\"https://pub.dev/packages/shared_preferences\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">shared_preferences</a>やKeychain/KeyStoreを利用したローカルデータソースに対する操作も責務に含まれます．</p>\n<p>RepositoryクラスはViewModelレイヤから利用されるのですが，Repositoryクラスはネットワークアクセスが行われるためViewModelクラスの内部でRepositoryクラスを初期化してしまうとViewModelのテストが困難になります．<br>\nかといってViewModelクラスのコンストラクタにRepositoryクラスを引数として渡す場合，そのViewModelクラスを利用するViewでRepositoryクラスを作成してViewModelを得る必要が出てしまい，レイヤ跨ぎ(View -> Repository)が発生してしまいます．</p>\n<p>これを解消するためにDI(Dependency Injection)を用いて各レイヤ間の結合をDIプロバイダに委任します．</p>\n<p>Repositoryインスタンスには<a href=\"https://pub.dev/packages/riverpod\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">riverpod</a>の提供する<code>Provider</code>を介してアクセスするようにします．\nそのために<code>FooRepository</code>にはパブリックなコンストラクタを実装せずプライベートコンストラクタ<code>._()</code>のみを定義し，外部ファイルから<code>FooRepository</code>インスタンスを直接立ち上げることを禁止します．</p>\n<div class=\"remark-highlight\"><pre data-file=\"foo_repository.dart\" class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">final</span> fooRepositoryProvider <span class=\"token operator\">=</span> <span class=\"token class-name\">Provider</span><span class=\"token generics\"><span class=\"token punctuation\">&#x3C;</span><span class=\"token class-name\">FooRepository</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>\n  <span class=\"token punctuation\">(</span>ref<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token class-name\">FooRepository</span><span class=\"token punctuation\">.</span><span class=\"token function\">_</span><span class=\"token punctuation\">(</span>ref<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>httpClientProvider<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>また，(一般的なアーキテクチャにおける)Repositoryクラスは永続化層と表現されることもあり，その文脈ではキャッシュ機構を持つことがあります．<br>\n仮に<code>FooRepository</code>がキャッシュ機構を持つとした場合，そのテストがどのように記述されるべきかを見ていきます．</p>\n<p><code>FooRepository</code>がキャッシュ機構を持つ場合，リモートデータソースとキャッシュとの整合性の不一致が生じえます．\n例えば<code>create</code>を呼んだ後に<code>list</code>を実行すると，<code>create</code>したデータが含まれないキャッシュが返されるなどが考えられます．<br>\nデータの整合性を担保するにはいくつか方法がありますが，ここではシンプルにキャッシュの破棄操作を行う実装を行うとしましょう．</p>\n<div class=\"remark-highlight\"><pre data-file=\"foo_repository.dart\" class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">FooRepository</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token class-name\">FooRepository</span><span class=\"token punctuation\">.</span><span class=\"token function\">_</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>_httpClient<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">final</span> <span class=\"token class-name\">HttpClient</span> _httpClient<span class=\"token punctuation\">;</span>\n  <span class=\"token class-name\">List</span><span class=\"token generics\"><span class=\"token punctuation\">&#x3C;</span><span class=\"token class-name\">Foo</span><span class=\"token punctuation\">></span></span><span class=\"token operator\">?</span> _cache<span class=\"token punctuation\">;</span>\n\n  <span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&#x3C;</span><span class=\"token class-name\">List</span><span class=\"token punctuation\">&#x3C;</span><span class=\"token class-name\">Foo</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> <span class=\"token function\">list</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>_cache <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> _cache<span class=\"token punctuation\">;</span>\n\n    _cache <span class=\"token operator\">=</span> <span class=\"token class-name\">ListFooRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">request</span><span class=\"token punctuation\">(</span>_httpClient<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> _cache<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// Requestクラスの説明では省略した[CreateFooRequest]を用いて</span>\n  <span class=\"token comment\">// [Foo]レコードを作成するリクエストを行う．</span>\n  <span class=\"token comment\">// [CreateFoo]クラスは[Foo]レコードを作成する際のDTO.</span>\n  <span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&#x3C;</span><span class=\"token class-name\">Foo</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">create</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CreateFoo</span> createFoo<span class=\"token punctuation\">)</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">{</span>\n    _cache <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">await</span> <span class=\"token class-name\">CreateFooRequest</span><span class=\"token punctuation\">(</span>createFoo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">request</span><span class=\"token punctuation\">(</span>_httpClient<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<h3 id=\"test-1\"><a href=\"#test-1\">test</a></h3>\n<p>Repositoryクラスはデータ取得・更新操作を行い，データの整合性を担保します．\nRepositoryクラスのユースケースにおいては，その内部にキャッシュ機構があるかどうか，またはインメモリデータベースを利用しているかどうかは隠蔽されているべきです．\nしたがって実装の詳細には触れず，その振る舞いのみを保証するにはテストデータ更新後に最新のデータを返すかどうかを確認すれば良さそうです．</p>\n<p>次にテスト容易性を主軸にRepositoryクラスをどのように提供するか考察します．<br>\nRepositoryクラスはその責務上複数のAPIクライアントクラスを操作するため，テストのタイミングではAPIクライアントクラスもしくはその処理のモックが必要となります．\nRepositoryクラスにおいてもどのレイヤーをモックするかが設計のポイントとなるのですが，Repositoryクラスのコンストラクタに渡される<code>HttpClient</code>をモックする方針をとります．<br>\n判断に至った思考仮定は次のようなものです;</p>\n<p><strong>A. APIクライアントのテストのようにAPIサーバをモックする場合</strong><br>\nこの場合Repositoryクラスが扱う各APIクライアントクラスに対するモックAPIサーバの設定を記述する必要があります．\nこの設定にはエンドポイントのURLやレスポンスのJSONスキーマ定義など，APIクライアントクラスの責務となる詳細部分が必要なので，\nAPIクライアントの実装を変更することでRepositoryクラスのテストがfailする可能性があり，修正に脆いテストとなり得ます．</p>\n<p><strong>B. 個々のAPIクライアントクラスをモックする場合</strong><br>\n先に示した<code>FooRepository</code>クラスの実装ではAPIクライアントクラスをハードコードして利用しています．<br>\nAPIクライアントクラスをモックする場合には各APIクライアントクラスをDIするかコンストラクタの引数として受け取るような実装をする必要が生じます．<br>\n(callerの直接の)コンストラクタでの引数渡しについては先に述べたとおり抽象化レイヤを跨いでしまうため避けたいです．<br>\nまたAPIクライアントクラスはRepositoryクラスにとってStatic Dependency<sup><a href=\"#user-content-fn-1\" id=\"user-content-fnref-1\" data-footnote-ref aria-describedby=\"footnote-label\">1</a></sup>であり，また各APIクライアントクラスをDIすることはOver-Injection<sup><a href=\"#user-content-fn-2\" id=\"user-content-fnref-2\" data-footnote-ref aria-describedby=\"footnote-label\">2</a></sup>に繋がるのでこれもベストとは言い難いです．</p>\n<p><strong>C. HttpClientをモックする場合</strong><br>\nAではネットワーク先，BではAPIクライアントの振る舞いをそれぞれスタブする方針でした．<br>\nAPIクライアントクラスが利用する<code>HttpClient</code>をモックすることで，APIクライアントのネットワークリクエスト処理のみをスタブすることができます．<br>\nAPIクライアントクラスが<code>HttpClient</code>を利用する処理はmixinとして実装を与えてあるため，個々のAPIクライアントクラスの振る舞いには左右されず修正に強いテストが期待できます．\nまたBと比較してもDIする対象が1つで済むため適切であると言えます．</p>\n<p><div class=\"remark-container warn\"><div class=\"remark-container__title\">FooRepositoryのコンストラクタについて</div>FooRepository内部で直接ProviderをService Locatorとして利用することを避けるために，HttpClientをコンストラクタの引数として渡すような設計になっています．</div></p>\n<p>テストコードで<code>HttpClient</code>をProviderから受け取るには<code>ProviderContainer</code>を利用します．<br>\n<code>ProviderContainer</code>の引数にDIプロバイダのオーバーライド設定を指定することで，テスト内では<code>mockHttpClient</code>を利用するRepositoryクラスを利用することができます．</p>\n<div class=\"remark-highlight\"><pre data-file=\"foo_repository_test.dart\" class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">final</span> container <span class=\"token operator\">=</span> <span class=\"token class-name\">ProviderContainer</span><span class=\"token punctuation\">(</span>\n    overrides<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>httpClientProvider<span class=\"token punctuation\">.</span><span class=\"token function\">overrideWithValue</span><span class=\"token punctuation\">(</span>mockHttpClient<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">final</span> repository <span class=\"token operator\">=</span> container<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>fooRepositoryProvider<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>データ整合性のテストはユースケースを元に，<code>create</code>メソッド実行後に<code>list</code>メソッドの実行結果が<code>create</code>したデータを含むかどうかを確認します．</p>\n<p><small>もちろん<code>list</code>メソッド単体のテストは書く前提です.</small></p>\n<div class=\"remark-highlight\"><pre data-file=\"foo_repository_test.dart\" class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// omitted</span>\n\n  <span class=\"token comment\">// HttpClientの挙動をスタブ</span>\n  <span class=\"token function\">when</span><span class=\"token punctuation\">(</span>mockHttpClient<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>any<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">thenAnswer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">)</span> <span class=\"token keyword\">async</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> listFooResponse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> repository<span class=\"token punctuation\">.</span><span class=\"token function\">list</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// verify(mockHttpClient.get(any)) として</span>\n  <span class=\"token comment\">// **内部でmockHttpClientが呼ばれた**ことをテストすることも可能だが，</span>\n  <span class=\"token comment\">// ここではRepositoryクラスの振る舞いを見ることを主軸に置くためテストに含めない．</span>\n  <span class=\"token comment\">// 実際のユースケースではRepositoryクラスはProvider経由で利用され，</span>\n  <span class=\"token comment\">// HttpClientはProvider内部で渡されるため利用する側からはHttpClientはされている.</span>\n  <span class=\"token comment\">// あくまでテストにおいてのみRepositoryクラスがHttpClientを利用していることを知る必要が生じている．</span>\n  <span class=\"token comment\">//</span>\n  <span class=\"token comment\">// ListFooRequestの結果が返される</span>\n  <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">,</span> listFooResponse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// create時の挙動をスタブ</span>\n  <span class=\"token function\">when</span><span class=\"token punctuation\">(</span>mockHttpClient<span class=\"token punctuation\">.</span><span class=\"token function\">post</span><span class=\"token punctuation\">(</span>any<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">thenAnswer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">)</span> <span class=\"token keyword\">async</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> createResponse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">final</span> createFoo <span class=\"token operator\">=</span> <span class=\"token class-name\">CreateFoo</span><span class=\"token punctuation\">(</span><span class=\"token comment\">/* */</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> repository<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>createFoo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">,</span> createResponse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// 再度Listした際に更新されたResponseが返される</span>\n  <span class=\"token function\">when</span><span class=\"token punctuation\">(</span>mockHttpClient<span class=\"token punctuation\">.</span><span class=\"token keyword\">get</span><span class=\"token punctuation\">(</span>any<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">thenAnswer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">)</span> <span class=\"token keyword\">async</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> updatedListResponse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  response <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> repository<span class=\"token punctuation\">.</span><span class=\"token function\">list</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>response<span class=\"token punctuation\">,</span> updatedListResponse<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<h2 id=\"viewmodel\"><a href=\"#viewmodel\">ViewModel</a></h2>\n<p>ViewModelはViewが利用するデータ及びロジックを提供します．<br>\nここが一番責務をどこにおくか悩むところだと思うので，ViewModelの定義について John Gossman. (2005)<sup><a href=\"#user-content-fn-3\" id=\"user-content-fnref-3\" data-footnote-ref aria-describedby=\"footnote-label\">3</a></sup>を紹介します．</p>\n<blockquote>\n<p>The UI may want to perform complex operations that must be implemented in code which doesn't make sense in our strict definition of the View but are too specific to be included in the Model (or didn't come with the pre-existing model).\nFinally we need a place to put view state such as selection or modes.</p>\n<p>The ViewModel is responsible for these tasks.\nThe term means \"Model of a View\", and can be thought of as abstraction of the view,\nbut it also provides a specialization of the Model that the View can use for data-binding.\nIn this latter role the ViewModel contains data-transformers that convert Model types into View types, and it contains Commands the View can use to interact with the Model.</p>\n</blockquote>\n<p>ここで示したいのはViewModelはViewとのデータバインディングだけではなく，Viewが行う複雑な操作(=ドメインロジック)をも責務に含むという点です．\nこれは逆にViewにそのような処理をもたせてはいけないというだけなので，ViewModelまたはServiceレイヤに持たせるようにします．<br>\nViewModelからはViewでの操作のハンドラを提供し，ViewからServiceクラスを直接呼ぶことのないようにします．<br>\n例外的にpull-to-refreshのように描画・アニメーションがメインとなるロジックや，<code>BuildContext</code>を介する処理(例: <code>Navigator.push</code>等)についてはView側の責務となります．</p>\n<p>また，テスト容易性の観点からはMartin Fowler氏のHumble Object<sup><a href=\"#user-content-fn-4\" id=\"user-content-fnref-4\" data-footnote-ref aria-describedby=\"footnote-label\">4</a></sup>をイメージするとViewとViewModelとのそれぞれの責務の切り分けがしやすいかと思います．</p>\n<p>Viewのテストを考慮すると，View内部でViewModelをイニシャライズするとViewModelのモックがやや手間になります．<br>\nしたがってViewModelにおいてもProviderを利用して提供します．</p>\n<p>ここで，ViewModelのライフサイクルをどうするか検討しましょう．<br>\nViewModelがViewを参照しない・してはならないことからもわかるように，ViewModelとViewとのライフサイクルは異なります．\nしかしViewインスタンスが破棄された後にViewModelが生き続けると，再度Viewが生成された際にその(中途半端な状態を持つ)ViewModelが参照されると困るケースもあります．\nそういったケースでは<code>StateNotifierProvider.autoDispose</code>を用いてViewModelのライフサイクルをViewに揃え，Viewが生成されるタイミングでViewModelを生成してデータの整合性を担保するようにします．</p>\n<div class=\"remark-highlight\"><pre data-file=\"view_model.dart\" class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">final</span> fooViewModelProvider <span class=\"token operator\">=</span> <span class=\"token class-name\">StateNotifierProvider</span><span class=\"token punctuation\">.</span>autoDispose<span class=\"token generics\"><span class=\"token punctuation\">&#x3C;</span><span class=\"token class-name\">FooViewModel</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">FooState</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>\n  <span class=\"token punctuation\">(</span>ref<span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token class-name\">WaitingListViewModel</span><span class=\"token punctuation\">(</span>\n    fooRepository<span class=\"token punctuation\">:</span> ref<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>fooRepositoryProvider<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre></div>\n<p>ViewModelが持つ状態はたとえ変数が1つであってもクラスとして切り出し，内包する状態が増えた際に変更に対して閉じるようにします．</p>\n<div class=\"remark-highlight\"><pre data-file=\"view_model.dart\" class=\"language-dart\"><code class=\"language-dart\"><span class=\"token metadata symbol\">@freezed</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">FooState</span> <span class=\"token keyword\">with</span> _$<span class=\"token class-name\">FooState</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token keyword\">factory</span> <span class=\"token class-name\">FooState</span><span class=\"token punctuation\">.</span><span class=\"token function\">_</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    required <span class=\"token class-name\">AsyncValue</span><span class=\"token generics\"><span class=\"token punctuation\">&#x3C;</span><span class=\"token class-name\">List</span><span class=\"token punctuation\">&#x3C;</span><span class=\"token class-name\">Foo</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> foos<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span> _FooState<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<p>今回はViewがpull-to-refresh機能を提供するとして設計します．\nその場合，Viewで必要となるロジックは以下のようなデータ及びイベントハンドラが考えられます；</p>\n<ul>\n<li>Viewで描画するデータ(<code>List&#x3C;Foo></code>)</li>\n<li>View作成時のViewModelの初期化処理(<code>onInit</code>)</li>\n<li>pull-to-refresh実行時のリフレッシュ処理(<code>onRefresh</code>)</li>\n<li><code>Foo</code>の追加処理(<code>createFoo(CreateFoo foo)</code>)</li>\n</ul>\n<p>また描画するデータ<code>List&#x3C;Foo></code>はAPIから取得するため，初期状態はデータを保持しておらずローディング中・ローディング失敗の状態も考えられます．\nそういったケースに対応するため<code>Future</code>の値の変化を検知・通知できる<a href=\"https://pub.dev/documentation/riverpod/latest/riverpod/AsyncValue-class.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><code>AsyncValue</code></a>を利用します．</p>\n<p>それぞれを実装におとすと次のようになります．</p>\n<div class=\"remark-highlight\"><pre data-file=\"view_model.dart\" class=\"language-dart\"><code class=\"language-dart\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">FooViewModel</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">StateNotifier</span><span class=\"token generics\"><span class=\"token punctuation\">&#x3C;</span><span class=\"token class-name\">FooState</span><span class=\"token punctuation\">></span></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token class-name\">FooViewModel</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>required <span class=\"token class-name\">FooRepository</span> fooRepository<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">:</span> _repository <span class=\"token operator\">=</span> fooRepository<span class=\"token punctuation\">,</span>\n        <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token class-name\">FooState</span><span class=\"token punctuation\">.</span><span class=\"token function\">_</span><span class=\"token punctuation\">(</span>foos<span class=\"token punctuation\">:</span> <span class=\"token class-name\">AsyncValue</span><span class=\"token punctuation\">.</span><span class=\"token function\">loading</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// construct時に初期化処理`onInit`を実行</span>\n    <span class=\"token function\">onInit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">final</span> <span class=\"token class-name\">FooRepository</span> _repository<span class=\"token punctuation\">;</span>\n\n  <span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&#x3C;</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">onInit</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 今回の例では簡単のため`onRefresh`を呼ぶだけ</span>\n    <span class=\"token keyword\">await</span> <span class=\"token function\">onRefresh</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&#x3C;</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">createFoo</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CreateFoo</span> foo<span class=\"token punctuation\">)</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">await</span> _repository<span class=\"token punctuation\">.</span><span class=\"token function\">create</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">await</span> <span class=\"token function\">onRefresh</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">catchError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// TODO</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&#x3C;</span><span class=\"token keyword\">void</span><span class=\"token punctuation\">></span></span> <span class=\"token function\">onRefresh</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">await</span> _repository<span class=\"token punctuation\">.</span><span class=\"token function\">list</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      state <span class=\"token operator\">=</span> state<span class=\"token punctuation\">.</span><span class=\"token function\">copyWith</span><span class=\"token punctuation\">(</span>foos<span class=\"token punctuation\">:</span> <span class=\"token class-name\">AsyncValue</span><span class=\"token punctuation\">.</span><span class=\"token function\">data</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">catchError</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      state <span class=\"token operator\">=</span> state<span class=\"token punctuation\">.</span><span class=\"token function\">copyWith</span><span class=\"token punctuation\">(</span>foos<span class=\"token punctuation\">:</span> <span class=\"token class-name\">AsyncValue</span><span class=\"token punctuation\">.</span><span class=\"token function\">error</span><span class=\"token punctuation\">(</span>e <span class=\"token operator\">as</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n</code></pre></div>\n<h3 id=\"test-2\"><a href=\"#test-2\">test</a></h3>\n<p>ViewModelはViewが利用するデータ及びロジックの提供を責務とします．<br>\nViewModelのテストですが，単体でのテストを行うかViewと組み合わせたテストを行うか正直自分の中で答えを出せていません．\nViewの持つロジックを極力薄くすることで，擬似的にViewの取りうる振る舞いをViewModelでテストすることは可能です．ただViewModelの取りうる状態に応じた描画はViewでのテストでしか担保することができず，かつそれらは無視できる量・質のものとは言い難いです．<br>\nそのためViewはViewのテストが必要となりますが，ViewModelが示す状態に沿う描画ができているかを検査すればよいので，ある程度宣言的にテストを記述できます．</p>\n<p>実際，実機での<a href=\"https://flutter.dev/docs/cookbook/testing/integration/introduction\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">integration_test</a>や回帰テストを行う<a href=\"https://pub.dev/packages/golden_toolkit\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">golden toolkit</a>などViewを対象としたテストツールも充実してきておりそれらを用いることで描画内容にとどまらないデザインのテストをも行うことが可能となってきています．</p>\n<p>ただ，そこに実際のViewModelを持ち込むかモックしたViewModelを持ち込むかは明確な判断理由を持てていません．<br>\nここではテスト容易性を主軸においたアーキテクチャの紹介を行い，いわゆるUIテストについては上記の説明に留めることとします．</p>\n<hr>\n<p>先程実装した<code>FooRepository</code>はProvider経由のみのアクセスとするためにパブリックなコンストラクタを公開していませんでした．\n直接インスタンスを生成できないというのも理由のひとつですが，<code>FooRepository</code>は内部でネットワークリクエストを行うためどのみちそのまま扱うことができません．<br>\nそのため<code>FooRepository</code>のモックオブジェクトを生成し，<code>fooRepositoryProvider</code>に注入して<code>FooViewModel</code>から<code>MockFooRepository</code>が参照されるように設定します．</p>\n<p>今回利用するモックライブラリ<a href=\"https://pub.dev/packages/mockito\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">mockito</a>が生成するモックは，次のように対象のクラスを<code>implements</code>する形で実装されます．<br>\nパブリックなコンストラクタを自動で生成してくれるので，<code>MockFooRepository</code>インスタンスを用いて<code>fooRepositoryProvider</code>を上書きできます．</p>\n<div class=\"remark-highlight\"><pre data-file=\"foo_repository.mocks.dart\" class=\"language-dart  line-numbers\"><code class=\"language-dart\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MockFooRepository</span> <span class=\"token keyword\">extends</span> _i1<span class=\"token punctuation\">.</span>Mock <span class=\"token keyword\">implements</span> _i2<span class=\"token punctuation\">.</span>FooRepository <span class=\"token punctuation\">{</span>\n  <span class=\"token class-name\">MockFooRepository</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    _i1<span class=\"token punctuation\">.</span><span class=\"token function\">throwOnMissingStub</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token metadata symbol\">@override</span>\n  _i3<span class=\"token punctuation\">.</span>Future<span class=\"token generics\"><span class=\"token punctuation\">&#x3C;</span><span class=\"token class-name\">List</span><span class=\"token punctuation\">&#x3C;</span><span class=\"token class-name\">Foo</span><span class=\"token punctuation\">></span><span class=\"token punctuation\">></span></span> <span class=\"token function\">list</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token punctuation\">(</span><span class=\"token comment\">/* omitted */</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span></span>\n</code></pre></div>\n<p>今回はViewModelとViewを共に扱いテストを行います．\nここでは<code>FooViewModel</code>を利用するViewを<code>FooView</code>とします．</p>\n<div class=\"remark-highlight\"><pre data-file=\"foo_view_model_test.dart\" class=\"language-dart  line-numbers\"><code class=\"language-dart\"><span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">final</span> repository <span class=\"token operator\">=</span> <span class=\"token class-name\">MockFooRepository</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">final</span> container <span class=\"token operator\">=</span> <span class=\"token class-name\">ProviderContainer</span><span class=\"token punctuation\">(</span>\n    overrides<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>fooRepositoryProvider<span class=\"token punctuation\">.</span><span class=\"token function\">overrideWithValue</span><span class=\"token punctuation\">(</span>repository<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token comment\">// repositoryのmock等を行う</span>\n\n  <span class=\"token function\">testWidgets</span><span class=\"token punctuation\">(</span><span class=\"token string\">'FooViewModel smoke test with view'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">WidgetTester</span> tester<span class=\"token punctuation\">)</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">final</span> widget <span class=\"token operator\">=</span> <span class=\"token class-name\">ProviderScope</span><span class=\"token punctuation\">(</span>\n      overrides<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">[</span>fooRepositoryProvider<span class=\"token punctuation\">.</span><span class=\"token function\">overrideWithValue</span><span class=\"token punctuation\">(</span>repository<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      child<span class=\"token punctuation\">:</span> <span class=\"token keyword\">const</span> <span class=\"token class-name\">MaterialApp</span><span class=\"token punctuation\">(</span>home<span class=\"token punctuation\">:</span> <span class=\"token class-name\">FooView</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">await</span> tester<span class=\"token punctuation\">.</span><span class=\"token function\">runAsync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">await</span> tester<span class=\"token punctuation\">.</span><span class=\"token function\">pumpWidget</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// 初期状態の確認.</span>\n      <span class=\"token comment\">// APIリクエストが完了していないのでデータローディングの旨を表示したい</span>\n      <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>find<span class=\"token punctuation\">.</span><span class=\"token function\">text</span><span class=\"token punctuation\">(</span><span class=\"token string\">'データ読み込み中'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> findsOneWidget<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// 描画更新を更新.</span>\n      <span class=\"token comment\">// APIリクエストが完了している(ようレスポンスをスタブする)ので</span>\n      <span class=\"token comment\">// ローディングが完了しデータが描画されていることを確認</span>\n      <span class=\"token comment\">// (レスポンスはListViewで描画しているとする)</span>\n      <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>find<span class=\"token punctuation\">.</span><span class=\"token function\">text</span><span class=\"token punctuation\">(</span><span class=\"token string\">'データ読み込み中'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> findsNothing<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span>find<span class=\"token punctuation\">.</span><span class=\"token function\">byType</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListView</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> findsOneWidget<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n      <span class=\"token comment\">// pull to refresh 実行</span>\n      <span class=\"token comment\">// pull to refreshをテスト上でimitateする処理は以下を参照</span>\n      <span class=\"token comment\">// @see: <a href=\"https://github.com/flutter/flutter/blob/d62f75dde1cb6f04fadb9aff48896491ff0e2163/packages/flutter/test/material/refresh_indicator_test.dart#L119-L122\" class=\"token url-link\">https://github.com/flutter/flutter/blob/d62f75dde1cb6f04fadb9aff48896491ff0e2163/packages/flutter/test/material/refresh_indicator_test.dart#L119-L122</a></span>\n      <span class=\"token function\">when</span><span class=\"token punctuation\">(</span>repository<span class=\"token punctuation\">.</span><span class=\"token function\">list</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">thenAnswer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>_<span class=\"token punctuation\">)</span> <span class=\"token keyword\">async</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token comment\">/* response */</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">await</span> tester<span class=\"token punctuation\">.</span><span class=\"token function\">fling</span><span class=\"token punctuation\">(</span>find<span class=\"token punctuation\">.</span><span class=\"token function\">byType</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ListView</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">const</span> <span class=\"token class-name\">Offset</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">300</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">await</span> tester<span class=\"token punctuation\">.</span><span class=\"token function\">pump</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">await</span> tester<span class=\"token punctuation\">.</span><span class=\"token function\">pump</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> <span class=\"token class-name\">Duration</span><span class=\"token punctuation\">(</span>seconds<span class=\"token punctuation\">:</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// responseが更新されていることを確認</span>\n      <span class=\"token function\">expect</span><span class=\"token punctuation\">(</span><span class=\"token comment\">/* */</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span><span class=\"\"></span></span>\n</code></pre></div>\n<p>同様にしてRepositoryから<code>Future.error</code>を返すことでWidgetのエラー時の描画のテストを行うことが可能です．</p>\n<h3 id=\"viewmodelとservice-class\"><a href=\"#viewmodel%E3%81%A8service-class\">ViewModelとService class</a></h3>\n<p>ViewModelの処理をどのタイミングでServiceクラスへ委譲するかの基準は，<a href=\"https://docs.microsoft.com/en-us/visualstudio/test/unit-test-basics?view=vs-2019#write-your-tests\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Arrange-Act-Assert</a>におけるArrange<sup><a href=\"#user-content-fn-6\" id=\"user-content-fnref-6\" data-footnote-ref aria-describedby=\"footnote-label\">5</a></sup>のコストを一つの目安とすることができます．<br>\nテストの準備の記述(Arrange)が少なくない割合を占める場合，テスト対象が状態や責務を持ちすぎている可能性があります．\nそうなった場合にはArrangeの記述及びViewModelのメソッドの処理からテスト(の準備が)しづらいメソッドを探しだしてServiceクラスへ抽出します．\nそうすることでテスト容易性を高め，かつテスト対象の関心の対象を絞ることで壊れづらいテストコードを保つことが可能です．</p>\n<p><small>このアプローチは実際テスト対象とレイヤーの異なる責務を見分けて分離するには便利な手法だと感じています</small></p>\n<p>補足:<br>\nSOLID原則の<a href=\"https://en.wikipedia.org/wiki/Single-responsibility_principle\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Single-responsibility principle</a>は\"1つのクラスは1つの責務\"といった説明がされがちですが，真意は\"1つのクラスは1つの(アクターに対し)責務(を負う)\"ということです．<br>\nViewModelは責務が多くなりがちですが，対応するViewに対してのみ責務を追っているためSRPの観点からは適切です．<br>\nただしViewModelのメソッドの処理をテストする際にViewModelがServiceクラスのアクターになれる場合においては，それはメソッドの処理をServiceクラスへと切り出すタイミングだと思います．</p>\n<hr>\n<p>以上，テスト容易性を意識したFlutterアプリケーションのアーキテクチャを考察していきました．\n長くなってスマン.</p>\n<p>Dartの型システムは比較的緩いので，そういった言語特性も含めテストでカバーしていきたい気持ちがあり今回このような検討を行いました．<br>\n結合度と凝集度など関数レベルでの設計やTDDなどのプラクティスはもちろん，アーキテクチャレベルで考慮することで更にテスト容易性を向上することができ，またソフトウェアの品質を担保することに繋がります．</p>\n<small>\n  半年とか経ったら振り返りをしようと考えています．  \n</small>\n<section data-footnotes class=\"footnotes\"><h2 id=\"footnote-label\" class=\"sr-only\">Footnotes</h2>\n<ol>\n<li id=\"user-content-fn-1\">\n<p><a href=\"https://livebook.manning.com/book/dependency-injection-principles-practices-patterns/about-this-book/1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Dependency Injection principles, Manning</a>. volatile dependency/static dependency <a href=\"#user-content-fnref-1\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\">↩</a></p>\n</li>\n<li id=\"user-content-fn-2\">\n<p><a href=\"https://blog.ploeh.dk/2018/08/27/on-constructor-over-injection/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://blog.ploeh.dk/2018/08/27/on-constructor-over-injection/</a> <a href=\"#user-content-fnref-2\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\">↩</a></p>\n</li>\n<li id=\"user-content-fn-3\">\n<p><a href=\"https://docs.microsoft.com/en-us/archive/blogs/johngossman/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://docs.microsoft.com/en-us/archive/blogs/johngossman/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps</a> <a href=\"#user-content-fnref-3\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\">↩</a></p>\n</li>\n<li id=\"user-content-fn-4\">\n<p><a href=\"https://martinfowler.com/bliki/HumbleObject.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://martinfowler.com/bliki/HumbleObject.html</a> <a href=\"#user-content-fnref-4\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\">↩</a></p>\n</li>\n<li id=\"user-content-fn-6\">\n<p>またはHeuristics of Software TestabilityにおけるControllability/Decomposability. <a href=\"#user-content-fnref-6\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\">↩</a></p>\n</li>\n</ol>\n</section>","description":"MVVM architecture with Repository pattern, state_notifier and riverpod","commits":[{"title":"fix","date":"2021-10-26 12:59:58","hash":"04af4b49","diff":"<div class=\"remark-highlight\"><pre data-file=\"04af4b49.patch\" class=\"language-git  language-diff\"><code class=\"language-git\"><span class=\"token commit-sha1\">commit 04af4b49794e94e2e6766510580c29c00a2c257a</span>\nAuthor: koka &#x26;<a href=\"mailto:lt;koka.code@gmail.com\" class=\"token email-link\">lt;koka.code@gmail.com</a>&#x26;gt;\nDate:   Tue Oct 26 12:59:58 2021 +0900\n\n  fix\n\ndiff --git a/_posts/2021-10-20-testable-architecture-flutter.md b/_posts/2021-10-20-testable-architecture-flutter.md\nindex 90ba4f9..81bc4d0 100644\n<span class=\"token deleted\">--- a/_posts/2021-10-20-testable-architecture-flutter.md</span>\n<span class=\"token inserted\">+++ b/_posts/2021-10-20-testable-architecture-flutter.md</span>\n@@ -326,7 +326,7 @@ ViewModelがViewを参照しない・してはならないことからもわか\n\\```dart[data-file=<span class=\"token string\">\"view_model.dart\"</span>]\nfinal fooViewModelProvider = StateNotifierProvider.autoDispose&#x26;lt;FooViewModel, FooState&#x26;gt;(\n (ref) =&#x26;gt; WaitingListViewModel(\n<span class=\"token deleted\">-    insuranceRepository: ref.read(insuranceRepositoryProvider),</span>\n<span class=\"token inserted\">+    fooRepository: ref.read(fooRepositoryProvider),</span>\n ),\n);\n\\```\n</code></pre></div>"},{"title":"fix publish date","date":"2021-10-25 23:27:04","hash":"c6cee325","diff":"<div class=\"remark-highlight\"><pre data-file=\"c6cee325.patch\" class=\"language-git  language-diff\"><code class=\"language-git\"><span class=\"token commit-sha1\">commit c6cee325763ea715072dc0671967db3042ca63c2</span>\nAuthor: koka &#x26;<a href=\"mailto:lt;koka.code@gmail.com\" class=\"token email-link\">lt;koka.code@gmail.com</a>&#x26;gt;\nDate:   Mon Oct 25 23:27:04 2021 +0900\n\n  fix publish date\n\ndiff --git a/_posts/2021-10-20-testable-architecture-flutter.md b/_posts/2021-10-20-testable-architecture-flutter.md\nindex 0fd6cde..90ba4f9 100644\n<span class=\"token deleted\">--- a/_posts/2021-10-20-testable-architecture-flutter.md</span>\n<span class=\"token inserted\">+++ b/_posts/2021-10-20-testable-architecture-flutter.md</span>\n<span class=\"token coord\">@@ -1,6 +1,6 @@</span>\n<span class=\"token deleted\">---</span>\ntitle: テスト容易性を考慮したFlutterのアーキテクチャ考察\n<span class=\"token deleted\">-date: 2021-10-20</span>\n<span class=\"token inserted\">+date: 2021-10-25</span>\ncategories:\n<span class=\"token deleted\">- Programming</span>\ntags:\n</code></pre></div>"},{"title":"publish: テスト容易性を考慮したFlutterのアーキテクチャ考察","date":"2021-10-25 23:22:57","hash":"77ea8468","diff":"<div class=\"remark-highlight\"><pre data-file=\"77ea8468.patch\" class=\"language-git  language-diff\"><code class=\"language-git\"><span class=\"token commit-sha1\">commit 77ea846835d033ba818e33830a7a6e2be156553e</span>\nAuthor: koka &#x26;<a href=\"mailto:lt;koka.code@gmail.com\" class=\"token email-link\">lt;koka.code@gmail.com</a>&#x26;gt;\nDate:   Mon Oct 25 23:22:57 2021 +0900\n\n  publish: テスト容易性を考慮したFlutterのアーキテクチャ考察\n\ndiff --git a/_posts/2021-10-20-testable-architecture-flutter.md b/_posts/2021-10-20-testable-architecture-flutter.md\nnew file mode 100644\nindex 0000000..0fd6cde\n<span class=\"token deleted\">--- /dev/null</span>\n<span class=\"token inserted\">+++ b/_posts/2021-10-20-testable-architecture-flutter.md</span>\n<span class=\"token coord\">@@ -0,0 +1,524 @@</span>\n<span class=\"token inserted\">+---</span>\n<span class=\"token inserted\">+title: テスト容易性を考慮したFlutterのアーキテクチャ考察</span>\n<span class=\"token inserted\">+date: 2021-10-20</span>\n<span class=\"token inserted\">+categories:</span>\n<span class=\"token inserted\">+- Programming</span>\n<span class=\"token inserted\">+tags:</span>\n<span class=\"token inserted\">+- Flutter</span>\n<span class=\"token inserted\">+description: MVVM architecture with Repository pattern, state_notifier and riverpod</span>\n<span class=\"token inserted\">+---</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+ここ半年ほどFlutterを書いていて，アプリケーションのアーキテクチャで試行錯誤してます．状態管理ムズくない？  </span>\n<span class=\"token inserted\">+なのでいっそ表に出して意見もらえたらな，と思ったので書きます．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+本記事では，Flutterアプリケーションにおいてテスト容易性を向上するためにはどうすればいいか，サンプルアプリケーションを例題にアーキテクチャレベルで検討します．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+## アーキテクチャの目的</span>\n<span class=\"token inserted\">+今回は**テスト容易性**を主軸に置いたアーキテクチャ選定を行いました．</span>\n<span class=\"token inserted\">+特にFlutterの単体テストはネットワークリクエストが遮断されるので，副作用を伴う処理を行うレイヤを適切に分離し，テストが容易になるよう設計を行うこととしました．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+アーキテクチャは何かしら課題を解決するために設計されるもの(だと思っている)なので，今回示す例が必ずしもベストなものとは限らないです．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+### テスト容易性とは</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+テスト容易性とは，James Bachが提唱した[Heuristics of Software Testability][testability](テスタビリティ・テスト容易性のモデル)に示される，テストの品質を測る指標です．</span>\n<span class=\"token inserted\">+それぞれの説明は[優れたテスト容易性を実現するためのポイント - PrAha ENGINEER LAB][praha_test]に詳しいです．  </span>\n<span class=\"token inserted\">+こちらの記事でも示されている通り，テスト容易性の向上にはテスト容易性を低下させる要因を抑えることが必要不可欠です．そしてその要因はコードレベルに留まらずアーキテクチャレベルで抑えることが求められます．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+## 全体像</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+ざっくり以下の機能を持つアプリケーションを例にとります．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+- APIサーバからデータ`Foo`のリストを取得してデータを描画する</span>\n<span class=\"token inserted\">+- データ`Foo`を作成し，描画されるリストを更新する</span>\n<span class=\"token inserted\">+- pull-to-refreshでのデータ再取得機能を持つ</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+また，今回用いるレイヤは以下のようになります;</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+- **API Client**: APIサーバからのデータ取得+モデルへのdeserializeを行う</span>\n<span class=\"token inserted\">+  - 実装: `GetRequestProtocol` + `ListFooRequest`</span>\n<span class=\"token inserted\">+- **Repository**: API Client(+[shared_preferences][shared_preferences])を利用してデータ取得・更新を行う</span>\n<span class=\"token inserted\">+  - 実装: `FooRepository` + `fooRepositoryProvider`</span>\n<span class=\"token inserted\">+- **Service**: ドメインロジック担当(もしくはTransaction Script)</span>\n<span class=\"token inserted\">+  - 実装は省略</span>\n<span class=\"token inserted\">+- **ViewModel**: Viewの描画以外の責務全て</span>\n<span class=\"token inserted\">+  - 実装: `FooViewModel` + `fooViewModelProvider`</span>\n<span class=\"token inserted\">+- **View**: 描画+イベントとViewModelのイベントハンドラの糊付け</span>\n<span class=\"token inserted\">+  - 実装は省略</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+テスト容易性を念頭に置いた際にどのレイヤの分割が必要か判断した結果，基本的なMVVMアーキテクチャとなりました．  </span>\n<span class=\"token inserted\">+テスト容易性のためには特にViewをいかに薄く保てるかがキモで，そのためにViewModelはやや責務過多になる傾向にあります．</span>\n<span class=\"token inserted\">+したがってViewModelの肥大化を防ぐためにドメインロジックをViewModelからServiceクラスへ委譲し，また描画用のデータ管理とステートレスなドメインロジックを分離してテストできるようにします．  </span>\n<span class=\"token inserted\">+ViewModelと共に扱われることの多い，StreamやReactiveな双方向データバインディングは扱いません．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+以下では各レイヤ毎に簡易実装及びそのテストコードを示し，そのレイヤにおける責務と設計基準を説明します．  </span>\n<span class=\"token inserted\">+実際の設計時はテストコードから書いて書き心地を試しつつの実装を行いましたが，説明の都合で実装-&#x26;gt;テストの順で示します．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+また，Widgetについての設計はここでは述べません．</span>\n<span class=\"token inserted\">+テスト容易性の観点からViewを薄く保つことを念頭に置いているため，ViewはViewModelまでの設計と異なる目的での設計を取りうるためです．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+## API Client</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+APIクライアントクラスはネットワーク越しのリクエストを行い，アプリ内でのモデルへのdeserializeを行います．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+ここではREST APIを仮定したクラス設計を行いますが，gRPCやGraphQLの場合でも実装が異なるだけで責務自体は変わらないと思います．  </span>\n<span class=\"token inserted\">+APIレスポンスは対応するモデルクラスにマッピングし，`dynamic`型として存在する期間を極力短く保ちます．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+モデルクラスは適当な集約単位で作成し，レスポンスを正規化して持つようにします．</span>\n<span class=\"token inserted\">+[json_serializable][json_serializable]と組み合わせて`deserialize`の実装をModelのconstructorとして任せると楽です．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+::: info immutable</span>\n<span class=\"token inserted\">+Dartで構造体や関数以外への型エイリアスが定義できないのでclassとして定義するしかない．</span>\n<span class=\"token inserted\">+ただ内部状態を変更できるクラスメソッドを書けてしまうと変更検知が辛くなってしまう．</span>\n<span class=\"token inserted\">+:::</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+\\```dart[class=\"line-numbers\"][data-file=\"foo.dart\"]</span>\n<span class=\"token inserted\">+@freezed</span>\n<span class=\"token inserted\">+class Foo with _$Foo {</span>\n<span class=\"token inserted\">+  factory Foo.fromJson(Map&#x26;lt;String, dynamic&#x26;gt; json) =&#x26;gt; _$FooFromJson(json);</span>\n<span class=\"token inserted\">+}</span>\n<span class=\"token inserted\">+\\```</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+APIリクエストクラスは，実際のリクエスト処理の隠蔽及びテスト時のDIインターフェース統一のためにプロトコルで縛るようにします．</span>\n<span class=\"token inserted\">+プロトコルはmixinとして定義し，リクエスト処理を行う`request`メソッドのみmixin側に実装します．  </span>\n<span class=\"token inserted\">+ここでは簡単のため`url`以外の定義を省略していますが，クエリパラメータやヘッダなど，想定されるユースケースに応じた設定が行えるようにインターフェースを設計します．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+今回はGETリクエストを想定した`GetRequestProtocol`を定義し，またそのユースケースとして`ListFooRequest`を実装します．  </span>\n<span class=\"token inserted\">+また，`HttpClient`はHTTPリクエストを担う[http][http]や[dio][dio]，またはいずれかをwrapしたクラスです．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+\\```dart[class=\"line-numbers\"][data-file=\"api_protocol.dart\"]</span>\n<span class=\"token inserted\">+// `package:meta` に [@mustOverride] annotation が入ったら嬉しい</span>\n<span class=\"token inserted\">+// @see: https://github.com/dart-lang/sdk/issues/30175</span>\n<span class=\"token inserted\">+mixin GetRequestProtocol&#x26;lt;M&#x26;gt; {</span>\n<span class=\"token inserted\">+  @protected</span>\n<span class=\"token inserted\">+  String get url =&#x26;gt; throw UnimplementedError();</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+  Future&#x26;lt;M&#x26;gt; request(HttpClient client) async {</span>\n<span class=\"token inserted\">+    final json = await client.get(/* api request */);</span>\n<span class=\"token inserted\">+    return _deserialize(json);</span>\n<span class=\"token inserted\">+  }</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+  @protected</span>\n<span class=\"token inserted\">+  M _deserialize(Response json) {}</span>\n<span class=\"token inserted\">+}</span>\n<span class=\"token inserted\">+\\```</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+ユースケース側は`GetRequestProtocol`を取り込んだRequestクラスを定義し，`request`メソッドが返すレスポンスをモデルへ変換する`deserialize`メソッドを実装します．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+ここでは簡単のため`url`を固定値としていますが，実際には[flutter_dotenv][dotenv]を用いて環境変数としてAPIエンドポイントの管理を行います．</span>\n<span class=\"token inserted\">+これは設定と実装の分離の観点からももちろん好ましいのですが，読み込む`.env`ファイルをテスト時に差し替えられる利点が大きいです．詳細は後述します．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+\\```dart[class=\"line-numbers\"][data-file=\"list_foo_request.dart\"]</span>\n<span class=\"token inserted\">+class ListFooRequest with GetRequestProtocol&#x26;lt;List&#x26;lt;Foo&#x26;gt;&#x26;gt; {</span>\n<span class=\"token inserted\">+  @override</span>\n<span class=\"token inserted\">+  String get url =&#x26;gt; 'https://example.com/foos';</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+  @override</span>\n<span class=\"token inserted\">+  List&#x26;lt;Foo&#x26;gt; _deserialize(Response json) {</span>\n<span class=\"token inserted\">+    // レスポンスのJSONが`foos`をキーとして[Foo]の配列を持つと仮定</span>\n<span class=\"token inserted\">+    // constructor の tear-off が入ると `.map(Foo.fromJson)`のようにかける</span>\n<span class=\"token inserted\">+    // @see: https://twitter.com/remi_rousselet/status/1438207417154686980?s=20</span>\n<span class=\"token inserted\">+    return (json['foos'] as List)</span>\n<span class=\"token inserted\">+      .map((f) =&#x26;gt; Foo.fromJson(f as Map&#x26;lt;String, dynamic&#x26;gt;))</span>\n<span class=\"token inserted\">+      .toList();</span>\n<span class=\"token inserted\">+  }</span>\n<span class=\"token inserted\">+}</span>\n<span class=\"token inserted\">+\\```</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+### test</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+APIクライアントクラスはネットワークリクエストを行い，レスポンスをモデルに変換するところまでを責務としました．  </span>\n<span class=\"token inserted\">+Flutterのテストライブラリ[flutter_test][flutter_test]ではネットワークリクエストが遮断されるため，APIクライアントクラスに対するテストは`request`メソッドの返り値が対応するモデルインスタンスであるかどうかを評価することになります．  </span>\n<span class=\"token inserted\">+モックのアプローチとしては以下の2パターンが考えられます;</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+- A. [mockito][mockito]を用いて`HttpClient`のモックオブジェクトを生成し，対応するレスポンスをスタブする</span>\n<span class=\"token inserted\">+- B. [mock_http_server][mock_http_server]を用いてテスト用APIサーバを構築し，閉じたネットワークでのテストを行う</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+mockitoを用いる場合，今回の例題では`HttpClient`クラスの`get`メソッドをスタブすれば良さそうですが，HTTPリクエストを担うレイヤはinterceptorなどの機構を用いてロガーやエラーハンドラなどを注入するケースが多々あります．  </span>\n<span class=\"token inserted\">+そのためテスト時に生成される`HttpClient`のモックオブジェクトと実際のリクエスト時に渡される`HttpClient`のインスタンスはスタブされている箇所以外にも設定が異なってしまうことが懸念されます．</span>\n<span class=\"token inserted\">+したがって`HttpClient`の挙動がランタイムと乖離しないように，ネットワークリクエスト先をすげ替えるBの方針を取ることにします．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+\\```dart[class=\"line-numbers\"][data-file=\"list_foo_request_test.dart\"]</span>\n<span class=\"token inserted\">+void main() {</span>\n<span class=\"token inserted\">+  final server = MockWebServer(port: 8081);</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+  setUp(() async {</span>\n<span class=\"token inserted\">+    // APIエンドポイントを[MockWebServer]にすげ替えるためにテスト用の.envファイルを読み込む．</span>\n<span class=\"token inserted\">+    // HttpClientがbaseUrlを保持するパターンもあるが，全てのAPIが単一のbaseUrlからされない場合もあるので</span>\n<span class=\"token inserted\">+    // このようにしておく．</span>\n<span class=\"token inserted\">+    await dotenv.load(fileName: '.env.test');</span>\n<span class=\"token inserted\">+    server.start();</span>\n<span class=\"token inserted\">+  });</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+  tearDown(server.shutdown);</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+  // エラー時のテストケースについては，エラーハンドラを`request`メソッドの実装に持たせたり</span>\n<span class=\"token inserted\">+  // interceptorで挟んだりするためHttpClientやmixinのテストで記述する．</span>\n<span class=\"token inserted\">+  // したがって個々のRequestクラスのテストケースはシンプルに保つことができる．</span>\n<span class=\"token inserted\">+  test('ListFooRequest returns list of Foo', () async {</span>\n<span class=\"token inserted\">+    // ここではJSONの構築に[dart:convert#jsonEncode]を用いた．</span>\n<span class=\"token inserted\">+    // `json_serializable` が生成する`toJson`メソッドで適当なレスポンスを組み立ててもよい．</span>\n<span class=\"token inserted\">+    final body = { 'foos': [/* Foo モデル */] };</span>\n<span class=\"token inserted\">+    server.enqueue(httpCode: 200, body: jsonEncode(body));</span>\n<span class=\"token inserted\">+    final response = await ListFooRequest().request(httpClient);</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+    expect(response, isA&#x26;lt;List&#x26;lt;Foo&#x26;gt;&#x26;gt;);</span>\n<span class=\"token inserted\">+  });</span>\n<span class=\"token inserted\">+}</span>\n<span class=\"token inserted\">+\\```</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+## Repository</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+Repositoryクラスはデータ取得及びデータの更新操作を行います．  </span>\n<span class=\"token inserted\">+ここではAPIからのリモートデータリソースのみを扱っていますが，[shared_preferences][shared_preferences]やKeychain/KeyStoreを利用したローカルデータソースに対する操作も責務に含まれます．  </span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+RepositoryクラスはViewModelレイヤから利用されるのですが，Repositoryクラスはネットワークアクセスが行われるためViewModelクラスの内部でRepositoryクラスを初期化してしまうとViewModelのテストが困難になります．  </span>\n<span class=\"token inserted\">+かといってViewModelクラスのコンストラクタにRepositoryクラスを引数として渡す場合，そのViewModelクラスを利用するViewでRepositoryクラスを作成してViewModelを得る必要が出てしまい，レイヤ跨ぎ(View -&#x26;gt; Repository)が発生してしまいます．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+これを解消するためにDI(Dependency Injection)を用いて各レイヤ間の結合をDIプロバイダに委任します．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+Repositoryインスタンスには[riverpod][riverpod]の提供する`Provider`を介してアクセスするようにします．</span>\n<span class=\"token inserted\">+そのために`FooRepository`にはパブリックなコンストラクタを実装せずプライベートコンストラクタ`._()`のみを定義し，外部ファイルから`FooRepository`インスタンスを直接立ち上げることを禁止します．  </span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+\\```dart[data-file=\"foo_repository.dart\"]</span>\n<span class=\"token inserted\">+final fooRepositoryProvider = Provider&#x26;lt;FooRepository&#x26;gt;(</span>\n<span class=\"token inserted\">+  (ref) =&#x26;gt; FooRepository._(ref.read(httpClientProvider)),</span>\n<span class=\"token inserted\">+);</span>\n<span class=\"token inserted\">+\\```</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+また，(一般的なアーキテクチャにおける)Repositoryクラスは永続化層と表現されることもあり，その文脈ではキャッシュ機構を持つことがあります．  </span>\n<span class=\"token inserted\">+仮に`FooRepository`がキャッシュ機構を持つとした場合，そのテストがどのように記述されるべきかを見ていきます．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+`FooRepository`がキャッシュ機構を持つ場合，リモートデータソースとキャッシュとの整合性の不一致が生じえます．</span>\n<span class=\"token inserted\">+例えば`create`を呼んだ後に`list`を実行すると，`create`したデータが含まれないキャッシュが返されるなどが考えられます．  </span>\n<span class=\"token inserted\">+データの整合性を担保するにはいくつか方法がありますが，ここではシンプルにキャッシュの破棄操作を行う実装を行うとしましょう．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+\\```dart[data-file=\"foo_repository.dart\"]</span>\n<span class=\"token inserted\">+class FooRepository {</span>\n<span class=\"token inserted\">+  FooRepository._(this._httpClient);</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+  final HttpClient _httpClient;</span>\n<span class=\"token inserted\">+  List&#x26;lt;Foo&#x26;gt;? _cache;</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+  Future&#x26;lt;List&#x26;lt;Foo&#x26;gt;&#x26;gt; list() async {</span>\n<span class=\"token inserted\">+    if (_cache != null) return _cache;</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+    _cache = ListFooRequest().request(_httpClient);</span>\n<span class=\"token inserted\">+    return _cache;</span>\n<span class=\"token inserted\">+  }</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+  // Requestクラスの説明では省略した[CreateFooRequest]を用いて</span>\n<span class=\"token inserted\">+  // [Foo]レコードを作成するリクエストを行う．</span>\n<span class=\"token inserted\">+  // [CreateFoo]クラスは[Foo]レコードを作成する際のDTO.</span>\n<span class=\"token inserted\">+  Future&#x26;lt;Foo&#x26;gt; create(CreateFoo createFoo) async {</span>\n<span class=\"token inserted\">+    _cache = null;</span>\n<span class=\"token inserted\">+    await CreateFooRequest(createFoo).request(_httpClient);</span>\n<span class=\"token inserted\">+  }</span>\n<span class=\"token inserted\">+}</span>\n<span class=\"token inserted\">+\\```</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+### test</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+Repositoryクラスはデータ取得・更新操作を行い，データの整合性を担保します．</span>\n<span class=\"token inserted\">+Repositoryクラスのユースケースにおいては，その内部にキャッシュ機構があるかどうか，またはインメモリデータベースを利用しているかどうかは隠蔽されているべきです．</span>\n<span class=\"token inserted\">+したがって実装の詳細には触れず，その振る舞いのみを保証するにはテストデータ更新後に最新のデータを返すかどうかを確認すれば良さそうです．  </span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+次にテスト容易性を主軸にRepositoryクラスをどのように提供するか考察します．  </span>\n<span class=\"token inserted\">+Repositoryクラスはその責務上複数のAPIクライアントクラスを操作するため，テストのタイミングではAPIクライアントクラスもしくはその処理のモックが必要となります．</span>\n<span class=\"token inserted\">+Repositoryクラスにおいてもどのレイヤーをモックするかが設計のポイントとなるのですが，Repositoryクラスのコンストラクタに渡される`HttpClient`をモックする方針をとります．  </span>\n<span class=\"token inserted\">+判断に至った思考仮定は次のようなものです;</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+**A. APIクライアントのテストのようにAPIサーバをモックする場合**  </span>\n<span class=\"token inserted\">+この場合Repositoryクラスが扱う各APIクライアントクラスに対するモックAPIサーバの設定を記述する必要があります．</span>\n<span class=\"token inserted\">+この設定にはエンドポイントのURLやレスポンスのJSONスキーマ定義など，APIクライアントクラスの責務となる詳細部分が必要なので，</span>\n<span class=\"token inserted\">+APIクライアントの実装を変更することでRepositoryクラスのテストがfailする可能性があり，修正に脆いテストとなり得ます．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+**B. 個々のAPIクライアントクラスをモックする場合**  </span>\n<span class=\"token inserted\">+先に示した`FooRepository`クラスの実装ではAPIクライアントクラスをハードコードして利用しています．  </span>\n<span class=\"token inserted\">+APIクライアントクラスをモックする場合には各APIクライアントクラスをDIするかコンストラクタの引数として受け取るような実装をする必要が生じます．  </span>\n<span class=\"token inserted\">+(callerの直接の)コンストラクタでの引数渡しについては先に述べたとおり抽象化レイヤを跨いでしまうため避けたいです．  </span>\n<span class=\"token inserted\">+またAPIクライアントクラスはRepositoryクラスにとってStatic Dependency[^1]であり，また各APIクライアントクラスをDIすることはOver-Injection[^2]に繋がるのでこれもベストとは言い難いです．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+**C. HttpClientをモックする場合**  </span>\n<span class=\"token inserted\">+Aではネットワーク先，BではAPIクライアントの振る舞いをそれぞれスタブする方針でした．  </span>\n<span class=\"token inserted\">+APIクライアントクラスが利用する`HttpClient`をモックすることで，APIクライアントのネットワークリクエスト処理のみをスタブすることができます．  </span>\n<span class=\"token inserted\">+APIクライアントクラスが`HttpClient`を利用する処理はmixinとして実装を与えてあるため，個々のAPIクライアントクラスの振る舞いには左右されず修正に強いテストが期待できます．</span>\n<span class=\"token inserted\">+またBと比較してもDIする対象が1つで済むため適切であると言えます．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+::: warn FooRepositoryのコンストラクタについて</span>\n<span class=\"token inserted\">+FooRepository内部で直接ProviderをService Locatorとして利用することを避けるために，HttpClientをコンストラクタの引数として渡すような設計になっています．</span>\n<span class=\"token inserted\">+:::</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+テストコードで`HttpClient`をProviderから受け取るには`ProviderContainer`を利用します．  </span>\n<span class=\"token inserted\">+`ProviderContainer`の引数にDIプロバイダのオーバーライド設定を指定することで，テスト内では`mockHttpClient`を利用するRepositoryクラスを利用することができます．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+\\```dart[data-file=\"foo_repository_test.dart\"]</span>\n<span class=\"token inserted\">+void main() {</span>\n<span class=\"token inserted\">+  final container = ProviderContainer(</span>\n<span class=\"token inserted\">+    overrides: [httpClientProvider.overrideWithValue(mockHttpClient)],</span>\n<span class=\"token inserted\">+  );</span>\n<span class=\"token inserted\">+  final repository = container.read(fooRepositoryProvider);</span>\n<span class=\"token inserted\">+}</span>\n<span class=\"token inserted\">+\\```</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+データ整合性のテストはユースケースを元に，`create`メソッド実行後に`list`メソッドの実行結果が`create`したデータを含むかどうかを確認します．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+&#x26;lt;small&#x26;gt;もちろん`list`メソッド単体のテストは書く前提です.&#x26;lt;/small&#x26;gt;</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+\\```dart[data-file=\"foo_repository_test.dart\"]</span>\n<span class=\"token inserted\">+void main() {</span>\n<span class=\"token inserted\">+  // omitted</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+  // HttpClientの挙動をスタブ</span>\n<span class=\"token inserted\">+  when(mockHttpClient.get(any)).thenAnswer((_) async =&#x26;gt; listFooResponse);</span>\n<span class=\"token inserted\">+  var response = await repository.list();</span>\n<span class=\"token inserted\">+  // verify(mockHttpClient.get(any)) として</span>\n<span class=\"token inserted\">+  // **内部でmockHttpClientが呼ばれた**ことをテストすることも可能だが，</span>\n<span class=\"token inserted\">+  // ここではRepositoryクラスの振る舞いを見ることを主軸に置くためテストに含めない．</span>\n<span class=\"token inserted\">+  // 実際のユースケースではRepositoryクラスはProvider経由で利用され，</span>\n<span class=\"token inserted\">+  // HttpClientはProvider内部で渡されるため利用する側からはHttpClientはされている.</span>\n<span class=\"token inserted\">+  // あくまでテストにおいてのみRepositoryクラスがHttpClientを利用していることを知る必要が生じている．</span>\n<span class=\"token inserted\">+  //</span>\n<span class=\"token inserted\">+  // ListFooRequestの結果が返される</span>\n<span class=\"token inserted\">+  expect(response, listFooResponse);</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+  // create時の挙動をスタブ</span>\n<span class=\"token inserted\">+  when(mockHttpClient.post(any)).thenAnswer((_) async =&#x26;gt; createResponse);</span>\n<span class=\"token inserted\">+  final createFoo = CreateFoo(/* */);</span>\n<span class=\"token inserted\">+  response = await repository.create(createFoo);</span>\n<span class=\"token inserted\">+  expect(response, createResponse);</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+  // 再度Listした際に更新されたResponseが返される</span>\n<span class=\"token inserted\">+  when(mockHttpClient.get(any)).thenAnswer((_) async =&#x26;gt; updatedListResponse);</span>\n<span class=\"token inserted\">+  response = await repository.list();</span>\n<span class=\"token inserted\">+  expect(response, updatedListResponse);</span>\n<span class=\"token inserted\">+}</span>\n<span class=\"token inserted\">+\\```</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+## ViewModel</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+ViewModelはViewが利用するデータ及びロジックを提供します．  </span>\n<span class=\"token inserted\">+ここが一番責務をどこにおくか悩むところだと思うので，ViewModelの定義について John Gossman. (2005)[^3]を紹介します．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+&#x26;gt; The UI may want to perform complex operations that must be implemented in code which doesn't make sense in our strict definition of the View but are too specific to be included in the Model (or didn't come with the pre-existing model).</span>\n<span class=\"token inserted\">+&#x26;gt; Finally we need a place to put view state such as selection or modes.</span>\n<span class=\"token inserted\">+&#x26;gt;</span>\n<span class=\"token inserted\">+&#x26;gt; The ViewModel is responsible for these tasks.</span>\n<span class=\"token inserted\">+&#x26;gt; The term means \"Model of a View\", and can be thought of as abstraction of the view,</span>\n<span class=\"token inserted\">+&#x26;gt; but it also provides a specialization of the Model that the View can use for data-binding.</span>\n<span class=\"token inserted\">+&#x26;gt; In this latter role the ViewModel contains data-transformers that convert Model types into View types, and it contains Commands the View can use to interact with the Model.</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+ここで示したいのはViewModelはViewとのデータバインディングだけではなく，Viewが行う複雑な操作(=ドメインロジック)をも責務に含むという点です．</span>\n<span class=\"token inserted\">+これは逆にViewにそのような処理をもたせてはいけないというだけなので，ViewModelまたはServiceレイヤに持たせるようにします．  </span>\n<span class=\"token inserted\">+ViewModelからはViewでの操作のハンドラを提供し，ViewからServiceクラスを直接呼ぶことのないようにします．  </span>\n<span class=\"token inserted\">+例外的にpull-to-refreshのように描画・アニメーションがメインとなるロジックや，`BuildContext`を介する処理(例: `Navigator.push`等)についてはView側の責務となります．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+また，テスト容易性の観点からはMartin Fowler氏のHumble Object[^4]をイメージするとViewとViewModelとのそれぞれの責務の切り分けがしやすいかと思います．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+Viewのテストを考慮すると，View内部でViewModelをイニシャライズするとViewModelのモックがやや手間になります．  </span>\n<span class=\"token inserted\">+したがってViewModelにおいてもProviderを利用して提供します．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+ここで，ViewModelのライフサイクルをどうするか検討しましょう．  </span>\n<span class=\"token inserted\">+ViewModelがViewを参照しない・してはならないことからもわかるように，ViewModelとViewとのライフサイクルは異なります．</span>\n<span class=\"token inserted\">+しかしViewインスタンスが破棄された後にViewModelが生き続けると，再度Viewが生成された際にその(中途半端な状態を持つ)ViewModelが参照されると困るケースもあります．</span>\n<span class=\"token inserted\">+そういったケースでは`StateNotifierProvider.autoDispose`を用いてViewModelのライフサイクルをViewに揃え，Viewが生成されるタイミングでViewModelを生成してデータの整合性を担保するようにします．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+\\```dart[data-file=\"view_model.dart\"]</span>\n<span class=\"token inserted\">+final fooViewModelProvider = StateNotifierProvider.autoDispose&#x26;lt;FooViewModel, FooState&#x26;gt;(</span>\n<span class=\"token inserted\">+  (ref) =&#x26;gt; WaitingListViewModel(</span>\n<span class=\"token inserted\">+    insuranceRepository: ref.read(insuranceRepositoryProvider),</span>\n<span class=\"token inserted\">+  ),</span>\n<span class=\"token inserted\">+);</span>\n<span class=\"token inserted\">+\\```</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+ViewModelが持つ状態はたとえ変数が1つであってもクラスとして切り出し，内包する状態が増えた際に変更に対して閉じるようにします．  </span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+\\```dart[data-file=\"view_model.dart\"]</span>\n<span class=\"token inserted\">+@freezed</span>\n<span class=\"token inserted\">+class FooState with _$FooState {</span>\n<span class=\"token inserted\">+  const factory FooState._({</span>\n<span class=\"token inserted\">+    required AsyncValue&#x26;lt;List&#x26;lt;Foo&#x26;gt;&#x26;gt; foos,</span>\n<span class=\"token inserted\">+  }) = _FooState;</span>\n<span class=\"token inserted\">+}</span>\n<span class=\"token inserted\">+\\```</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+今回はViewがpull-to-refresh機能を提供するとして設計します．</span>\n<span class=\"token inserted\">+その場合，Viewで必要となるロジックは以下のようなデータ及びイベントハンドラが考えられます；</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+- Viewで描画するデータ(`List&#x26;lt;Foo&#x26;gt;`)</span>\n<span class=\"token inserted\">+- View作成時のViewModelの初期化処理(`onInit`)</span>\n<span class=\"token inserted\">+- pull-to-refresh実行時のリフレッシュ処理(`onRefresh`)</span>\n<span class=\"token inserted\">+- `Foo`の追加処理(`createFoo(CreateFoo foo)`)</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+また描画するデータ`List&#x26;lt;Foo&#x26;gt;`はAPIから取得するため，初期状態はデータを保持しておらずローディング中・ローディング失敗の状態も考えられます．</span>\n<span class=\"token inserted\">+そういったケースに対応するため`Future`の値の変化を検知・通知できる[`AsyncValue`][async_value]を利用します．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+それぞれを実装におとすと次のようになります．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+\\```dart[data-file=\"view_model.dart\"]</span>\n<span class=\"token inserted\">+class FooViewModel extends StateNotifier&#x26;lt;FooState&#x26;gt; {</span>\n<span class=\"token inserted\">+  FooViewModel({required FooRepository fooRepository})</span>\n<span class=\"token inserted\">+      : _repository = fooRepository,</span>\n<span class=\"token inserted\">+        super(const FooState._(foos: AsyncValue.loading())) {</span>\n<span class=\"token inserted\">+    // construct時に初期化処理`onInit`を実行</span>\n<span class=\"token inserted\">+    onInit();</span>\n<span class=\"token inserted\">+  }</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+  final FooRepository _repository;</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+  Future&#x26;lt;void&#x26;gt; onInit() async {</span>\n<span class=\"token inserted\">+    // 今回の例では簡単のため`onRefresh`を呼ぶだけ</span>\n<span class=\"token inserted\">+    await onRefresh();</span>\n<span class=\"token inserted\">+  }</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+  Future&#x26;lt;void&#x26;gt; createFoo(CreateFoo foo) async {</span>\n<span class=\"token inserted\">+    await _repository.create(foo).then((res) {</span>\n<span class=\"token inserted\">+      await onRefresh();</span>\n<span class=\"token inserted\">+    }).catchError((e) {</span>\n<span class=\"token inserted\">+      // TODO</span>\n<span class=\"token inserted\">+    });</span>\n<span class=\"token inserted\">+  }</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+  Future&#x26;lt;void&#x26;gt; onRefresh() async {</span>\n<span class=\"token inserted\">+    await _repository.list().then((res) {</span>\n<span class=\"token inserted\">+      state = state.copyWith(foos: AsyncValue.data(res));</span>\n<span class=\"token inserted\">+    }).catchError((e) {</span>\n<span class=\"token inserted\">+      state = state.copyWith(foos: AsyncValue.error(e as Object));</span>\n<span class=\"token inserted\">+    });</span>\n<span class=\"token inserted\">+  }</span>\n<span class=\"token inserted\">+}</span>\n<span class=\"token inserted\">+\\```</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+### test</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+ViewModelはViewが利用するデータ及びロジックの提供を責務とします．  </span>\n<span class=\"token inserted\">+ViewModelのテストですが，単体でのテストを行うかViewと組み合わせたテストを行うか正直自分の中で答えを出せていません．</span>\n<span class=\"token inserted\">+Viewの持つロジックを極力薄くすることで，擬似的にViewの取りうる振る舞いをViewModelでテストすることは可能です．ただViewModelの取りうる状態に応じた描画はViewでのテストでしか担保することができず，かつそれらは無視できる量・質のものとは言い難いです．  </span>\n<span class=\"token inserted\">+そのためViewはViewのテストが必要となりますが，ViewModelが示す状態に沿う描画ができているかを検査すればよいので，ある程度宣言的にテストを記述できます．  </span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+実際，実機での[integration_test][integration_test]や回帰テストを行う[golden toolkit][golden_test]などViewを対象としたテストツールも充実してきておりそれらを用いることで描画内容にとどまらないデザインのテストをも行うことが可能となってきています．  </span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+ただ，そこに実際のViewModelを持ち込むかモックしたViewModelを持ち込むかは明確な判断理由を持てていません．  </span>\n<span class=\"token inserted\">+ここではテスト容易性を主軸においたアーキテクチャの紹介を行い，いわゆるUIテストについては上記の説明に留めることとします．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+---</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+先程実装した`FooRepository`はProvider経由のみのアクセスとするためにパブリックなコンストラクタを公開していませんでした．</span>\n<span class=\"token inserted\">+直接インスタンスを生成できないというのも理由のひとつですが，`FooRepository`は内部でネットワークリクエストを行うためどのみちそのまま扱うことができません．  </span>\n<span class=\"token inserted\">+そのため`FooRepository`のモックオブジェクトを生成し，`fooRepositoryProvider`に注入して`FooViewModel`から`MockFooRepository`が参照されるように設定します．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+今回利用するモックライブラリ[mockito][mockito]が生成するモックは，次のように対象のクラスを`implements`する形で実装されます．  </span>\n<span class=\"token inserted\">+パブリックなコンストラクタを自動で生成してくれるので，`MockFooRepository`インスタンスを用いて`fooRepositoryProvider`を上書きできます．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+\\```dart[class=\"line-numbers\"][data-file=\"foo_repository.mocks.dart\"]</span>\n<span class=\"token inserted\">+class MockFooRepository extends _i1.Mock implements _i2.FooRepository {</span>\n<span class=\"token inserted\">+  MockFooRepository() {</span>\n<span class=\"token inserted\">+    _i1.throwOnMissingStub(this);</span>\n<span class=\"token inserted\">+  }</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+  @override</span>\n<span class=\"token inserted\">+  _i3.Future&#x26;lt;List&#x26;lt;Foo&#x26;gt;&#x26;gt; list() =&#x26;gt; (/* omitted */);</span>\n<span class=\"token inserted\">+}</span>\n<span class=\"token inserted\">+\\```</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+今回はViewModelとViewを共に扱いテストを行います．</span>\n<span class=\"token inserted\">+ここでは`FooViewModel`を利用するViewを`FooView`とします．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+\\```dart[class=\"line-numbers\"][data-file=\"foo_view_model_test.dart\"]</span>\n<span class=\"token inserted\">+void main() {</span>\n<span class=\"token inserted\">+  final repository = MockFooRepository();</span>\n<span class=\"token inserted\">+  final container = ProviderContainer(</span>\n<span class=\"token inserted\">+    overrides: [fooRepositoryProvider.overrideWithValue(repository)],</span>\n<span class=\"token inserted\">+  );</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+  // repositoryのmock等を行う</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+  testWidgets('FooViewModel smoke test with view', (WidgetTester tester) async {</span>\n<span class=\"token inserted\">+    final widget = ProviderScope(</span>\n<span class=\"token inserted\">+      overrides: [fooRepositoryProvider.overrideWithValue(repository)],</span>\n<span class=\"token inserted\">+      child: const MaterialApp(home: FooView()),</span>\n<span class=\"token inserted\">+    );</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+    await tester.runAsync(() async {</span>\n<span class=\"token inserted\">+      await tester.pumpWidget();</span>\n<span class=\"token inserted\">+      // 初期状態の確認.</span>\n<span class=\"token inserted\">+      // APIリクエストが完了していないのでデータローディングの旨を表示したい</span>\n<span class=\"token inserted\">+      expect(find.text('データ読み込み中'), findsOneWidget);</span>\n<span class=\"token inserted\">+      // 描画更新を更新.</span>\n<span class=\"token inserted\">+      // APIリクエストが完了している(ようレスポンスをスタブする)ので</span>\n<span class=\"token inserted\">+      // ローディングが完了しデータが描画されていることを確認</span>\n<span class=\"token inserted\">+      // (レスポンスはListViewで描画しているとする)</span>\n<span class=\"token inserted\">+      expect(find.text('データ読み込み中'), findsNothing);</span>\n<span class=\"token inserted\">+      expect(find.byType(ListView), findsOneWidget);</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+      // pull to refresh 実行</span>\n<span class=\"token inserted\">+      // pull to refreshをテスト上でimitateする処理は以下を参照</span>\n<span class=\"token inserted\">+      // @see: https://github.com/flutter/flutter/blob/d62f75dde1cb6f04fadb9aff48896491ff0e2163/packages/flutter/test/material/refresh_indicator_test.dart#L119-L122</span>\n<span class=\"token inserted\">+      when(repository.list()).thenAnswer((_) async =&#x26;gt; /* response */);</span>\n<span class=\"token inserted\">+      await tester.fling(find.byType(ListView), const Offset(0, 300), 1000);</span>\n<span class=\"token inserted\">+      await tester.pump();</span>\n<span class=\"token inserted\">+      await tester.pump(const Duration(seconds: 3));</span>\n<span class=\"token inserted\">+      // responseが更新されていることを確認</span>\n<span class=\"token inserted\">+      expect(/* */);</span>\n<span class=\"token inserted\">+    });</span>\n<span class=\"token inserted\">+  });</span>\n<span class=\"token inserted\">+}</span>\n<span class=\"token inserted\">+\\```</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+同様にしてRepositoryから`Future.error`を返すことでWidgetのエラー時の描画のテストを行うことが可能です．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+### ViewModelとService class</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+ViewModelの処理をどのタイミングでServiceクラスへ委譲するかの基準は，[Arrange-Act-Assert][aaa]におけるArrange[^6]のコストを一つの目安とすることができます．  </span>\n<span class=\"token inserted\">+テストの準備の記述(Arrange)が少なくない割合を占める場合，テスト対象が状態や責務を持ちすぎている可能性があります．</span>\n<span class=\"token inserted\">+そうなった場合にはArrangeの記述及びViewModelのメソッドの処理からテスト(の準備が)しづらいメソッドを探しだしてServiceクラスへ抽出します．</span>\n<span class=\"token inserted\">+そうすることでテスト容易性を高め，かつテスト対象の関心の対象を絞ることで壊れづらいテストコードを保つことが可能です．  </span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+&#x26;lt;small&#x26;gt;このアプローチは実際テスト対象とレイヤーの異なる責務を見分けて分離するには便利な手法だと感じています&#x26;lt;/small&#x26;gt;</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+補足:  </span>\n<span class=\"token inserted\">+SOLID原則の[Single-responsibility principle][srp]は\"1つのクラスは1つの責務\"といった説明がされがちですが，真意は\"1つのクラスは1つの(アクターに対し)責務(を負う)\"ということです．  </span>\n<span class=\"token inserted\">+ViewModelは責務が多くなりがちですが，対応するViewに対してのみ責務を追っているためSRPの観点からは適切です．  </span>\n<span class=\"token inserted\">+ただしViewModelのメソッドの処理をテストする際にViewModelがServiceクラスのアクターになれる場合においては，それはメソッドの処理をServiceクラスへと切り出すタイミングだと思います．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+---</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+以上，テスト容易性を意識したFlutterアプリケーションのアーキテクチャを考察していきました．</span>\n<span class=\"token inserted\">+長くなってスマン.</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+Dartの型システムは比較的緩いので，そういった言語特性も含めテストでカバーしていきたい気持ちがあり今回このような検討を行いました．  </span>\n<span class=\"token inserted\">+結合度と凝集度など関数レベルでの設計やTDDなどのプラクティスはもちろん，アーキテクチャレベルで考慮することで更にテスト容易性を向上することができ，またソフトウェアの品質を担保することに繋がります．</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+&#x26;lt;small&#x26;gt;</span>\n<span class=\"token inserted\">+  半年とか経ったら振り返りをしようと考えています．  </span>\n<span class=\"token inserted\">+&#x26;lt;/small&#x26;gt;</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+[praha_test]: https://www.praha-inc.com/lab/posts/testability</span>\n<span class=\"token inserted\">+[testability]: https://www.satisfice.com/download/heuristics-of-software-testability</span>\n<span class=\"token inserted\">+[shared_preferences]: https://pub.dev/packages/shared_preferences</span>\n<span class=\"token inserted\">+[freezed]: https://pub.dev/packages/freezed</span>\n<span class=\"token inserted\">+[riverpod]: https://pub.dev/packages/riverpod</span>\n<span class=\"token inserted\">+[dotenv]: https://pub.dev/packages/flutter_dotenv</span>\n<span class=\"token inserted\">+[json_serializable]: https://pub.dev/packages/json_serializable</span>\n<span class=\"token inserted\">+[http]: https://pub.dev/packages/http</span>\n<span class=\"token inserted\">+[dio]: https://pub.dev/packages/dio</span>\n<span class=\"token inserted\">+[flutter_test]: https://api.flutter.dev/flutter/flutter_test/flutter_test-library.html</span>\n<span class=\"token inserted\">+[mockito]: https://pub.dev/packages/mockito</span>\n<span class=\"token inserted\">+[mock_http_server]: https://pub.dev/packages/mock_web_server</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+[async_value]: https://pub.dev/documentation/riverpod/latest/riverpod/AsyncValue-class.html</span>\n<span class=\"token inserted\">+[di_principles]: https://livebook.manning.com/book/dependency-injection-principles-practices-patterns/about-this-book/1</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+[integration_test]: https://flutter.dev/docs/cookbook/testing/integration/introduction</span>\n<span class=\"token inserted\">+[golden_test]: https://pub.dev/packages/golden_toolkit</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+[aaa]: https://docs.microsoft.com/en-us/visualstudio/test/unit-test-basics?view=vs-2019#write-your-tests</span>\n<span class=\"token inserted\">+[srp]: https://en.wikipedia.org/wiki/Single-responsibility_principle</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+</span>\n<span class=\"token inserted\">+[^1]: [Dependency Injection principles, Manning][di_principles]. volatile dependency/static dependency</span>\n<span class=\"token inserted\">+[^2]: https://blog.ploeh.dk/2018/08/27/on-constructor-over-injection/</span>\n<span class=\"token inserted\">+[^3]: https://docs.microsoft.com/en-us/archive/blogs/johngossman/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps</span>\n<span class=\"token inserted\">+[^4]: https://martinfowler.com/bliki/HumbleObject.html</span>\n<span class=\"token inserted\">+[^5]: https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html</span>\n<span class=\"token inserted\">+[^6]: またはHeuristics of Software TestabilityにおけるControllability/Decomposability.</span>\n</code></pre></div>"}],"publishedAt":"2021-10-25","updatedAt":"2021-10-26"}},"__N_SSG":true}