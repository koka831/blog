<!DOCTYPE html><html lang="en"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta name="theme-color" content="#ddd4bb"/><meta property="og:type" content="website"/><meta property="og:url" content="https://koka831.github.io"/><meta property="og:site_name" content="/var/log/koka"/><meta name="twitter:card" content="summary"/><meta name="twitter:title" content="/var/log/koka"/><meta name="twitter:site" content="@k_0ka"/><meta name="twitter:description" content="cat /var/log/koka &gt; /dev/null"/><link rel="alternate" type="application/rss+xml" href="https://koka831.github.io/feed.xml" title="/var/log/koka RSS2.0"/><title>テスト容易性を考慮したFlutterのアーキテクチャ考察 | /var/log/koka</title><meta property="title" content="テスト容易性を考慮したFlutterのアーキテクチャ考察 | /var/log/koka"/><meta property="og:title" content="テスト容易性を考慮したFlutterのアーキテクチャ考察 | /var/log/koka"/><meta property="twitter:title" content="テスト容易性を考慮したFlutterのアーキテクチャ考察 | /var/log/koka"/><meta property="description" content="MVVM architecture with Repository pattern, state_notifier and riverpod"/><meta property="og:description" content="MVVM architecture with Repository pattern, state_notifier and riverpod"/><meta property="twitter:description" content="MVVM architecture with Repository pattern, state_notifier and riverpod"/><meta property="og:image" content="https://koka831.github.io/img/icon.png"/><meta name="next-head-count" content="19"/><link rel="preload" href="/_next/static/css/fec7387515ee4d96.css" as="style"/><link rel="stylesheet" href="/_next/static/css/fec7387515ee4d96.css" data-n-g=""/><link rel="preload" href="/_next/static/css/9a908afc1d99510a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9a908afc1d99510a.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e0fcf5a3a528e4c5.js" defer=""></script><script src="/_next/static/chunks/cb1608f2-ecfb8d9b659208e2.js" defer=""></script><script src="/_next/static/chunks/956-010db0f3f1d0c7bc.js" defer=""></script><script src="/_next/static/chunks/291-9c5c86f482a4e495.js" defer=""></script><script src="/_next/static/chunks/pages/archives/%5Bslug%5D-c119bff926c7db42.js" defer=""></script><script src="/_next/static/2E6UKlrD16eNIDc8fou7_/_buildManifest.js" defer=""></script><script src="/_next/static/2E6UKlrD16eNIDc8fou7_/_ssgManifest.js" defer=""></script><script src="/_next/static/2E6UKlrD16eNIDc8fou7_/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><nav class="Header_navigation__container__Xjar7"><div class="Header_navigation__qZpeO"><a href="/">/var/log/koka</a></div><div><a href="/archives">archive</a></div></nav><main class="Layout_container__LBFOo"><div class="slug_container__f_fjw"><div class="slug_main__WMOpC"><article class="slug_article__cOl2p" role="article"><div itemscope="" class="ArticleHeader_header__container__5Gs_X"><a class="ArticleHeader_post__title__gVFje" href="/archives/2021-10-20-testable-architecture-flutter">テスト容易性を考慮したFlutterのアーキテクチャ考察</a><p>MVVM architecture with Repository pattern, state_notifier and riverpod</p><div class="ArticleHeader_flex__yDiMS"><div class="ArticleHeader_post__tags__uCQyx"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="tags" class="svg-inline--fa fa-tags ArticleHeader_tags__icon__U9c_O" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M472.8 168.4C525.1 221.4 525.1 306.6 472.8 359.6L360.8 472.9C351.5 482.3 336.3 482.4 326.9 473.1C317.4 463.8 317.4 448.6 326.7 439.1L438.6 325.9C472.5 291.6 472.5 236.4 438.6 202.1L310.9 72.87C301.5 63.44 301.6 48.25 311.1 38.93C320.5 29.61 335.7 29.7 344.1 39.13L472.8 168.4zM.0003 229.5V80C.0003 53.49 21.49 32 48 32H197.5C214.5 32 230.7 38.74 242.7 50.75L410.7 218.7C435.7 243.7 435.7 284.3 410.7 309.3L277.3 442.7C252.3 467.7 211.7 467.7 186.7 442.7L18.75 274.7C6.743 262.7 0 246.5 0 229.5L.0003 229.5zM112 112C94.33 112 80 126.3 80 144C80 161.7 94.33 176 112 176C129.7 176 144 161.7 144 144C144 126.3 129.7 112 112 112z"></path></svg><p class="Tag_tag__rl8WL">Flutter</p></div><div class="ArticleHeader_post__dates__6uEwt"><time dateTime="2021-10-25" itemProp="datePublished" class="PublishDate_post__date__jhH_w">published: <!-- -->2021-10-25</time><time dateTime="2021-11-16" itemProp="datePublished" class="PublishDate_post__date__jhH_w">updated: 2021-11-16</time></div></div></div><div class="slug_article__body__m2pRS"><p>ここ半年ほどFlutterを書いていて，アプリケーションのアーキテクチャで試行錯誤してます．状態管理ムズくない？<br>
なのでいっそ表に出して意見もらえたらな，と思ったので書きます．</p>
<p>本記事では，Flutterアプリケーションにおいてテスト容易性を向上するためにはどうすればいいか，サンプルアプリケーションを例題にアーキテクチャレベルで検討します．</p>
<h2 id="アーキテクチャの目的"><a href="#アーキテクチャの目的">アーキテクチャの目的</a></h2>
<p>今回は<strong>テスト容易性</strong>を主軸に置いたアーキテクチャ選定を行いました．
特にFlutterの単体テストはネットワークリクエストが遮断されるので，副作用を伴う処理を行うレイヤを適切に分離し，テストが容易になるよう設計を行うこととしました．</p>
<p>アーキテクチャは何かしら課題を解決するために設計されるもの(だと思っている)なので，今回示す例が必ずしもベストなものとは限らないです．</p>
<h3 id="テスト容易性とは"><a href="#テスト容易性とは">テスト容易性とは</a></h3>
<p>テスト容易性とは，James Bachが提唱した<a href="https://www.satisfice.com/download/heuristics-of-software-testability" target="_blank" rel="nofollow noopener noreferrer">Heuristics of Software Testability</a>(テスタビリティ・テスト容易性のモデル)に示される，テストの品質を測る指標です．
それぞれの説明は<a href="https://www.praha-inc.com/lab/posts/testability" target="_blank" rel="nofollow noopener noreferrer">優れたテスト容易性を実現するためのポイント - PrAha ENGINEER LAB</a>に詳しいです．<br>
こちらの記事でも示されている通り，テスト容易性の向上にはテスト容易性を低下させる要因を抑えることが必要不可欠です．そしてその要因はコードレベルに留まらずアーキテクチャレベルで抑えることが求められます．</p>
<h2 id="全体像"><a href="#全体像">全体像</a></h2>
<p>ざっくり以下の機能を持つアプリケーションを例にとります．</p>
<ul>
<li>APIサーバからデータ<code>Foo</code>のリストを取得してデータを描画する</li>
<li>データ<code>Foo</code>を作成し，描画されるリストを更新する</li>
<li>pull-to-refreshでのデータ再取得機能を持つ</li>
</ul>
<p>また，今回用いるレイヤは以下のようになります;</p>
<ul>
<li><strong>API Client</strong>: APIサーバからのデータ取得+モデルへのdeserializeを行う
<ul>
<li>実装: <code>GetRequestProtocol</code> + <code>ListFooRequest</code></li>
</ul>
</li>
<li><strong>Repository</strong>: API Client(+<a href="https://pub.dev/packages/shared_preferences" target="_blank" rel="nofollow noopener noreferrer">shared_preferences</a>)を利用してデータ取得・更新を行う
<ul>
<li>実装: <code>FooRepository</code> + <code>fooRepositoryProvider</code></li>
</ul>
</li>
<li><strong>Service</strong>: ドメインロジック担当(もしくはTransaction Script)
<ul>
<li>実装は省略</li>
</ul>
</li>
<li><strong>ViewModel</strong>: Viewの描画以外の責務全て
<ul>
<li>実装: <code>FooViewModel</code> + <code>fooViewModelProvider</code></li>
</ul>
</li>
<li><strong>View</strong>: 描画+イベントとViewModelのイベントハンドラの糊付け
<ul>
<li>実装は省略</li>
</ul>
</li>
</ul>
<p>テスト容易性を念頭に置いた際にどのレイヤの分割が必要か判断した結果，基本的なMVVMアーキテクチャとなりました．<br>
テスト容易性のためには特にViewをいかに薄く保てるかがキモで，そのためにViewModelはやや責務過多になる傾向にあります．
したがってViewModelの肥大化を防ぐためにドメインロジックをViewModelからServiceクラスへ委譲し，また描画用のデータ管理とステートレスなドメインロジックを分離してテストできるようにします．<br>
ViewModelと共に扱われることの多い，StreamやReactiveな双方向データバインディングは扱いません．</p>
<p>以下では各レイヤ毎に簡易実装及びそのテストコードを示し，そのレイヤにおける責務と設計基準を説明します．<br>
実際の設計時はテストコードから書いて書き心地を試しつつの実装を行いましたが，説明の都合で実装->テストの順で示します．</p>
<p>また，Widgetについての設計はここでは述べません．
テスト容易性の観点からViewを薄く保つことを念頭に置いているため，ViewはViewModelまでの設計と異なる目的での設計を取りうるためです．</p>
<h2 id="api-client"><a href="#api-client">API Client</a></h2>
<p>APIクライアントクラスはネットワーク越しのリクエストを行い，アプリ内でのモデルへのdeserializeを行います．</p>
<p>ここではREST APIを仮定したクラス設計を行いますが，gRPCやGraphQLの場合でも実装が異なるだけで責務自体は変わらないと思います．<br>
APIレスポンスは対応するモデルクラスにマッピングし，<code>dynamic</code>型として存在する期間を極力短く保ちます．</p>
<p>モデルクラスは適当な集約単位で作成し，レスポンスを正規化して持つようにします．
<a href="https://pub.dev/packages/json_serializable" target="_blank" rel="nofollow noopener noreferrer">json_serializable</a>と組み合わせて<code>deserialize</code>の実装をModelのconstructorとして任せると楽です．</p>
<p><div class="remark-container info"><div class="remark-container__title">immutable</div>Dartで構造体や関数以外への型エイリアスが定義できないのでclassとして定義するしかない．
ただ内部状態を変更できるクラスメソッドを書けてしまうと変更検知が辛くなってしまう．</div></p>
<div class="remark-highlight"><pre data-file="foo.dart" class="language-dart  line-numbers"><code class="language-dart"><span class="token metadata symbol">@freezed</span>
<span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token keyword">with</span> _$<span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">factory</span> <span class="token class-name">Foo</span><span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token keyword">dynamic</span><span class="token punctuation">></span></span> json<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> _$<span class="token class-name">FooFromJson</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span class=""></span><span class=""></span><span class=""></span><span class=""></span></span>
</code></pre></div>
<p>APIリクエストクラスは，実際のリクエスト処理の隠蔽及びテスト時のDIインターフェース統一のためにプロトコルで縛るようにします．
プロトコルはmixinとして定義し，リクエスト処理を行う<code>request</code>メソッドのみmixin側に実装します．<br>
ここでは簡単のため<code>url</code>以外の定義を省略していますが，クエリパラメータやヘッダなど，想定されるユースケースに応じた設定が行えるようにインターフェースを設計します．</p>
<p>今回はGETリクエストを想定した<code>GetRequestProtocol</code>を定義し，またそのユースケースとして<code>ListFooRequest</code>を実装します．<br>
また，<code>HttpClient</code>はHTTPリクエストを担う<a href="https://pub.dev/packages/http" target="_blank" rel="nofollow noopener noreferrer">http</a>や<a href="https://pub.dev/packages/dio" target="_blank" rel="nofollow noopener noreferrer">dio</a>，またはいずれかをwrapしたクラスです．</p>
<div class="remark-highlight"><pre data-file="api_protocol.dart" class="language-dart  line-numbers"><code class="language-dart"><span class="token comment">// `package:meta` に [@mustOverride] annotation が入ったら嬉しい</span>
<span class="token comment">// @see: <a href="https://github.com/dart-lang/sdk/issues/30175" class="token url-link">https://github.com/dart-lang/sdk/issues/30175</a></span>
<span class="token keyword">mixin</span> <span class="token class-name">GetRequestProtocol</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">M</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>
  <span class="token metadata symbol">@protected</span>
  <span class="token class-name">String</span> <span class="token keyword">get</span> url <span class="token operator">=</span><span class="token operator">></span> <span class="token keyword">throw</span> <span class="token class-name">UnimplementedError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">M</span><span class="token punctuation">></span></span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token class-name">HttpClient</span> client<span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> json <span class="token operator">=</span> <span class="token keyword">await</span> client<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token comment">/* api request */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">_deserialize</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token metadata symbol">@protected</span>
  <span class="token class-name">M</span> <span class="token function">_deserialize</span><span class="token punctuation">(</span><span class="token class-name">Response</span> json<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span></span>
</code></pre></div>
<p>ユースケース側は<code>GetRequestProtocol</code>を取り込んだRequestクラスを定義し，<code>request</code>メソッドが返すレスポンスをモデルへ変換する<code>deserialize</code>メソッドを実装します．</p>
<p>ここでは簡単のため<code>url</code>を固定値としていますが，実際には<a href="https://pub.dev/packages/flutter_dotenv" target="_blank" rel="nofollow noopener noreferrer">flutter_dotenv</a>を用いて環境変数としてAPIエンドポイントの管理を行います．
これは設定と実装の分離の観点からももちろん好ましいのですが，読み込む<code>.env</code>ファイルをテスト時に差し替えられる利点が大きいです．詳細は後述します．</p>
<div class="remark-highlight"><pre data-file="list_foo_request.dart" class="language-dart  line-numbers"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">ListFooRequest</span> <span class="token keyword">with</span> <span class="token class-name">GetRequestProtocol</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">List</span><span class="token punctuation">&#x3C;</span><span class="token class-name">Foo</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>
  <span class="token metadata symbol">@override</span>
  <span class="token class-name">String</span> <span class="token keyword">get</span> url <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'<a href="https://example.com/foos" class="token url-link">https://example.com/foos</a>'</span><span class="token punctuation">;</span>

  <span class="token metadata symbol">@override</span>
  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">Foo</span><span class="token punctuation">></span></span> <span class="token function">_deserialize</span><span class="token punctuation">(</span><span class="token class-name">Response</span> json<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// レスポンスのJSONが`foos`をキーとして[Foo]の配列を持つと仮定</span>
    <span class="token comment">// constructor の tear-off が入ると `.map(Foo.fromJson)`のようにかける</span>
    <span class="token comment">// @see: <a href="https://twitter.com/remi_rousselet/status/1438207417154686980?s=20" class="token url-link">https://twitter.com/remi_rousselet/status/1438207417154686980?s=20</a></span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>json<span class="token punctuation">[</span><span class="token string">'foos'</span><span class="token punctuation">]</span> <span class="token operator">as</span> <span class="token class-name">List</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token class-name">Foo</span><span class="token punctuation">.</span><span class="token function">fromJson</span><span class="token punctuation">(</span>f <span class="token operator">as</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token keyword">dynamic</span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span></span>
</code></pre></div>
<h3 id="test"><a href="#test">test</a></h3>
<p>APIクライアントクラスはネットワークリクエストを行い，レスポンスをモデルに変換するところまでを責務としました．<br>
Flutterのテストライブラリ<a href="https://api.flutter.dev/flutter/flutter_test/flutter_test-library.html" target="_blank" rel="nofollow noopener noreferrer">flutter_test</a>ではネットワークリクエストが遮断されるため，APIクライアントクラスに対するテストは<code>request</code>メソッドの返り値が対応するモデルインスタンスであるかどうかを評価することになります．<br>
モックのアプローチとしては以下の2パターンが考えられます;</p>
<ul>
<li>A. <a href="https://pub.dev/packages/mockito" target="_blank" rel="nofollow noopener noreferrer">mockito</a>を用いて<code>HttpClient</code>のモックオブジェクトを生成し，対応するレスポンスをスタブする</li>
<li>B. <a href="https://pub.dev/packages/mock_web_server" target="_blank" rel="nofollow noopener noreferrer">mock_http_server</a>を用いてテスト用APIサーバを構築し，閉じたネットワークでのテストを行う</li>
</ul>
<p>mockitoを用いる場合，今回の例題では<code>HttpClient</code>クラスの<code>get</code>メソッドをスタブすれば良さそうですが，HTTPリクエストを担うレイヤはinterceptorなどの機構を用いてロガーやエラーハンドラなどを注入するケースが多々あります．<br>
そのためテスト時に生成される<code>HttpClient</code>のモックオブジェクトと実際のリクエスト時に渡される<code>HttpClient</code>のインスタンスはスタブされている箇所以外にも設定が異なってしまうことが懸念されます．
したがって<code>HttpClient</code>の挙動がランタイムと乖離しないように，ネットワークリクエスト先をすげ替えるBの方針を取ることにします．</p>
<div class="remark-highlight"><pre data-file="list_foo_request_test.dart" class="language-dart  line-numbers"><code class="language-dart"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">final</span> server <span class="token operator">=</span> <span class="token class-name">MockWebServer</span><span class="token punctuation">(</span>port<span class="token punctuation">:</span> <span class="token number">8081</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">setUp</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
    <span class="token comment">// APIエンドポイントを[MockWebServer]にすげ替えるためにテスト用の.envファイルを読み込む．</span>
    <span class="token comment">// HttpClientがbaseUrlを保持するパターンもあるが，全てのAPIが単一のbaseUrlからされない場合もあるので</span>
    <span class="token comment">// このようにしておく．</span>
    <span class="token keyword">await</span> dotenv<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>fileName<span class="token punctuation">:</span> <span class="token string">'.env.test'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    server<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">tearDown</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>shutdown<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// エラー時のテストケースについては，エラーハンドラを`request`メソッドの実装に持たせたり</span>
  <span class="token comment">// interceptorで挟んだりするためHttpClientやmixinのテストで記述する．</span>
  <span class="token comment">// したがって個々のRequestクラスのテストケースはシンプルに保つことができる．</span>
  <span class="token function">test</span><span class="token punctuation">(</span><span class="token string">'ListFooRequest returns list of Foo'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
    <span class="token comment">// ここではJSONの構築に[dart:convert#jsonEncode]を用いた．</span>
    <span class="token comment">// `json_serializable` が生成する`toJson`メソッドで適当なレスポンスを組み立ててもよい．</span>
    <span class="token keyword">final</span> body <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">'foos'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token comment">/* Foo モデル */</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    server<span class="token punctuation">.</span><span class="token function">enqueue</span><span class="token punctuation">(</span>httpCode<span class="token punctuation">:</span> <span class="token number">200</span><span class="token punctuation">,</span> body<span class="token punctuation">:</span> <span class="token function">jsonEncode</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">final</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token class-name">ListFooRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>httpClient<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">expect</span><span class="token punctuation">(</span>response<span class="token punctuation">,</span> isA<span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">List</span><span class="token punctuation">&#x3C;</span><span class="token class-name">Foo</span><span class="token punctuation">></span><span class="token punctuation">></span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span></span>
</code></pre></div>
<h2 id="repository"><a href="#repository">Repository</a></h2>
<p>Repositoryクラスはデータ取得及びデータの更新操作を行います．<br>
ここではAPIからのリモートデータリソースのみを扱っていますが，<a href="https://pub.dev/packages/shared_preferences" target="_blank" rel="nofollow noopener noreferrer">shared_preferences</a>やKeychain/KeyStoreを利用したローカルデータソースに対する操作も責務に含まれます．</p>
<p>RepositoryクラスはViewModelレイヤから利用されるのですが，Repositoryクラスはネットワークアクセスが行われるためViewModelクラスの内部でRepositoryクラスを初期化してしまうとViewModelのテストが困難になります．<br>
かといってViewModelクラスのコンストラクタにRepositoryクラスを引数として渡す場合，そのViewModelクラスを利用するViewでRepositoryクラスを作成してViewModelを得る必要が出てしまい，レイヤ跨ぎ(View -> Repository)が発生してしまいます．</p>
<p>これを解消するためにDI(Dependency Injection)を用いて各レイヤ間の結合をDIプロバイダに委任します．</p>
<p>Repositoryインスタンスには<a href="https://pub.dev/packages/riverpod" target="_blank" rel="nofollow noopener noreferrer">riverpod</a>の提供する<code>Provider</code>を介してアクセスするようにします．
そのために<code>FooRepository</code>にはパブリックなコンストラクタを実装せずプライベートコンストラクタ<code>._()</code>のみを定義し，外部ファイルから<code>FooRepository</code>インスタンスを直接立ち上げることを禁止します．</p>
<div class="remark-highlight"><pre data-file="foo_repository.dart" class="language-dart"><code class="language-dart"><span class="token keyword">final</span> fooRepositoryProvider <span class="token operator">=</span> <span class="token class-name">Provider</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">FooRepository</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span>ref<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token class-name">FooRepository</span><span class="token punctuation">.</span><span class="token function">_</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span>read<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>
<p>また，(一般的なアーキテクチャにおける)Repositoryクラスは永続化層と表現されることもあり，その文脈ではキャッシュ機構を持つことがあります．<br>
仮に<code>FooRepository</code>がキャッシュ機構を持つとした場合，そのテストがどのように記述されるべきかを見ていきます．</p>
<p><code>FooRepository</code>がキャッシュ機構を持つ場合，リモートデータソースとキャッシュとの整合性の不一致が生じえます．
例えば<code>create</code>を呼んだ後に<code>list</code>を実行すると，<code>create</code>したデータが含まれないキャッシュが返されるなどが考えられます．<br>
データの整合性を担保するにはいくつか方法がありますが，ここではシンプルにキャッシュの破棄操作を行う実装を行うとしましょう．</p>
<div class="remark-highlight"><pre data-file="foo_repository.dart" class="language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">FooRepository</span> <span class="token punctuation">{</span>
  <span class="token comment">// @see <a href="https://pub.dev/documentation/riverpod/latest/riverpod/Ref/read.html" class="token url-link">https://pub.dev/documentation/riverpod/latest/riverpod/Ref/read.html</a></span>
  <span class="token class-name">FooRepository</span><span class="token punctuation">.</span><span class="token function">_</span><span class="token punctuation">(</span><span class="token class-name">Reader</span> read<span class="token punctuation">)</span> <span class="token punctuation">:</span> _httpClient <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>httpClientProvider<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">final</span> <span class="token class-name">HttpClient</span> _httpClient<span class="token punctuation">;</span>
  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">Foo</span><span class="token punctuation">></span></span><span class="token operator">?</span> _cache<span class="token punctuation">;</span>

  <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">List</span><span class="token punctuation">&#x3C;</span><span class="token class-name">Foo</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_cache <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> _cache<span class="token punctuation">;</span>

    _cache <span class="token operator">=</span> <span class="token class-name">ListFooRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>_httpClient<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> _cache<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Requestクラスの説明では省略した[CreateFooRequest]を用いて</span>
  <span class="token comment">// [Foo]レコードを作成するリクエストを行う．</span>
  <span class="token comment">// [CreateFoo]クラスは[Foo]レコードを作成する際のDTO.</span>
  <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">Foo</span><span class="token punctuation">></span></span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">CreateFoo</span> createFoo<span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
    _cache <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">await</span> <span class="token class-name">CreateFooRequest</span><span class="token punctuation">(</span>createFoo<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span>_httpClient<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<h3 id="test-1"><a href="#test-1">test</a></h3>
<p>Repositoryクラスはデータ取得・更新操作を行い，データの整合性を担保します．
Repositoryクラスのユースケースにおいては，その内部にキャッシュ機構があるかどうか，またはインメモリデータベースを利用しているかどうかは隠蔽されているべきです．
したがって実装の詳細には触れず，その振る舞いのみを保証するにはテストデータ更新後に最新のデータを返すかどうかを確認すれば良さそうです．</p>
<p>次にテスト容易性を主軸にRepositoryクラスをどのように提供するか考察します．<br>
Repositoryクラスはその責務上複数のAPIクライアントクラスを操作するため，テストのタイミングではAPIクライアントクラスもしくはその処理のモックが必要となります．
Repositoryクラスにおいてもどのレイヤーをモックするかが設計のポイントとなるのですが，Repositoryクラスのコンストラクタに渡される<code>HttpClient</code>をモックする方針をとります．<br>
判断に至った思考仮定は次のようなものです;</p>
<p><strong>A. APIクライアントのテストのようにAPIサーバをモックする場合</strong><br>
この場合Repositoryクラスが扱う各APIクライアントクラスに対するモックAPIサーバの設定を記述する必要があります．
この設定にはエンドポイントのURLやレスポンスのJSONスキーマ定義など，APIクライアントクラスの責務となる詳細部分が必要なので，
APIクライアントの実装を変更することでRepositoryクラスのテストがfailする可能性があり，修正に脆いテストとなり得ます．</p>
<p><strong>B. 個々のAPIクライアントクラスをモックする場合</strong><br>
先に示した<code>FooRepository</code>クラスの実装ではAPIクライアントクラスをハードコードして利用しています．<br>
APIクライアントクラスをモックする場合には各APIクライアントクラスをDIするかコンストラクタの引数として受け取るような実装をする必要が生じます．<br>
(callerの直接の)コンストラクタでの引数渡しについては先に述べたとおり抽象化レイヤを跨いでしまうため避けたいです．<br>
またAPIクライアントクラスはRepositoryクラスにとってStatic Dependency<sup><a href="#user-content-fn-1" id="user-content-fnref-1" data-footnote-ref aria-describedby="footnote-label">1</a></sup>であり，また各APIクライアントクラスをDIすることはOver-Injection<sup><a href="#user-content-fn-2" id="user-content-fnref-2" data-footnote-ref aria-describedby="footnote-label">2</a></sup>に繋がるのでこれもベストとは言い難いです．</p>
<p><strong>C. HttpClientをモックする場合</strong><br>
Aではネットワーク先，BではAPIクライアントの振る舞いをそれぞれスタブする方針でした．<br>
APIクライアントクラスが利用する<code>HttpClient</code>をモックすることで，APIクライアントのネットワークリクエスト処理のみをスタブすることができます．<br>
APIクライアントクラスが<code>HttpClient</code>を利用する処理はmixinとして実装を与えてあるため，個々のAPIクライアントクラスの振る舞いには左右されず修正に強いテストが期待できます．
またBと比較してもDIする対象が1つで済むため適切であると言えます．</p>
<p>テストコードで<code>HttpClient</code>をProviderから受け取るには<code>ProviderContainer</code>を利用します．<br>
<code>ProviderContainer</code>の引数にDIプロバイダのオーバーライド設定を指定することで，テスト内では<code>mockHttpClient</code>を利用するRepositoryクラスを利用することができます．</p>
<div class="remark-highlight"><pre data-file="foo_repository_test.dart" class="language-dart"><code class="language-dart"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">final</span> container <span class="token operator">=</span> <span class="token class-name">ProviderContainer</span><span class="token punctuation">(</span>
    overrides<span class="token punctuation">:</span> <span class="token punctuation">[</span>httpClientProvider<span class="token punctuation">.</span><span class="token function">overrideWithValue</span><span class="token punctuation">(</span>mockHttpClient<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">final</span> repository <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>fooRepositoryProvider<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>データ整合性のテストはユースケースを元に，<code>create</code>メソッド実行後に<code>list</code>メソッドの実行結果が<code>create</code>したデータを含むかどうかを確認します．</p>
<p><small>もちろん<code>list</code>メソッド単体のテストは書く前提です.</small></p>
<div class="remark-highlight"><pre data-file="foo_repository_test.dart" class="language-dart"><code class="language-dart"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// omitted</span>

  <span class="token comment">// HttpClientの挙動をスタブ</span>
  <span class="token function">when</span><span class="token punctuation">(</span>mockHttpClient<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>any<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenAnswer</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token operator">=</span><span class="token operator">></span> listFooResponse<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> response <span class="token operator">=</span> <span class="token keyword">await</span> repository<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// verify(mockHttpClient.get(any)) として</span>
  <span class="token comment">// **内部でmockHttpClientが呼ばれた**ことをテストすることも可能だが，</span>
  <span class="token comment">// ここではRepositoryクラスの振る舞いを見ることを主軸に置くためテストに含めない．</span>
  <span class="token comment">// 実際のユースケースではRepositoryクラスはProvider経由で利用され，</span>
  <span class="token comment">// HttpClientはProvider内部で渡されるため利用する側からはHttpClientはされている.</span>
  <span class="token comment">// あくまでテストにおいてのみRepositoryクラスがHttpClientを利用していることを知る必要が生じている．</span>
  <span class="token comment">//</span>
  <span class="token comment">// ListFooRequestの結果が返される</span>
  <span class="token function">expect</span><span class="token punctuation">(</span>response<span class="token punctuation">,</span> listFooResponse<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// create時の挙動をスタブ</span>
  <span class="token function">when</span><span class="token punctuation">(</span>mockHttpClient<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>any<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenAnswer</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token operator">=</span><span class="token operator">></span> createResponse<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">final</span> createFoo <span class="token operator">=</span> <span class="token class-name">CreateFoo</span><span class="token punctuation">(</span><span class="token comment">/* */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  response <span class="token operator">=</span> <span class="token keyword">await</span> repository<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>createFoo<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">expect</span><span class="token punctuation">(</span>response<span class="token punctuation">,</span> createResponse<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 再度Listした際に更新されたResponseが返される</span>
  <span class="token function">when</span><span class="token punctuation">(</span>mockHttpClient<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>any<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenAnswer</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token operator">=</span><span class="token operator">></span> updatedListResponse<span class="token punctuation">)</span><span class="token punctuation">;</span>
  response <span class="token operator">=</span> <span class="token keyword">await</span> repository<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">expect</span><span class="token punctuation">(</span>response<span class="token punctuation">,</span> updatedListResponse<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<h2 id="viewmodel"><a href="#viewmodel">ViewModel</a></h2>
<p>ViewModelはViewが利用するデータ及びロジックを提供します．<br>
ここが一番責務をどこにおくか悩むところだと思うので，ViewModelの定義について John Gossman. (2005)<sup><a href="#user-content-fn-3" id="user-content-fnref-3" data-footnote-ref aria-describedby="footnote-label">3</a></sup>を紹介します．</p>
<blockquote>
<p>The UI may want to perform complex operations that must be implemented in code which doesn't make sense in our strict definition of the View but are too specific to be included in the Model (or didn't come with the pre-existing model).
Finally we need a place to put view state such as selection or modes.</p>
<p>The ViewModel is responsible for these tasks.
The term means "Model of a View", and can be thought of as abstraction of the view,
but it also provides a specialization of the Model that the View can use for data-binding.
In this latter role the ViewModel contains data-transformers that convert Model types into View types, and it contains Commands the View can use to interact with the Model.</p>
</blockquote>
<p>ここで示したいのはViewModelはViewとのデータバインディングだけではなく，Viewが行う複雑な操作(=ドメインロジック)をも責務に含むという点です．
これは逆にViewにそのような処理をもたせてはいけないというだけなので，ViewModelまたはServiceレイヤに持たせるようにします．<br>
ViewModelからはViewでの操作のハンドラを提供し，ViewからServiceクラスを直接呼ぶことのないようにします．<br>
例外的にpull-to-refreshのように描画・アニメーションがメインとなるロジックや，<code>BuildContext</code>を介する処理(例: <code>Navigator.push</code>等)についてはView側の責務となります．</p>
<p>また，テスト容易性の観点からはMartin Fowler氏のHumble Object<sup><a href="#user-content-fn-4" id="user-content-fnref-4" data-footnote-ref aria-describedby="footnote-label">4</a></sup>をイメージするとViewとViewModelとのそれぞれの責務の切り分けがしやすいかと思います．</p>
<p>Viewのテストを考慮すると，View内部でViewModelをイニシャライズするとViewModelのモックがやや手間になります．<br>
したがってViewModelにおいてもProviderを利用して提供します．</p>
<p>ここで，ViewModelのライフサイクルをどうするか検討しましょう．<br>
ViewModelがViewを参照しない・してはならないことからもわかるように，ViewModelとViewとのライフサイクルは異なります．
しかしViewインスタンスが破棄された後にViewModelが生き続けると，再度Viewが生成された際にその(中途半端な状態を持つ)ViewModelが参照されると困るケースもあります．
そういったケースでは<code>StateNotifierProvider.autoDispose</code>を用いてViewModelのライフサイクルをViewに揃え，Viewが生成されるタイミングでViewModelを生成してデータの整合性を担保するようにします．</p>
<div class="remark-highlight"><pre data-file="view_model.dart" class="language-dart"><code class="language-dart"><span class="token keyword">final</span> fooViewModelProvider <span class="token operator">=</span> <span class="token class-name">StateNotifierProvider</span><span class="token punctuation">.</span>autoDispose<span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">FooViewModel</span><span class="token punctuation">,</span> <span class="token class-name">FooState</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span>ref<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token class-name">WaitingListViewModel</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span>read<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>
<p>ViewModelが持つ状態はたとえ変数が1つであってもクラスとして切り出し，内包する状態が増えた際に変更に対して閉じるようにします．</p>
<div class="remark-highlight"><pre data-file="view_model.dart" class="language-dart"><code class="language-dart"><span class="token metadata symbol">@freezed</span>
<span class="token keyword">class</span> <span class="token class-name">FooState</span> <span class="token keyword">with</span> _$<span class="token class-name">FooState</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token keyword">factory</span> <span class="token class-name">FooState</span><span class="token punctuation">.</span><span class="token function">_</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    required <span class="token class-name">AsyncValue</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">List</span><span class="token punctuation">&#x3C;</span><span class="token class-name">Foo</span><span class="token punctuation">></span><span class="token punctuation">></span></span> foos<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span> _FooState<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>今回はViewがpull-to-refresh機能を提供するとして設計します．
その場合，Viewで必要となるロジックは以下のようなデータ及びイベントハンドラが考えられます；</p>
<ul>
<li>Viewで描画するデータ(<code>List&#x3C;Foo></code>)</li>
<li>View作成時のViewModelの初期化処理(<code>onInit</code>)</li>
<li>pull-to-refresh実行時のリフレッシュ処理(<code>onRefresh</code>)</li>
<li><code>Foo</code>の追加処理(<code>createFoo(CreateFoo foo)</code>)</li>
</ul>
<p>また描画するデータ<code>List&#x3C;Foo></code>はAPIから取得するため，初期状態はデータを保持しておらずローディング中・ローディング失敗の状態も考えられます．
そういったケースに対応するため<code>Future</code>の値の変化を検知・通知できる<a href="https://pub.dev/documentation/riverpod/latest/riverpod/AsyncValue-class.html" target="_blank" rel="nofollow noopener noreferrer"><code>AsyncValue</code></a>を利用します．</p>
<p>それぞれを実装におとすと次のようになります．</p>
<div class="remark-highlight"><pre data-file="view_model.dart" class="language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">FooViewModel</span> <span class="token keyword">extends</span> <span class="token class-name">StateNotifier</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">FooState</span><span class="token punctuation">></span></span> <span class="token punctuation">{</span>
  <span class="token class-name">FooViewModel</span><span class="token punctuation">(</span><span class="token class-name">Reader</span> read<span class="token punctuation">)</span>
      <span class="token punctuation">:</span> _repository <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fooRepositoryProvider<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">FooState</span><span class="token punctuation">.</span><span class="token function">_</span><span class="token punctuation">(</span>foos<span class="token punctuation">:</span> <span class="token class-name">AsyncValue</span><span class="token punctuation">.</span><span class="token function">loading</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// construct時に初期化処理`onInit`を実行</span>
    <span class="token function">onInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">final</span> <span class="token class-name">FooRepository</span> _repository<span class="token punctuation">;</span>

  <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token keyword">void</span><span class="token punctuation">></span></span> <span class="token function">onInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
    <span class="token comment">// 今回の例では簡単のため`onRefresh`を呼ぶだけ</span>
    <span class="token keyword">await</span> <span class="token function">onRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token keyword">void</span><span class="token punctuation">></span></span> <span class="token function">createFoo</span><span class="token punctuation">(</span><span class="token class-name">CreateFoo</span> foo<span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> _repository<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">await</span> <span class="token function">onRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catchError</span><span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// TODO</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token keyword">void</span><span class="token punctuation">></span></span> <span class="token function">onRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> _repository<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      state <span class="token operator">=</span> state<span class="token punctuation">.</span><span class="token function">copyWith</span><span class="token punctuation">(</span>foos<span class="token punctuation">:</span> <span class="token class-name">AsyncValue</span><span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catchError</span><span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      state <span class="token operator">=</span> state<span class="token punctuation">.</span><span class="token function">copyWith</span><span class="token punctuation">(</span>foos<span class="token punctuation">:</span> <span class="token class-name">AsyncValue</span><span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>e <span class="token operator">as</span> <span class="token class-name">Object</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div>
<h3 id="test-2"><a href="#test-2">test</a></h3>
<p>ViewModelはViewが利用するデータ及びロジックの提供を責務とします．<br>
ViewModelのテストですが，単体でのテストを行うかViewと組み合わせたテストを行うか正直自分の中で答えを出せていません．
Viewの持つロジックを極力薄くすることで，擬似的にViewの取りうる振る舞いをViewModelでテストすることは可能です．ただViewModelの取りうる状態に応じた描画はViewでのテストでしか担保することができず，かつそれらは無視できる量・質のものとは言い難いです．<br>
そのためViewはViewのテストが必要となりますが，ViewModelが示す状態に沿う描画ができているかを検査すればよいので，ある程度宣言的にテストを記述できます．</p>
<p>実際，実機での<a href="https://flutter.dev/docs/cookbook/testing/integration/introduction" target="_blank" rel="nofollow noopener noreferrer">integration_test</a>や回帰テストを行う<a href="https://pub.dev/packages/golden_toolkit" target="_blank" rel="nofollow noopener noreferrer">golden toolkit</a>などViewを対象としたテストツールも充実してきておりそれらを用いることで描画内容にとどまらないデザインのテストをも行うことが可能となってきています．</p>
<p>ただ，そこに実際のViewModelを持ち込むかモックしたViewModelを持ち込むかは明確な判断理由を持てていません．<br>
ここではテスト容易性を主軸においたアーキテクチャの紹介を行い，いわゆるUIテストについては上記の説明に留めることとします．</p>
<hr>
<p>先程実装した<code>FooRepository</code>はProvider経由のみのアクセスとするためにパブリックなコンストラクタを公開していませんでした．
直接インスタンスを生成できないというのも理由のひとつですが，<code>FooRepository</code>は内部でネットワークリクエストを行うためどのみちそのまま扱うことができません．<br>
そのため<code>FooRepository</code>のモックオブジェクトを生成し，<code>fooRepositoryProvider</code>に注入して<code>FooViewModel</code>から<code>MockFooRepository</code>が参照されるように設定します．</p>
<p>今回利用するモックライブラリ<a href="https://pub.dev/packages/mockito" target="_blank" rel="nofollow noopener noreferrer">mockito</a>が生成するモックは，次のように対象のクラスを<code>implements</code>する形で実装されます．<br>
パブリックなコンストラクタを自動で生成してくれるので，<code>MockFooRepository</code>インスタンスを用いて<code>fooRepositoryProvider</code>を上書きできます．</p>
<div class="remark-highlight"><pre data-file="foo_repository.mocks.dart" class="language-dart  line-numbers"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">MockFooRepository</span> <span class="token keyword">extends</span> _i1<span class="token punctuation">.</span>Mock <span class="token keyword">implements</span> _i2<span class="token punctuation">.</span>FooRepository <span class="token punctuation">{</span>
  <span class="token class-name">MockFooRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    _i1<span class="token punctuation">.</span><span class="token function">throwOnMissingStub</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token metadata symbol">@override</span>
  _i3<span class="token punctuation">.</span>Future<span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token class-name">List</span><span class="token punctuation">&#x3C;</span><span class="token class-name">Foo</span><span class="token punctuation">></span><span class="token punctuation">></span></span> <span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token comment">/* omitted */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span></span>
</code></pre></div>
<p>今回はViewModelとViewを共に扱いテストを行います．
ここでは<code>FooViewModel</code>を利用するViewを<code>FooView</code>とします．</p>
<div class="remark-highlight"><pre data-file="foo_view_model_test.dart" class="language-dart  line-numbers"><code class="language-dart"><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">final</span> repository <span class="token operator">=</span> <span class="token class-name">MockFooRepository</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">final</span> container <span class="token operator">=</span> <span class="token class-name">ProviderContainer</span><span class="token punctuation">(</span>
    overrides<span class="token punctuation">:</span> <span class="token punctuation">[</span>fooRepositoryProvider<span class="token punctuation">.</span><span class="token function">overrideWithValue</span><span class="token punctuation">(</span>repository<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// repositoryのmock等を行う</span>

  <span class="token function">testWidgets</span><span class="token punctuation">(</span><span class="token string">'FooViewModel smoke test with view'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">WidgetTester</span> tester<span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> widget <span class="token operator">=</span> <span class="token class-name">ProviderScope</span><span class="token punctuation">(</span>
      overrides<span class="token punctuation">:</span> <span class="token punctuation">[</span>fooRepositoryProvider<span class="token punctuation">.</span><span class="token function">overrideWithValue</span><span class="token punctuation">(</span>repository<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
      child<span class="token punctuation">:</span> <span class="token keyword">const</span> <span class="token class-name">MaterialApp</span><span class="token punctuation">(</span>home<span class="token punctuation">:</span> <span class="token class-name">FooView</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">await</span> tester<span class="token punctuation">.</span><span class="token function">runAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token punctuation">{</span>
      <span class="token keyword">await</span> tester<span class="token punctuation">.</span><span class="token function">pumpWidget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 初期状態の確認.</span>
      <span class="token comment">// APIリクエストが完了していないのでデータローディングの旨を表示したい</span>
      <span class="token function">expect</span><span class="token punctuation">(</span>find<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token string">'データ読み込み中'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> findsOneWidget<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// 描画更新を更新.</span>
      <span class="token comment">// APIリクエストが完了している(ようレスポンスをスタブする)ので</span>
      <span class="token comment">// ローディングが完了しデータが描画されていることを確認</span>
      <span class="token comment">// (レスポンスはListViewで描画しているとする)</span>
      <span class="token function">expect</span><span class="token punctuation">(</span>find<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token string">'データ読み込み中'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> findsNothing<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">expect</span><span class="token punctuation">(</span>find<span class="token punctuation">.</span><span class="token function">byType</span><span class="token punctuation">(</span><span class="token class-name">ListView</span><span class="token punctuation">)</span><span class="token punctuation">,</span> findsOneWidget<span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token comment">// pull to refresh 実行</span>
      <span class="token comment">// pull to refreshをテスト上でimitateする処理は以下を参照</span>
      <span class="token comment">// @see: <a href="https://github.com/flutter/flutter/blob/d62f75dde1cb6f04fadb9aff48896491ff0e2163/packages/flutter/test/material/refresh_indicator_test.dart#L119-L122" class="token url-link">https://github.com/flutter/flutter/blob/d62f75dde1cb6f04fadb9aff48896491ff0e2163/packages/flutter/test/material/refresh_indicator_test.dart#L119-L122</a></span>
      <span class="token function">when</span><span class="token punctuation">(</span>repository<span class="token punctuation">.</span><span class="token function">list</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">thenAnswer</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_<span class="token punctuation">)</span> <span class="token keyword">async</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token comment">/* response */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">await</span> tester<span class="token punctuation">.</span><span class="token function">fling</span><span class="token punctuation">(</span>find<span class="token punctuation">.</span><span class="token function">byType</span><span class="token punctuation">(</span><span class="token class-name">ListView</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">Offset</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">await</span> tester<span class="token punctuation">.</span><span class="token function">pump</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">await</span> tester<span class="token punctuation">.</span><span class="token function">pump</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token class-name">Duration</span><span class="token punctuation">(</span>seconds<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// responseが更新されていることを確認</span>
      <span class="token function">expect</span><span class="token punctuation">(</span><span class="token comment">/* */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span><span class=""></span></span>
</code></pre></div>
<p>同様にしてRepositoryから<code>Future.error</code>を返すことでWidgetのエラー時の描画のテストを行うことが可能です．</p>
<h3 id="viewmodelとservice-class"><a href="#viewmodelとservice-class">ViewModelとService class</a></h3>
<p>ViewModelの処理をどのタイミングでServiceクラスへ委譲するかの基準は，<a href="https://docs.microsoft.com/en-us/visualstudio/test/unit-test-basics?view=vs-2019#write-your-tests" target="_blank" rel="nofollow noopener noreferrer">Arrange-Act-Assert</a>におけるArrange<sup><a href="#user-content-fn-6" id="user-content-fnref-6" data-footnote-ref aria-describedby="footnote-label">5</a></sup>のコストを一つの目安とすることができます．<br>
テストの準備の記述(Arrange)が少なくない割合を占める場合，テスト対象が状態や責務を持ちすぎている可能性があります．
そうなった場合にはArrangeの記述及びViewModelのメソッドの処理からテスト(の準備が)しづらいメソッドを探しだしてServiceクラスへ抽出します．
そうすることでテスト容易性を高め，かつテスト対象の関心の対象を絞ることで壊れづらいテストコードを保つことが可能です．</p>
<p><small>このアプローチは実際テスト対象とレイヤーの異なる責務を見分けて分離するには便利な手法だと感じています</small></p>
<p>補足:<br>
SOLID原則の<a href="https://en.wikipedia.org/wiki/Single-responsibility_principle" target="_blank" rel="nofollow noopener noreferrer">Single-responsibility principle</a>は"1つのクラスは1つの責務"といった説明がされがちですが，真意は"1つのクラスは1つの(アクターに対し)責務(を負う)"ということです．<br>
ViewModelは責務が多くなりがちですが，対応するViewに対してのみ責務を追っているためSRPの観点からは適切です．<br>
ただしViewModelのメソッドの処理をテストする際にViewModelがServiceクラスのアクターになれる場合においては，それはメソッドの処理をServiceクラスへと切り出すタイミングだと思います．</p>
<hr>
<p>以上，テスト容易性を意識したFlutterアプリケーションのアーキテクチャを考察していきました．
長くなってスマン.</p>
<p>Dartの型システムは比較的緩いので，そういった言語特性も含めテストでカバーしていきたい気持ちがあり今回このような検討を行いました．<br>
結合度と凝集度など関数レベルでの設計やTDDなどのプラクティスはもちろん，アーキテクチャレベルで考慮することで更にテスト容易性を向上することができ，またソフトウェアの品質を担保することに繋がります．</p>
<small>
  半年とか経ったら振り返りをしようと考えています．  
</small>
<hr>
<h3 id="2021-11-15-追記"><a href="#2021-11-15-追記">2021-11-15 追記:</a></h3>
<p>ご指摘をいただき，<code>xxxProvider</code>内で<code>ref.read</code>を呼ぶ代わりに<code>ref.read</code>を渡すように修正しました．<br>
元々の設計意図はDIフレームワークを各レイヤの実装内部に持ち込みたくなかったというのがあります．
Riverpodでは以下のように記述することで(後述するパフォーマンスの問題を除けば)Provider内部で別のProviderの値を取得することが可能です．</p>
<div class="remark-highlight"><pre class="language-dart"><code class="language-dart"><span class="token comment">// bad</span>
<span class="token keyword">final</span> fooViewModelProvider <span class="token operator">=</span> <span class="token class-name">StateNotifierProvider</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span>ref<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token class-name">FooViewModel</span><span class="token punctuation">(</span>repository<span class="token punctuation">:</span> ref<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>fooRepositoryProvider<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div>
<p><code>fooViewModelProvider</code>を<code>FooViewModel</code>と<code>fooRepositoryProvider</code>の糊付けとして用いることで，<code>FooViewModel</code>の実装内部にRiverpodを持ち込まなくて済みます．</p>
<div class="remark-highlight"><pre class="language-dart"><code class="language-dart"><span class="token keyword">class</span> <span class="token class-name">FooViewModel</span> <span class="token punctuation">{</span>
  <span class="token comment">// 修正前は`fooViewModelProvider`を糊付けとして利用して`FooViewModel`にRiverpodのコードを入れないようにしていた.</span>
  <span class="token class-name">FooViewModel</span><span class="token punctuation">(</span><span class="token punctuation">{</span>required <span class="token class-name">FooRepository</span> repository<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>ただ<a href="https://riverpod.dev/docs/concepts/combining_providers/#can-i-read-a-provider-without-listening-to-it" target="_blank" rel="nofollow noopener noreferrer">こちら</a>にもあるように<code>ref.read</code>をProvider内部で呼ぶことは不要なリビルドを招くため，次のように<code>Reader</code>関数を渡すように修正しました．</p>
<p>個人的には<code>Reader</code>を引数にとるのはService Locatorパターンだと考えているので，<code>Reader</code>をメンバとして保持しないようにコンストラクタで取得後破棄するようにしています．</p>
<div class="remark-highlight"><pre class="language-dart"><code class="language-dart"><span class="token comment">// good</span>
<span class="token keyword">final</span> fooViewModelProvider <span class="token operator">=</span> <span class="token class-name">StateNotifierProvider</span><span class="token generics"><span class="token punctuation">&#x3C;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span>ref<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token class-name">FooViewModel</span><span class="token punctuation">(</span>ref<span class="token punctuation">.</span>read<span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">FooViewModel</span> <span class="token punctuation">{</span>
  <span class="token comment">// `ref.read`を受取り，コンストラクタで`read`する</span>
  <span class="token class-name">FooViewModel</span><span class="token punctuation">(</span><span class="token class-name">Reader</span> reader<span class="token punctuation">)</span> <span class="token punctuation">:</span> _repository <span class="token operator">=</span> <span class="token function">read</span><span class="token punctuation">(</span>fooRepositoryProvider<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">final</span> <span class="token class-name">FooRepository</span> _repository<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>正直修正後もベストかどうか自信がないので，引き続き試行錯誤していこうと思います．</p>
<p>改めてご指摘頂いた方々には感謝しています．ありがとうございます．</p>
<section data-footnotes class="footnotes"><h2 id="footnote-label" class="sr-only"><a href="#footnote-label">Footnotes</a></h2>
<ol>
<li id="user-content-fn-1">
<p><a href="https://livebook.manning.com/book/dependency-injection-principles-practices-patterns/about-this-book/1" target="_blank" rel="nofollow noopener noreferrer">Dependency Injection principles, Manning</a>. volatile dependency/static dependency <a href="#user-content-fnref-1" data-footnote-backref class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-2">
<p><a href="https://blog.ploeh.dk/2018/08/27/on-constructor-over-injection/" target="_blank" rel="nofollow noopener noreferrer">https://blog.ploeh.dk/2018/08/27/on-constructor-over-injection/</a> <a href="#user-content-fnref-2" data-footnote-backref class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-3">
<p><a href="https://docs.microsoft.com/en-us/archive/blogs/johngossman/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps" target="_blank" rel="nofollow noopener noreferrer">https://docs.microsoft.com/en-us/archive/blogs/johngossman/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps</a> <a href="#user-content-fnref-3" data-footnote-backref class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-4">
<p><a href="https://martinfowler.com/bliki/HumbleObject.html" target="_blank" rel="nofollow noopener noreferrer">https://martinfowler.com/bliki/HumbleObject.html</a> <a href="#user-content-fnref-4" data-footnote-backref class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
<li id="user-content-fn-6">
<p>またはHeuristics of Software TestabilityにおけるControllability/Decomposability. <a href="#user-content-fnref-6" data-footnote-backref class="data-footnote-backref" aria-label="Back to content">↩</a></p>
</li>
</ol>
</section></div></article><div class="CommitLogs_commit_logs__W6xPi" role="log"><h2>Commits</h2><details><summary><span class="CommitLogs_commit__date___q8bm">2021-11-16 00:41:55</span><span class="CommitLogs_commit__hash__Xyu7v">27de1553</span><span class="CommitLogs_commit__message__IGUPv">refac: use Reader</span></summary><div><div class="remark-highlight"><pre data-file="27de1553.patch" class="language-git  language-diff"><code class="language-git"><span class="token commit-sha1">commit 27de15535be63d9f250f908627bb68497c8d9699</span>
Author: koka &#x26;<a href="mailto:lt;koka.code@gmail.com" class="token email-link">lt;koka.code@gmail.com</a>&#x26;gt;
Date:   Tue Nov 16 00:41:55 2021 +0900

  refac: use Reader

diff --git a/_posts/2021-10-20-testable-architecture-flutter.md b/_posts/2021-10-20-testable-architecture-flutter.md
index 81bc4d0..da2f4a5 100644
<span class="token deleted">--- a/_posts/2021-10-20-testable-architecture-flutter.md</span>
<span class="token inserted">+++ b/_posts/2021-10-20-testable-architecture-flutter.md</span>
@@ -182,7 +182,7 @@ Repositoryインスタンスには[riverpod][riverpod]の提供する`Provider`

\```dart[data-file=<span class="token string">"foo_repository.dart"</span>]
final fooRepositoryProvider = Provider&#x26;lt;FooRepository&#x26;gt;(
<span class="token deleted">-  (ref) =&#x26;gt; FooRepository._(ref.read(httpClientProvider)),</span>
<span class="token inserted">+  (ref) =&#x26;gt; FooRepository._(ref.read),</span>
);
\```

@@ -195,7 +195,8 @@ final fooRepositoryProvider = Provider&#x26;lt;FooRepository&#x26;gt;(

\```dart[data-file=<span class="token string">"foo_repository.dart"</span>]
class FooRepository {
<span class="token deleted">-  FooRepository._(this._httpClient);</span>
<span class="token inserted">+  // @see https://pub.dev/documentation/riverpod/latest/riverpod/Ref/read.html</span>
<span class="token inserted">+  FooRepository._(Reader read) : _httpClient = read(httpClientProvider);</span>

 final HttpClient _httpClient;
 List&#x26;lt;Foo&#x26;gt;? _cache;
@@ -245,10 +246,6 @@ APIクライアントクラスが利用する`HttpClient`をモックするこ
APIクライアントクラスが`HttpClient`を利用する処理はmixinとして実装を与えてあるため，個々のAPIクライアントクラスの振る舞いには左右されず修正に強いテストが期待できます．
またBと比較してもDIする対象が1つで済むため適切であると言えます．

<span class="token deleted">-::: warn FooRepositoryのコンストラクタについて</span>
<span class="token deleted">-FooRepository内部で直接ProviderをService Locatorとして利用することを避けるために，HttpClientをコンストラクタの引数として渡すような設計になっています．</span>
<span class="token deleted">-:::</span>
<span class="token deleted">-</span>
テストコードで`HttpClient`をProviderから受け取るには`ProviderContainer`を利用します．  
`ProviderContainer`の引数にDIプロバイダのオーバーライド設定を指定することで，テスト内では`mockHttpClient`を利用するRepositoryクラスを利用することができます．

@@ -325,9 +322,7 @@ ViewModelがViewを参照しない・してはならないことからもわか

\```dart[data-file=<span class="token string">"view_model.dart"</span>]
final fooViewModelProvider = StateNotifierProvider.autoDispose&#x26;lt;FooViewModel, FooState&#x26;gt;(
<span class="token deleted">-  (ref) =&#x26;gt; WaitingListViewModel(</span>
<span class="token deleted">-    fooRepository: ref.read(fooRepositoryProvider),</span>
<span class="token deleted">-  ),</span>
<span class="token inserted">+  (ref) =&#x26;gt; WaitingListViewModel(ref.read),</span>
);
\```

@@ -357,8 +352,8 @@ class FooState with _$FooState {

\```dart[data-file=<span class="token string">"view_model.dart"</span>]
class FooViewModel extends StateNotifier&#x26;lt;FooState&#x26;gt; {
<span class="token deleted">-  FooViewModel({required FooRepository fooRepository})</span>
<span class="token deleted">-      : _repository = fooRepository,</span>
<span class="token inserted">+  FooViewModel(Reader read)</span>
<span class="token inserted">+      : _repository = read(fooRepositoryProvider),</span>
       super(const FooState._(foos: AsyncValue.loading())) {
   // construct時に初期化処理`onInit`を実行
   onInit();
@@ -493,6 +488,52 @@ Dartの型システムは比較的緩いので，そういった言語特性も
 半年とか経ったら振り返りをしようと考えています．  
&#x26;lt;/small&#x26;gt;

<span class="token inserted">+---</span>
<span class="token inserted">+</span>
<span class="token inserted">+### 2021-11-15 追記:</span>
<span class="token inserted">+</span>
<span class="token inserted">+ご指摘をいただき，`xxxProvider`内で`ref.read`を呼ぶ代わりに`ref.read`を渡すように修正しました．  </span>
<span class="token inserted">+元々の設計意図はDIフレームワークを各レイヤの実装内部に持ち込みたくなかったというのがあります．</span>
<span class="token inserted">+Riverpodでは以下のように記述することで(後述するパフォーマンスの問題を除けば)Provider内部で別のProviderの値を取得することが可能です．  </span>
<span class="token inserted">+</span>
<span class="token inserted">+\```dart</span>
<span class="token inserted">+// bad</span>
<span class="token inserted">+final fooViewModelProvider = StateNotifierProvider&#x26;lt;...&#x26;gt;(</span>
<span class="token inserted">+  (ref) =&#x26;gt; FooViewModel(repository: ref.read(fooRepositoryProvider)),</span>
<span class="token inserted">+);</span>
<span class="token inserted">+\```</span>
<span class="token inserted">+</span>
<span class="token inserted">+`fooViewModelProvider`を`FooViewModel`と`fooRepositoryProvider`の糊付けとして用いることで，`FooViewModel`の実装内部にRiverpodを持ち込まなくて済みます．</span>
<span class="token inserted">+</span>
<span class="token inserted">+\```dart</span>
<span class="token inserted">+class FooViewModel {</span>
<span class="token inserted">+  // 修正前は`fooViewModelProvider`を糊付けとして利用して`FooViewModel`にRiverpodのコードを入れないようにしていた.</span>
<span class="token inserted">+  FooViewModel({required FooRepository repository});</span>
<span class="token inserted">+}</span>
<span class="token inserted">+\```</span>
<span class="token inserted">+</span>
<span class="token inserted">+ただ[こちら][provider_read]にもあるように`ref.read`をProvider内部で呼ぶことは不要なリビルドを招くため，次のように`Reader`関数を渡すように修正しました．</span>
<span class="token inserted">+</span>
<span class="token inserted">+個人的には`Reader`を引数にとるのはService Locatorパターンだと考えているので，`Reader`をメンバとして保持しないようにコンストラクタで取得後破棄するようにしています．</span>
<span class="token inserted">+</span>
<span class="token inserted">+\```dart</span>
<span class="token inserted">+// good</span>
<span class="token inserted">+final fooViewModelProvider = StateNotifierProvider&#x26;lt;...&#x26;gt;(</span>
<span class="token inserted">+  (ref) =&#x26;gt; FooViewModel(ref.read)</span>
<span class="token inserted">+);</span>
<span class="token inserted">+</span>
<span class="token inserted">+class FooViewModel {</span>
<span class="token inserted">+  // `ref.read`を受取り，コンストラクタで`read`する</span>
<span class="token inserted">+  FooViewModel(Reader reader) : _repository = read(fooRepositoryProvider);</span>
<span class="token inserted">+</span>
<span class="token inserted">+  final FooRepository _repository;</span>
<span class="token inserted">+}</span>
<span class="token inserted">+\```</span>
<span class="token inserted">+</span>
<span class="token inserted">+正直修正後もベストかどうか自信がないので，引き続き試行錯誤していこうと思います．</span>
<span class="token inserted">+</span>
<span class="token inserted">+改めてご指摘頂いた方々には感謝しています．ありがとうございます．</span>
<span class="token inserted">+</span>
[praha_test]: <a href="https://www.praha-inc.com/lab/posts/testability" class="token url-link">https://www.praha-inc.com/lab/posts/testability</a>
[testability]: <a href="https://www.satisfice.com/download/heuristics-of-software-testability" class="token url-link">https://www.satisfice.com/download/heuristics-of-software-testability</a>
[shared_preferences]: <a href="https://pub.dev/packages/shared_preferences" class="token url-link">https://pub.dev/packages/shared_preferences</a>
@@ -514,6 +555,7 @@ Dartの型システムは比較的緩いので，そういった言語特性も

[aaa]: <a href="https://docs.microsoft.com/en-us/visualstudio/test/unit-test-basics?view=vs-2019#write-your-tests" class="token url-link">https://docs.microsoft.com/en-us/visualstudio/test/unit-test-basics?view=vs-2019#write-your-tests</a>
[srp]: <a href="https://en.wikipedia.org/wiki/Single-responsibility_principle" class="token url-link">https://en.wikipedia.org/wiki/Single-responsibility_principle</a>
<span class="token inserted">+[provider_read]: https://riverpod.dev/docs/concepts/combining_providers/#can-i-read-a-provider-without-listening-to-it</span>


[^1]: [Dependency Injection principles, Manning][di_principles]. volatile dependency/static dependency
</code></pre></div></div></details><details><summary><span class="CommitLogs_commit__date___q8bm">2021-10-26 12:59:58</span><span class="CommitLogs_commit__hash__Xyu7v">04af4b49</span><span class="CommitLogs_commit__message__IGUPv">fix</span></summary><div><div class="remark-highlight"><pre data-file="04af4b49.patch" class="language-git  language-diff"><code class="language-git"><span class="token commit-sha1">commit 04af4b49794e94e2e6766510580c29c00a2c257a</span>
Author: koka &#x26;<a href="mailto:lt;koka.code@gmail.com" class="token email-link">lt;koka.code@gmail.com</a>&#x26;gt;
Date:   Tue Oct 26 12:59:58 2021 +0900

  fix

diff --git a/_posts/2021-10-20-testable-architecture-flutter.md b/_posts/2021-10-20-testable-architecture-flutter.md
index 90ba4f9..81bc4d0 100644
<span class="token deleted">--- a/_posts/2021-10-20-testable-architecture-flutter.md</span>
<span class="token inserted">+++ b/_posts/2021-10-20-testable-architecture-flutter.md</span>
@@ -326,7 +326,7 @@ ViewModelがViewを参照しない・してはならないことからもわか
\```dart[data-file=<span class="token string">"view_model.dart"</span>]
final fooViewModelProvider = StateNotifierProvider.autoDispose&#x26;lt;FooViewModel, FooState&#x26;gt;(
 (ref) =&#x26;gt; WaitingListViewModel(
<span class="token deleted">-    insuranceRepository: ref.read(insuranceRepositoryProvider),</span>
<span class="token inserted">+    fooRepository: ref.read(fooRepositoryProvider),</span>
 ),
);
\```
</code></pre></div></div></details><details><summary><span class="CommitLogs_commit__date___q8bm">2021-10-25 23:27:04</span><span class="CommitLogs_commit__hash__Xyu7v">c6cee325</span><span class="CommitLogs_commit__message__IGUPv">fix publish date</span></summary><div><div class="remark-highlight"><pre data-file="c6cee325.patch" class="language-git  language-diff"><code class="language-git"><span class="token commit-sha1">commit c6cee325763ea715072dc0671967db3042ca63c2</span>
Author: koka &#x26;<a href="mailto:lt;koka.code@gmail.com" class="token email-link">lt;koka.code@gmail.com</a>&#x26;gt;
Date:   Mon Oct 25 23:27:04 2021 +0900

  fix publish date

diff --git a/_posts/2021-10-20-testable-architecture-flutter.md b/_posts/2021-10-20-testable-architecture-flutter.md
index 0fd6cde..90ba4f9 100644
<span class="token deleted">--- a/_posts/2021-10-20-testable-architecture-flutter.md</span>
<span class="token inserted">+++ b/_posts/2021-10-20-testable-architecture-flutter.md</span>
<span class="token coord">@@ -1,6 +1,6 @@</span>
<span class="token deleted">---</span>
title: テスト容易性を考慮したFlutterのアーキテクチャ考察
<span class="token deleted">-date: 2021-10-20</span>
<span class="token inserted">+date: 2021-10-25</span>
categories:
<span class="token deleted">- Programming</span>
tags:
</code></pre></div></div></details><details><summary><span class="CommitLogs_commit__date___q8bm">2021-10-25 23:22:57</span><span class="CommitLogs_commit__hash__Xyu7v">77ea8468</span><span class="CommitLogs_commit__message__IGUPv">publish: テスト容易性を考慮したFlutterのアーキテクチャ考察</span></summary><div><div class="remark-highlight"><pre data-file="77ea8468.patch" class="language-git  language-diff"><code class="language-git"><span class="token commit-sha1">commit 77ea846835d033ba818e33830a7a6e2be156553e</span>
Author: koka &#x26;<a href="mailto:lt;koka.code@gmail.com" class="token email-link">lt;koka.code@gmail.com</a>&#x26;gt;
Date:   Mon Oct 25 23:22:57 2021 +0900

  publish: テスト容易性を考慮したFlutterのアーキテクチャ考察

diff --git a/_posts/2021-10-20-testable-architecture-flutter.md b/_posts/2021-10-20-testable-architecture-flutter.md
new file mode 100644
index 0000000..0fd6cde
<span class="token deleted">--- /dev/null</span>
<span class="token inserted">+++ b/_posts/2021-10-20-testable-architecture-flutter.md</span>
<span class="token coord">@@ -0,0 +1,524 @@</span>
<span class="token inserted">+---</span>
<span class="token inserted">+title: テスト容易性を考慮したFlutterのアーキテクチャ考察</span>
<span class="token inserted">+date: 2021-10-20</span>
<span class="token inserted">+categories:</span>
<span class="token inserted">+- Programming</span>
<span class="token inserted">+tags:</span>
<span class="token inserted">+- Flutter</span>
<span class="token inserted">+description: MVVM architecture with Repository pattern, state_notifier and riverpod</span>
<span class="token inserted">+---</span>
<span class="token inserted">+</span>
<span class="token inserted">+ここ半年ほどFlutterを書いていて，アプリケーションのアーキテクチャで試行錯誤してます．状態管理ムズくない？  </span>
<span class="token inserted">+なのでいっそ表に出して意見もらえたらな，と思ったので書きます．</span>
<span class="token inserted">+</span>
<span class="token inserted">+本記事では，Flutterアプリケーションにおいてテスト容易性を向上するためにはどうすればいいか，サンプルアプリケーションを例題にアーキテクチャレベルで検討します．</span>
<span class="token inserted">+</span>
<span class="token inserted">+## アーキテクチャの目的</span>
<span class="token inserted">+今回は**テスト容易性**を主軸に置いたアーキテクチャ選定を行いました．</span>
<span class="token inserted">+特にFlutterの単体テストはネットワークリクエストが遮断されるので，副作用を伴う処理を行うレイヤを適切に分離し，テストが容易になるよう設計を行うこととしました．</span>
<span class="token inserted">+</span>
<span class="token inserted">+アーキテクチャは何かしら課題を解決するために設計されるもの(だと思っている)なので，今回示す例が必ずしもベストなものとは限らないです．</span>
<span class="token inserted">+</span>
<span class="token inserted">+### テスト容易性とは</span>
<span class="token inserted">+</span>
<span class="token inserted">+テスト容易性とは，James Bachが提唱した[Heuristics of Software Testability][testability](テスタビリティ・テスト容易性のモデル)に示される，テストの品質を測る指標です．</span>
<span class="token inserted">+それぞれの説明は[優れたテスト容易性を実現するためのポイント - PrAha ENGINEER LAB][praha_test]に詳しいです．  </span>
<span class="token inserted">+こちらの記事でも示されている通り，テスト容易性の向上にはテスト容易性を低下させる要因を抑えることが必要不可欠です．そしてその要因はコードレベルに留まらずアーキテクチャレベルで抑えることが求められます．</span>
<span class="token inserted">+</span>
<span class="token inserted">+## 全体像</span>
<span class="token inserted">+</span>
<span class="token inserted">+ざっくり以下の機能を持つアプリケーションを例にとります．</span>
<span class="token inserted">+</span>
<span class="token inserted">+- APIサーバからデータ`Foo`のリストを取得してデータを描画する</span>
<span class="token inserted">+- データ`Foo`を作成し，描画されるリストを更新する</span>
<span class="token inserted">+- pull-to-refreshでのデータ再取得機能を持つ</span>
<span class="token inserted">+</span>
<span class="token inserted">+また，今回用いるレイヤは以下のようになります;</span>
<span class="token inserted">+</span>
<span class="token inserted">+- **API Client**: APIサーバからのデータ取得+モデルへのdeserializeを行う</span>
<span class="token inserted">+  - 実装: `GetRequestProtocol` + `ListFooRequest`</span>
<span class="token inserted">+- **Repository**: API Client(+[shared_preferences][shared_preferences])を利用してデータ取得・更新を行う</span>
<span class="token inserted">+  - 実装: `FooRepository` + `fooRepositoryProvider`</span>
<span class="token inserted">+- **Service**: ドメインロジック担当(もしくはTransaction Script)</span>
<span class="token inserted">+  - 実装は省略</span>
<span class="token inserted">+- **ViewModel**: Viewの描画以外の責務全て</span>
<span class="token inserted">+  - 実装: `FooViewModel` + `fooViewModelProvider`</span>
<span class="token inserted">+- **View**: 描画+イベントとViewModelのイベントハンドラの糊付け</span>
<span class="token inserted">+  - 実装は省略</span>
<span class="token inserted">+</span>
<span class="token inserted">+テスト容易性を念頭に置いた際にどのレイヤの分割が必要か判断した結果，基本的なMVVMアーキテクチャとなりました．  </span>
<span class="token inserted">+テスト容易性のためには特にViewをいかに薄く保てるかがキモで，そのためにViewModelはやや責務過多になる傾向にあります．</span>
<span class="token inserted">+したがってViewModelの肥大化を防ぐためにドメインロジックをViewModelからServiceクラスへ委譲し，また描画用のデータ管理とステートレスなドメインロジックを分離してテストできるようにします．  </span>
<span class="token inserted">+ViewModelと共に扱われることの多い，StreamやReactiveな双方向データバインディングは扱いません．</span>
<span class="token inserted">+</span>
<span class="token inserted">+以下では各レイヤ毎に簡易実装及びそのテストコードを示し，そのレイヤにおける責務と設計基準を説明します．  </span>
<span class="token inserted">+実際の設計時はテストコードから書いて書き心地を試しつつの実装を行いましたが，説明の都合で実装-&#x26;gt;テストの順で示します．</span>
<span class="token inserted">+</span>
<span class="token inserted">+また，Widgetについての設計はここでは述べません．</span>
<span class="token inserted">+テスト容易性の観点からViewを薄く保つことを念頭に置いているため，ViewはViewModelまでの設計と異なる目的での設計を取りうるためです．</span>
<span class="token inserted">+</span>
<span class="token inserted">+## API Client</span>
<span class="token inserted">+</span>
<span class="token inserted">+APIクライアントクラスはネットワーク越しのリクエストを行い，アプリ内でのモデルへのdeserializeを行います．</span>
<span class="token inserted">+</span>
<span class="token inserted">+ここではREST APIを仮定したクラス設計を行いますが，gRPCやGraphQLの場合でも実装が異なるだけで責務自体は変わらないと思います．  </span>
<span class="token inserted">+APIレスポンスは対応するモデルクラスにマッピングし，`dynamic`型として存在する期間を極力短く保ちます．</span>
<span class="token inserted">+</span>
<span class="token inserted">+モデルクラスは適当な集約単位で作成し，レスポンスを正規化して持つようにします．</span>
<span class="token inserted">+[json_serializable][json_serializable]と組み合わせて`deserialize`の実装をModelのconstructorとして任せると楽です．</span>
<span class="token inserted">+</span>
<span class="token inserted">+::: info immutable</span>
<span class="token inserted">+Dartで構造体や関数以外への型エイリアスが定義できないのでclassとして定義するしかない．</span>
<span class="token inserted">+ただ内部状態を変更できるクラスメソッドを書けてしまうと変更検知が辛くなってしまう．</span>
<span class="token inserted">+:::</span>
<span class="token inserted">+</span>
<span class="token inserted">+\```dart[class="line-numbers"][data-file="foo.dart"]</span>
<span class="token inserted">+@freezed</span>
<span class="token inserted">+class Foo with _$Foo {</span>
<span class="token inserted">+  factory Foo.fromJson(Map&#x26;lt;String, dynamic&#x26;gt; json) =&#x26;gt; _$FooFromJson(json);</span>
<span class="token inserted">+}</span>
<span class="token inserted">+\```</span>
<span class="token inserted">+</span>
<span class="token inserted">+APIリクエストクラスは，実際のリクエスト処理の隠蔽及びテスト時のDIインターフェース統一のためにプロトコルで縛るようにします．</span>
<span class="token inserted">+プロトコルはmixinとして定義し，リクエスト処理を行う`request`メソッドのみmixin側に実装します．  </span>
<span class="token inserted">+ここでは簡単のため`url`以外の定義を省略していますが，クエリパラメータやヘッダなど，想定されるユースケースに応じた設定が行えるようにインターフェースを設計します．</span>
<span class="token inserted">+</span>
<span class="token inserted">+今回はGETリクエストを想定した`GetRequestProtocol`を定義し，またそのユースケースとして`ListFooRequest`を実装します．  </span>
<span class="token inserted">+また，`HttpClient`はHTTPリクエストを担う[http][http]や[dio][dio]，またはいずれかをwrapしたクラスです．</span>
<span class="token inserted">+</span>
<span class="token inserted">+\```dart[class="line-numbers"][data-file="api_protocol.dart"]</span>
<span class="token inserted">+// `package:meta` に [@mustOverride] annotation が入ったら嬉しい</span>
<span class="token inserted">+// @see: https://github.com/dart-lang/sdk/issues/30175</span>
<span class="token inserted">+mixin GetRequestProtocol&#x26;lt;M&#x26;gt; {</span>
<span class="token inserted">+  @protected</span>
<span class="token inserted">+  String get url =&#x26;gt; throw UnimplementedError();</span>
<span class="token inserted">+</span>
<span class="token inserted">+  Future&#x26;lt;M&#x26;gt; request(HttpClient client) async {</span>
<span class="token inserted">+    final json = await client.get(/* api request */);</span>
<span class="token inserted">+    return _deserialize(json);</span>
<span class="token inserted">+  }</span>
<span class="token inserted">+</span>
<span class="token inserted">+  @protected</span>
<span class="token inserted">+  M _deserialize(Response json) {}</span>
<span class="token inserted">+}</span>
<span class="token inserted">+\```</span>
<span class="token inserted">+</span>
<span class="token inserted">+ユースケース側は`GetRequestProtocol`を取り込んだRequestクラスを定義し，`request`メソッドが返すレスポンスをモデルへ変換する`deserialize`メソッドを実装します．</span>
<span class="token inserted">+</span>
<span class="token inserted">+ここでは簡単のため`url`を固定値としていますが，実際には[flutter_dotenv][dotenv]を用いて環境変数としてAPIエンドポイントの管理を行います．</span>
<span class="token inserted">+これは設定と実装の分離の観点からももちろん好ましいのですが，読み込む`.env`ファイルをテスト時に差し替えられる利点が大きいです．詳細は後述します．</span>
<span class="token inserted">+</span>
<span class="token inserted">+\```dart[class="line-numbers"][data-file="list_foo_request.dart"]</span>
<span class="token inserted">+class ListFooRequest with GetRequestProtocol&#x26;lt;List&#x26;lt;Foo&#x26;gt;&#x26;gt; {</span>
<span class="token inserted">+  @override</span>
<span class="token inserted">+  String get url =&#x26;gt; 'https://example.com/foos';</span>
<span class="token inserted">+</span>
<span class="token inserted">+  @override</span>
<span class="token inserted">+  List&#x26;lt;Foo&#x26;gt; _deserialize(Response json) {</span>
<span class="token inserted">+    // レスポンスのJSONが`foos`をキーとして[Foo]の配列を持つと仮定</span>
<span class="token inserted">+    // constructor の tear-off が入ると `.map(Foo.fromJson)`のようにかける</span>
<span class="token inserted">+    // @see: https://twitter.com/remi_rousselet/status/1438207417154686980?s=20</span>
<span class="token inserted">+    return (json['foos'] as List)</span>
<span class="token inserted">+      .map((f) =&#x26;gt; Foo.fromJson(f as Map&#x26;lt;String, dynamic&#x26;gt;))</span>
<span class="token inserted">+      .toList();</span>
<span class="token inserted">+  }</span>
<span class="token inserted">+}</span>
<span class="token inserted">+\```</span>
<span class="token inserted">+</span>
<span class="token inserted">+### test</span>
<span class="token inserted">+</span>
<span class="token inserted">+APIクライアントクラスはネットワークリクエストを行い，レスポンスをモデルに変換するところまでを責務としました．  </span>
<span class="token inserted">+Flutterのテストライブラリ[flutter_test][flutter_test]ではネットワークリクエストが遮断されるため，APIクライアントクラスに対するテストは`request`メソッドの返り値が対応するモデルインスタンスであるかどうかを評価することになります．  </span>
<span class="token inserted">+モックのアプローチとしては以下の2パターンが考えられます;</span>
<span class="token inserted">+</span>
<span class="token inserted">+- A. [mockito][mockito]を用いて`HttpClient`のモックオブジェクトを生成し，対応するレスポンスをスタブする</span>
<span class="token inserted">+- B. [mock_http_server][mock_http_server]を用いてテスト用APIサーバを構築し，閉じたネットワークでのテストを行う</span>
<span class="token inserted">+</span>
<span class="token inserted">+mockitoを用いる場合，今回の例題では`HttpClient`クラスの`get`メソッドをスタブすれば良さそうですが，HTTPリクエストを担うレイヤはinterceptorなどの機構を用いてロガーやエラーハンドラなどを注入するケースが多々あります．  </span>
<span class="token inserted">+そのためテスト時に生成される`HttpClient`のモックオブジェクトと実際のリクエスト時に渡される`HttpClient`のインスタンスはスタブされている箇所以外にも設定が異なってしまうことが懸念されます．</span>
<span class="token inserted">+したがって`HttpClient`の挙動がランタイムと乖離しないように，ネットワークリクエスト先をすげ替えるBの方針を取ることにします．</span>
<span class="token inserted">+</span>
<span class="token inserted">+\```dart[class="line-numbers"][data-file="list_foo_request_test.dart"]</span>
<span class="token inserted">+void main() {</span>
<span class="token inserted">+  final server = MockWebServer(port: 8081);</span>
<span class="token inserted">+</span>
<span class="token inserted">+  setUp(() async {</span>
<span class="token inserted">+    // APIエンドポイントを[MockWebServer]にすげ替えるためにテスト用の.envファイルを読み込む．</span>
<span class="token inserted">+    // HttpClientがbaseUrlを保持するパターンもあるが，全てのAPIが単一のbaseUrlからされない場合もあるので</span>
<span class="token inserted">+    // このようにしておく．</span>
<span class="token inserted">+    await dotenv.load(fileName: '.env.test');</span>
<span class="token inserted">+    server.start();</span>
<span class="token inserted">+  });</span>
<span class="token inserted">+</span>
<span class="token inserted">+  tearDown(server.shutdown);</span>
<span class="token inserted">+</span>
<span class="token inserted">+  // エラー時のテストケースについては，エラーハンドラを`request`メソッドの実装に持たせたり</span>
<span class="token inserted">+  // interceptorで挟んだりするためHttpClientやmixinのテストで記述する．</span>
<span class="token inserted">+  // したがって個々のRequestクラスのテストケースはシンプルに保つことができる．</span>
<span class="token inserted">+  test('ListFooRequest returns list of Foo', () async {</span>
<span class="token inserted">+    // ここではJSONの構築に[dart:convert#jsonEncode]を用いた．</span>
<span class="token inserted">+    // `json_serializable` が生成する`toJson`メソッドで適当なレスポンスを組み立ててもよい．</span>
<span class="token inserted">+    final body = { 'foos': [/* Foo モデル */] };</span>
<span class="token inserted">+    server.enqueue(httpCode: 200, body: jsonEncode(body));</span>
<span class="token inserted">+    final response = await ListFooRequest().request(httpClient);</span>
<span class="token inserted">+</span>
<span class="token inserted">+    expect(response, isA&#x26;lt;List&#x26;lt;Foo&#x26;gt;&#x26;gt;);</span>
<span class="token inserted">+  });</span>
<span class="token inserted">+}</span>
<span class="token inserted">+\```</span>
<span class="token inserted">+</span>
<span class="token inserted">+## Repository</span>
<span class="token inserted">+</span>
<span class="token inserted">+Repositoryクラスはデータ取得及びデータの更新操作を行います．  </span>
<span class="token inserted">+ここではAPIからのリモートデータリソースのみを扱っていますが，[shared_preferences][shared_preferences]やKeychain/KeyStoreを利用したローカルデータソースに対する操作も責務に含まれます．  </span>
<span class="token inserted">+</span>
<span class="token inserted">+RepositoryクラスはViewModelレイヤから利用されるのですが，Repositoryクラスはネットワークアクセスが行われるためViewModelクラスの内部でRepositoryクラスを初期化してしまうとViewModelのテストが困難になります．  </span>
<span class="token inserted">+かといってViewModelクラスのコンストラクタにRepositoryクラスを引数として渡す場合，そのViewModelクラスを利用するViewでRepositoryクラスを作成してViewModelを得る必要が出てしまい，レイヤ跨ぎ(View -&#x26;gt; Repository)が発生してしまいます．</span>
<span class="token inserted">+</span>
<span class="token inserted">+これを解消するためにDI(Dependency Injection)を用いて各レイヤ間の結合をDIプロバイダに委任します．</span>
<span class="token inserted">+</span>
<span class="token inserted">+Repositoryインスタンスには[riverpod][riverpod]の提供する`Provider`を介してアクセスするようにします．</span>
<span class="token inserted">+そのために`FooRepository`にはパブリックなコンストラクタを実装せずプライベートコンストラクタ`._()`のみを定義し，外部ファイルから`FooRepository`インスタンスを直接立ち上げることを禁止します．  </span>
<span class="token inserted">+</span>
<span class="token inserted">+\```dart[data-file="foo_repository.dart"]</span>
<span class="token inserted">+final fooRepositoryProvider = Provider&#x26;lt;FooRepository&#x26;gt;(</span>
<span class="token inserted">+  (ref) =&#x26;gt; FooRepository._(ref.read(httpClientProvider)),</span>
<span class="token inserted">+);</span>
<span class="token inserted">+\```</span>
<span class="token inserted">+</span>
<span class="token inserted">+また，(一般的なアーキテクチャにおける)Repositoryクラスは永続化層と表現されることもあり，その文脈ではキャッシュ機構を持つことがあります．  </span>
<span class="token inserted">+仮に`FooRepository`がキャッシュ機構を持つとした場合，そのテストがどのように記述されるべきかを見ていきます．</span>
<span class="token inserted">+</span>
<span class="token inserted">+`FooRepository`がキャッシュ機構を持つ場合，リモートデータソースとキャッシュとの整合性の不一致が生じえます．</span>
<span class="token inserted">+例えば`create`を呼んだ後に`list`を実行すると，`create`したデータが含まれないキャッシュが返されるなどが考えられます．  </span>
<span class="token inserted">+データの整合性を担保するにはいくつか方法がありますが，ここではシンプルにキャッシュの破棄操作を行う実装を行うとしましょう．</span>
<span class="token inserted">+</span>
<span class="token inserted">+\```dart[data-file="foo_repository.dart"]</span>
<span class="token inserted">+class FooRepository {</span>
<span class="token inserted">+  FooRepository._(this._httpClient);</span>
<span class="token inserted">+</span>
<span class="token inserted">+  final HttpClient _httpClient;</span>
<span class="token inserted">+  List&#x26;lt;Foo&#x26;gt;? _cache;</span>
<span class="token inserted">+</span>
<span class="token inserted">+  Future&#x26;lt;List&#x26;lt;Foo&#x26;gt;&#x26;gt; list() async {</span>
<span class="token inserted">+    if (_cache != null) return _cache;</span>
<span class="token inserted">+</span>
<span class="token inserted">+    _cache = ListFooRequest().request(_httpClient);</span>
<span class="token inserted">+    return _cache;</span>
<span class="token inserted">+  }</span>
<span class="token inserted">+</span>
<span class="token inserted">+  // Requestクラスの説明では省略した[CreateFooRequest]を用いて</span>
<span class="token inserted">+  // [Foo]レコードを作成するリクエストを行う．</span>
<span class="token inserted">+  // [CreateFoo]クラスは[Foo]レコードを作成する際のDTO.</span>
<span class="token inserted">+  Future&#x26;lt;Foo&#x26;gt; create(CreateFoo createFoo) async {</span>
<span class="token inserted">+    _cache = null;</span>
<span class="token inserted">+    await CreateFooRequest(createFoo).request(_httpClient);</span>
<span class="token inserted">+  }</span>
<span class="token inserted">+}</span>
<span class="token inserted">+\```</span>
<span class="token inserted">+</span>
<span class="token inserted">+### test</span>
<span class="token inserted">+</span>
<span class="token inserted">+Repositoryクラスはデータ取得・更新操作を行い，データの整合性を担保します．</span>
<span class="token inserted">+Repositoryクラスのユースケースにおいては，その内部にキャッシュ機構があるかどうか，またはインメモリデータベースを利用しているかどうかは隠蔽されているべきです．</span>
<span class="token inserted">+したがって実装の詳細には触れず，その振る舞いのみを保証するにはテストデータ更新後に最新のデータを返すかどうかを確認すれば良さそうです．  </span>
<span class="token inserted">+</span>
<span class="token inserted">+次にテスト容易性を主軸にRepositoryクラスをどのように提供するか考察します．  </span>
<span class="token inserted">+Repositoryクラスはその責務上複数のAPIクライアントクラスを操作するため，テストのタイミングではAPIクライアントクラスもしくはその処理のモックが必要となります．</span>
<span class="token inserted">+Repositoryクラスにおいてもどのレイヤーをモックするかが設計のポイントとなるのですが，Repositoryクラスのコンストラクタに渡される`HttpClient`をモックする方針をとります．  </span>
<span class="token inserted">+判断に至った思考仮定は次のようなものです;</span>
<span class="token inserted">+</span>
<span class="token inserted">+**A. APIクライアントのテストのようにAPIサーバをモックする場合**  </span>
<span class="token inserted">+この場合Repositoryクラスが扱う各APIクライアントクラスに対するモックAPIサーバの設定を記述する必要があります．</span>
<span class="token inserted">+この設定にはエンドポイントのURLやレスポンスのJSONスキーマ定義など，APIクライアントクラスの責務となる詳細部分が必要なので，</span>
<span class="token inserted">+APIクライアントの実装を変更することでRepositoryクラスのテストがfailする可能性があり，修正に脆いテストとなり得ます．</span>
<span class="token inserted">+</span>
<span class="token inserted">+**B. 個々のAPIクライアントクラスをモックする場合**  </span>
<span class="token inserted">+先に示した`FooRepository`クラスの実装ではAPIクライアントクラスをハードコードして利用しています．  </span>
<span class="token inserted">+APIクライアントクラスをモックする場合には各APIクライアントクラスをDIするかコンストラクタの引数として受け取るような実装をする必要が生じます．  </span>
<span class="token inserted">+(callerの直接の)コンストラクタでの引数渡しについては先に述べたとおり抽象化レイヤを跨いでしまうため避けたいです．  </span>
<span class="token inserted">+またAPIクライアントクラスはRepositoryクラスにとってStatic Dependency[^1]であり，また各APIクライアントクラスをDIすることはOver-Injection[^2]に繋がるのでこれもベストとは言い難いです．</span>
<span class="token inserted">+</span>
<span class="token inserted">+**C. HttpClientをモックする場合**  </span>
<span class="token inserted">+Aではネットワーク先，BではAPIクライアントの振る舞いをそれぞれスタブする方針でした．  </span>
<span class="token inserted">+APIクライアントクラスが利用する`HttpClient`をモックすることで，APIクライアントのネットワークリクエスト処理のみをスタブすることができます．  </span>
<span class="token inserted">+APIクライアントクラスが`HttpClient`を利用する処理はmixinとして実装を与えてあるため，個々のAPIクライアントクラスの振る舞いには左右されず修正に強いテストが期待できます．</span>
<span class="token inserted">+またBと比較してもDIする対象が1つで済むため適切であると言えます．</span>
<span class="token inserted">+</span>
<span class="token inserted">+::: warn FooRepositoryのコンストラクタについて</span>
<span class="token inserted">+FooRepository内部で直接ProviderをService Locatorとして利用することを避けるために，HttpClientをコンストラクタの引数として渡すような設計になっています．</span>
<span class="token inserted">+:::</span>
<span class="token inserted">+</span>
<span class="token inserted">+テストコードで`HttpClient`をProviderから受け取るには`ProviderContainer`を利用します．  </span>
<span class="token inserted">+`ProviderContainer`の引数にDIプロバイダのオーバーライド設定を指定することで，テスト内では`mockHttpClient`を利用するRepositoryクラスを利用することができます．</span>
<span class="token inserted">+</span>
<span class="token inserted">+\```dart[data-file="foo_repository_test.dart"]</span>
<span class="token inserted">+void main() {</span>
<span class="token inserted">+  final container = ProviderContainer(</span>
<span class="token inserted">+    overrides: [httpClientProvider.overrideWithValue(mockHttpClient)],</span>
<span class="token inserted">+  );</span>
<span class="token inserted">+  final repository = container.read(fooRepositoryProvider);</span>
<span class="token inserted">+}</span>
<span class="token inserted">+\```</span>
<span class="token inserted">+</span>
<span class="token inserted">+データ整合性のテストはユースケースを元に，`create`メソッド実行後に`list`メソッドの実行結果が`create`したデータを含むかどうかを確認します．</span>
<span class="token inserted">+</span>
<span class="token inserted">+&#x26;lt;small&#x26;gt;もちろん`list`メソッド単体のテストは書く前提です.&#x26;lt;/small&#x26;gt;</span>
<span class="token inserted">+</span>
<span class="token inserted">+\```dart[data-file="foo_repository_test.dart"]</span>
<span class="token inserted">+void main() {</span>
<span class="token inserted">+  // omitted</span>
<span class="token inserted">+</span>
<span class="token inserted">+  // HttpClientの挙動をスタブ</span>
<span class="token inserted">+  when(mockHttpClient.get(any)).thenAnswer((_) async =&#x26;gt; listFooResponse);</span>
<span class="token inserted">+  var response = await repository.list();</span>
<span class="token inserted">+  // verify(mockHttpClient.get(any)) として</span>
<span class="token inserted">+  // **内部でmockHttpClientが呼ばれた**ことをテストすることも可能だが，</span>
<span class="token inserted">+  // ここではRepositoryクラスの振る舞いを見ることを主軸に置くためテストに含めない．</span>
<span class="token inserted">+  // 実際のユースケースではRepositoryクラスはProvider経由で利用され，</span>
<span class="token inserted">+  // HttpClientはProvider内部で渡されるため利用する側からはHttpClientはされている.</span>
<span class="token inserted">+  // あくまでテストにおいてのみRepositoryクラスがHttpClientを利用していることを知る必要が生じている．</span>
<span class="token inserted">+  //</span>
<span class="token inserted">+  // ListFooRequestの結果が返される</span>
<span class="token inserted">+  expect(response, listFooResponse);</span>
<span class="token inserted">+</span>
<span class="token inserted">+  // create時の挙動をスタブ</span>
<span class="token inserted">+  when(mockHttpClient.post(any)).thenAnswer((_) async =&#x26;gt; createResponse);</span>
<span class="token inserted">+  final createFoo = CreateFoo(/* */);</span>
<span class="token inserted">+  response = await repository.create(createFoo);</span>
<span class="token inserted">+  expect(response, createResponse);</span>
<span class="token inserted">+</span>
<span class="token inserted">+  // 再度Listした際に更新されたResponseが返される</span>
<span class="token inserted">+  when(mockHttpClient.get(any)).thenAnswer((_) async =&#x26;gt; updatedListResponse);</span>
<span class="token inserted">+  response = await repository.list();</span>
<span class="token inserted">+  expect(response, updatedListResponse);</span>
<span class="token inserted">+}</span>
<span class="token inserted">+\```</span>
<span class="token inserted">+</span>
<span class="token inserted">+## ViewModel</span>
<span class="token inserted">+</span>
<span class="token inserted">+ViewModelはViewが利用するデータ及びロジックを提供します．  </span>
<span class="token inserted">+ここが一番責務をどこにおくか悩むところだと思うので，ViewModelの定義について John Gossman. (2005)[^3]を紹介します．</span>
<span class="token inserted">+</span>
<span class="token inserted">+&#x26;gt; The UI may want to perform complex operations that must be implemented in code which doesn't make sense in our strict definition of the View but are too specific to be included in the Model (or didn't come with the pre-existing model).</span>
<span class="token inserted">+&#x26;gt; Finally we need a place to put view state such as selection or modes.</span>
<span class="token inserted">+&#x26;gt;</span>
<span class="token inserted">+&#x26;gt; The ViewModel is responsible for these tasks.</span>
<span class="token inserted">+&#x26;gt; The term means "Model of a View", and can be thought of as abstraction of the view,</span>
<span class="token inserted">+&#x26;gt; but it also provides a specialization of the Model that the View can use for data-binding.</span>
<span class="token inserted">+&#x26;gt; In this latter role the ViewModel contains data-transformers that convert Model types into View types, and it contains Commands the View can use to interact with the Model.</span>
<span class="token inserted">+</span>
<span class="token inserted">+ここで示したいのはViewModelはViewとのデータバインディングだけではなく，Viewが行う複雑な操作(=ドメインロジック)をも責務に含むという点です．</span>
<span class="token inserted">+これは逆にViewにそのような処理をもたせてはいけないというだけなので，ViewModelまたはServiceレイヤに持たせるようにします．  </span>
<span class="token inserted">+ViewModelからはViewでの操作のハンドラを提供し，ViewからServiceクラスを直接呼ぶことのないようにします．  </span>
<span class="token inserted">+例外的にpull-to-refreshのように描画・アニメーションがメインとなるロジックや，`BuildContext`を介する処理(例: `Navigator.push`等)についてはView側の責務となります．</span>
<span class="token inserted">+</span>
<span class="token inserted">+また，テスト容易性の観点からはMartin Fowler氏のHumble Object[^4]をイメージするとViewとViewModelとのそれぞれの責務の切り分けがしやすいかと思います．</span>
<span class="token inserted">+</span>
<span class="token inserted">+Viewのテストを考慮すると，View内部でViewModelをイニシャライズするとViewModelのモックがやや手間になります．  </span>
<span class="token inserted">+したがってViewModelにおいてもProviderを利用して提供します．</span>
<span class="token inserted">+</span>
<span class="token inserted">+ここで，ViewModelのライフサイクルをどうするか検討しましょう．  </span>
<span class="token inserted">+ViewModelがViewを参照しない・してはならないことからもわかるように，ViewModelとViewとのライフサイクルは異なります．</span>
<span class="token inserted">+しかしViewインスタンスが破棄された後にViewModelが生き続けると，再度Viewが生成された際にその(中途半端な状態を持つ)ViewModelが参照されると困るケースもあります．</span>
<span class="token inserted">+そういったケースでは`StateNotifierProvider.autoDispose`を用いてViewModelのライフサイクルをViewに揃え，Viewが生成されるタイミングでViewModelを生成してデータの整合性を担保するようにします．</span>
<span class="token inserted">+</span>
<span class="token inserted">+\```dart[data-file="view_model.dart"]</span>
<span class="token inserted">+final fooViewModelProvider = StateNotifierProvider.autoDispose&#x26;lt;FooViewModel, FooState&#x26;gt;(</span>
<span class="token inserted">+  (ref) =&#x26;gt; WaitingListViewModel(</span>
<span class="token inserted">+    insuranceRepository: ref.read(insuranceRepositoryProvider),</span>
<span class="token inserted">+  ),</span>
<span class="token inserted">+);</span>
<span class="token inserted">+\```</span>
<span class="token inserted">+</span>
<span class="token inserted">+ViewModelが持つ状態はたとえ変数が1つであってもクラスとして切り出し，内包する状態が増えた際に変更に対して閉じるようにします．  </span>
<span class="token inserted">+</span>
<span class="token inserted">+\```dart[data-file="view_model.dart"]</span>
<span class="token inserted">+@freezed</span>
<span class="token inserted">+class FooState with _$FooState {</span>
<span class="token inserted">+  const factory FooState._({</span>
<span class="token inserted">+    required AsyncValue&#x26;lt;List&#x26;lt;Foo&#x26;gt;&#x26;gt; foos,</span>
<span class="token inserted">+  }) = _FooState;</span>
<span class="token inserted">+}</span>
<span class="token inserted">+\```</span>
<span class="token inserted">+</span>
<span class="token inserted">+今回はViewがpull-to-refresh機能を提供するとして設計します．</span>
<span class="token inserted">+その場合，Viewで必要となるロジックは以下のようなデータ及びイベントハンドラが考えられます；</span>
<span class="token inserted">+</span>
<span class="token inserted">+- Viewで描画するデータ(`List&#x26;lt;Foo&#x26;gt;`)</span>
<span class="token inserted">+- View作成時のViewModelの初期化処理(`onInit`)</span>
<span class="token inserted">+- pull-to-refresh実行時のリフレッシュ処理(`onRefresh`)</span>
<span class="token inserted">+- `Foo`の追加処理(`createFoo(CreateFoo foo)`)</span>
<span class="token inserted">+</span>
<span class="token inserted">+また描画するデータ`List&#x26;lt;Foo&#x26;gt;`はAPIから取得するため，初期状態はデータを保持しておらずローディング中・ローディング失敗の状態も考えられます．</span>
<span class="token inserted">+そういったケースに対応するため`Future`の値の変化を検知・通知できる[`AsyncValue`][async_value]を利用します．</span>
<span class="token inserted">+</span>
<span class="token inserted">+それぞれを実装におとすと次のようになります．</span>
<span class="token inserted">+</span>
<span class="token inserted">+\```dart[data-file="view_model.dart"]</span>
<span class="token inserted">+class FooViewModel extends StateNotifier&#x26;lt;FooState&#x26;gt; {</span>
<span class="token inserted">+  FooViewModel({required FooRepository fooRepository})</span>
<span class="token inserted">+      : _repository = fooRepository,</span>
<span class="token inserted">+        super(const FooState._(foos: AsyncValue.loading())) {</span>
<span class="token inserted">+    // construct時に初期化処理`onInit`を実行</span>
<span class="token inserted">+    onInit();</span>
<span class="token inserted">+  }</span>
<span class="token inserted">+</span>
<span class="token inserted">+  final FooRepository _repository;</span>
<span class="token inserted">+</span>
<span class="token inserted">+  Future&#x26;lt;void&#x26;gt; onInit() async {</span>
<span class="token inserted">+    // 今回の例では簡単のため`onRefresh`を呼ぶだけ</span>
<span class="token inserted">+    await onRefresh();</span>
<span class="token inserted">+  }</span>
<span class="token inserted">+</span>
<span class="token inserted">+  Future&#x26;lt;void&#x26;gt; createFoo(CreateFoo foo) async {</span>
<span class="token inserted">+    await _repository.create(foo).then((res) {</span>
<span class="token inserted">+      await onRefresh();</span>
<span class="token inserted">+    }).catchError((e) {</span>
<span class="token inserted">+      // TODO</span>
<span class="token inserted">+    });</span>
<span class="token inserted">+  }</span>
<span class="token inserted">+</span>
<span class="token inserted">+  Future&#x26;lt;void&#x26;gt; onRefresh() async {</span>
<span class="token inserted">+    await _repository.list().then((res) {</span>
<span class="token inserted">+      state = state.copyWith(foos: AsyncValue.data(res));</span>
<span class="token inserted">+    }).catchError((e) {</span>
<span class="token inserted">+      state = state.copyWith(foos: AsyncValue.error(e as Object));</span>
<span class="token inserted">+    });</span>
<span class="token inserted">+  }</span>
<span class="token inserted">+}</span>
<span class="token inserted">+\```</span>
<span class="token inserted">+</span>
<span class="token inserted">+### test</span>
<span class="token inserted">+</span>
<span class="token inserted">+ViewModelはViewが利用するデータ及びロジックの提供を責務とします．  </span>
<span class="token inserted">+ViewModelのテストですが，単体でのテストを行うかViewと組み合わせたテストを行うか正直自分の中で答えを出せていません．</span>
<span class="token inserted">+Viewの持つロジックを極力薄くすることで，擬似的にViewの取りうる振る舞いをViewModelでテストすることは可能です．ただViewModelの取りうる状態に応じた描画はViewでのテストでしか担保することができず，かつそれらは無視できる量・質のものとは言い難いです．  </span>
<span class="token inserted">+そのためViewはViewのテストが必要となりますが，ViewModelが示す状態に沿う描画ができているかを検査すればよいので，ある程度宣言的にテストを記述できます．  </span>
<span class="token inserted">+</span>
<span class="token inserted">+実際，実機での[integration_test][integration_test]や回帰テストを行う[golden toolkit][golden_test]などViewを対象としたテストツールも充実してきておりそれらを用いることで描画内容にとどまらないデザインのテストをも行うことが可能となってきています．  </span>
<span class="token inserted">+</span>
<span class="token inserted">+ただ，そこに実際のViewModelを持ち込むかモックしたViewModelを持ち込むかは明確な判断理由を持てていません．  </span>
<span class="token inserted">+ここではテスト容易性を主軸においたアーキテクチャの紹介を行い，いわゆるUIテストについては上記の説明に留めることとします．</span>
<span class="token inserted">+</span>
<span class="token inserted">+---</span>
<span class="token inserted">+</span>
<span class="token inserted">+先程実装した`FooRepository`はProvider経由のみのアクセスとするためにパブリックなコンストラクタを公開していませんでした．</span>
<span class="token inserted">+直接インスタンスを生成できないというのも理由のひとつですが，`FooRepository`は内部でネットワークリクエストを行うためどのみちそのまま扱うことができません．  </span>
<span class="token inserted">+そのため`FooRepository`のモックオブジェクトを生成し，`fooRepositoryProvider`に注入して`FooViewModel`から`MockFooRepository`が参照されるように設定します．</span>
<span class="token inserted">+</span>
<span class="token inserted">+今回利用するモックライブラリ[mockito][mockito]が生成するモックは，次のように対象のクラスを`implements`する形で実装されます．  </span>
<span class="token inserted">+パブリックなコンストラクタを自動で生成してくれるので，`MockFooRepository`インスタンスを用いて`fooRepositoryProvider`を上書きできます．</span>
<span class="token inserted">+</span>
<span class="token inserted">+\```dart[class="line-numbers"][data-file="foo_repository.mocks.dart"]</span>
<span class="token inserted">+class MockFooRepository extends _i1.Mock implements _i2.FooRepository {</span>
<span class="token inserted">+  MockFooRepository() {</span>
<span class="token inserted">+    _i1.throwOnMissingStub(this);</span>
<span class="token inserted">+  }</span>
<span class="token inserted">+</span>
<span class="token inserted">+  @override</span>
<span class="token inserted">+  _i3.Future&#x26;lt;List&#x26;lt;Foo&#x26;gt;&#x26;gt; list() =&#x26;gt; (/* omitted */);</span>
<span class="token inserted">+}</span>
<span class="token inserted">+\```</span>
<span class="token inserted">+</span>
<span class="token inserted">+今回はViewModelとViewを共に扱いテストを行います．</span>
<span class="token inserted">+ここでは`FooViewModel`を利用するViewを`FooView`とします．</span>
<span class="token inserted">+</span>
<span class="token inserted">+\```dart[class="line-numbers"][data-file="foo_view_model_test.dart"]</span>
<span class="token inserted">+void main() {</span>
<span class="token inserted">+  final repository = MockFooRepository();</span>
<span class="token inserted">+  final container = ProviderContainer(</span>
<span class="token inserted">+    overrides: [fooRepositoryProvider.overrideWithValue(repository)],</span>
<span class="token inserted">+  );</span>
<span class="token inserted">+</span>
<span class="token inserted">+  // repositoryのmock等を行う</span>
<span class="token inserted">+</span>
<span class="token inserted">+  testWidgets('FooViewModel smoke test with view', (WidgetTester tester) async {</span>
<span class="token inserted">+    final widget = ProviderScope(</span>
<span class="token inserted">+      overrides: [fooRepositoryProvider.overrideWithValue(repository)],</span>
<span class="token inserted">+      child: const MaterialApp(home: FooView()),</span>
<span class="token inserted">+    );</span>
<span class="token inserted">+</span>
<span class="token inserted">+    await tester.runAsync(() async {</span>
<span class="token inserted">+      await tester.pumpWidget();</span>
<span class="token inserted">+      // 初期状態の確認.</span>
<span class="token inserted">+      // APIリクエストが完了していないのでデータローディングの旨を表示したい</span>
<span class="token inserted">+      expect(find.text('データ読み込み中'), findsOneWidget);</span>
<span class="token inserted">+      // 描画更新を更新.</span>
<span class="token inserted">+      // APIリクエストが完了している(ようレスポンスをスタブする)ので</span>
<span class="token inserted">+      // ローディングが完了しデータが描画されていることを確認</span>
<span class="token inserted">+      // (レスポンスはListViewで描画しているとする)</span>
<span class="token inserted">+      expect(find.text('データ読み込み中'), findsNothing);</span>
<span class="token inserted">+      expect(find.byType(ListView), findsOneWidget);</span>
<span class="token inserted">+</span>
<span class="token inserted">+      // pull to refresh 実行</span>
<span class="token inserted">+      // pull to refreshをテスト上でimitateする処理は以下を参照</span>
<span class="token inserted">+      // @see: https://github.com/flutter/flutter/blob/d62f75dde1cb6f04fadb9aff48896491ff0e2163/packages/flutter/test/material/refresh_indicator_test.dart#L119-L122</span>
<span class="token inserted">+      when(repository.list()).thenAnswer((_) async =&#x26;gt; /* response */);</span>
<span class="token inserted">+      await tester.fling(find.byType(ListView), const Offset(0, 300), 1000);</span>
<span class="token inserted">+      await tester.pump();</span>
<span class="token inserted">+      await tester.pump(const Duration(seconds: 3));</span>
<span class="token inserted">+      // responseが更新されていることを確認</span>
<span class="token inserted">+      expect(/* */);</span>
<span class="token inserted">+    });</span>
<span class="token inserted">+  });</span>
<span class="token inserted">+}</span>
<span class="token inserted">+\```</span>
<span class="token inserted">+</span>
<span class="token inserted">+同様にしてRepositoryから`Future.error`を返すことでWidgetのエラー時の描画のテストを行うことが可能です．</span>
<span class="token inserted">+</span>
<span class="token inserted">+### ViewModelとService class</span>
<span class="token inserted">+</span>
<span class="token inserted">+ViewModelの処理をどのタイミングでServiceクラスへ委譲するかの基準は，[Arrange-Act-Assert][aaa]におけるArrange[^6]のコストを一つの目安とすることができます．  </span>
<span class="token inserted">+テストの準備の記述(Arrange)が少なくない割合を占める場合，テスト対象が状態や責務を持ちすぎている可能性があります．</span>
<span class="token inserted">+そうなった場合にはArrangeの記述及びViewModelのメソッドの処理からテスト(の準備が)しづらいメソッドを探しだしてServiceクラスへ抽出します．</span>
<span class="token inserted">+そうすることでテスト容易性を高め，かつテスト対象の関心の対象を絞ることで壊れづらいテストコードを保つことが可能です．  </span>
<span class="token inserted">+</span>
<span class="token inserted">+&#x26;lt;small&#x26;gt;このアプローチは実際テスト対象とレイヤーの異なる責務を見分けて分離するには便利な手法だと感じています&#x26;lt;/small&#x26;gt;</span>
<span class="token inserted">+</span>
<span class="token inserted">+補足:  </span>
<span class="token inserted">+SOLID原則の[Single-responsibility principle][srp]は"1つのクラスは1つの責務"といった説明がされがちですが，真意は"1つのクラスは1つの(アクターに対し)責務(を負う)"ということです．  </span>
<span class="token inserted">+ViewModelは責務が多くなりがちですが，対応するViewに対してのみ責務を追っているためSRPの観点からは適切です．  </span>
<span class="token inserted">+ただしViewModelのメソッドの処理をテストする際にViewModelがServiceクラスのアクターになれる場合においては，それはメソッドの処理をServiceクラスへと切り出すタイミングだと思います．</span>
<span class="token inserted">+</span>
<span class="token inserted">+---</span>
<span class="token inserted">+</span>
<span class="token inserted">+以上，テスト容易性を意識したFlutterアプリケーションのアーキテクチャを考察していきました．</span>
<span class="token inserted">+長くなってスマン.</span>
<span class="token inserted">+</span>
<span class="token inserted">+Dartの型システムは比較的緩いので，そういった言語特性も含めテストでカバーしていきたい気持ちがあり今回このような検討を行いました．  </span>
<span class="token inserted">+結合度と凝集度など関数レベルでの設計やTDDなどのプラクティスはもちろん，アーキテクチャレベルで考慮することで更にテスト容易性を向上することができ，またソフトウェアの品質を担保することに繋がります．</span>
<span class="token inserted">+</span>
<span class="token inserted">+&#x26;lt;small&#x26;gt;</span>
<span class="token inserted">+  半年とか経ったら振り返りをしようと考えています．  </span>
<span class="token inserted">+&#x26;lt;/small&#x26;gt;</span>
<span class="token inserted">+</span>
<span class="token inserted">+[praha_test]: https://www.praha-inc.com/lab/posts/testability</span>
<span class="token inserted">+[testability]: https://www.satisfice.com/download/heuristics-of-software-testability</span>
<span class="token inserted">+[shared_preferences]: https://pub.dev/packages/shared_preferences</span>
<span class="token inserted">+[freezed]: https://pub.dev/packages/freezed</span>
<span class="token inserted">+[riverpod]: https://pub.dev/packages/riverpod</span>
<span class="token inserted">+[dotenv]: https://pub.dev/packages/flutter_dotenv</span>
<span class="token inserted">+[json_serializable]: https://pub.dev/packages/json_serializable</span>
<span class="token inserted">+[http]: https://pub.dev/packages/http</span>
<span class="token inserted">+[dio]: https://pub.dev/packages/dio</span>
<span class="token inserted">+[flutter_test]: https://api.flutter.dev/flutter/flutter_test/flutter_test-library.html</span>
<span class="token inserted">+[mockito]: https://pub.dev/packages/mockito</span>
<span class="token inserted">+[mock_http_server]: https://pub.dev/packages/mock_web_server</span>
<span class="token inserted">+</span>
<span class="token inserted">+[async_value]: https://pub.dev/documentation/riverpod/latest/riverpod/AsyncValue-class.html</span>
<span class="token inserted">+[di_principles]: https://livebook.manning.com/book/dependency-injection-principles-practices-patterns/about-this-book/1</span>
<span class="token inserted">+</span>
<span class="token inserted">+[integration_test]: https://flutter.dev/docs/cookbook/testing/integration/introduction</span>
<span class="token inserted">+[golden_test]: https://pub.dev/packages/golden_toolkit</span>
<span class="token inserted">+</span>
<span class="token inserted">+[aaa]: https://docs.microsoft.com/en-us/visualstudio/test/unit-test-basics?view=vs-2019#write-your-tests</span>
<span class="token inserted">+[srp]: https://en.wikipedia.org/wiki/Single-responsibility_principle</span>
<span class="token inserted">+</span>
<span class="token inserted">+</span>
<span class="token inserted">+[^1]: [Dependency Injection principles, Manning][di_principles]. volatile dependency/static dependency</span>
<span class="token inserted">+[^2]: https://blog.ploeh.dk/2018/08/27/on-constructor-over-injection/</span>
<span class="token inserted">+[^3]: https://docs.microsoft.com/en-us/archive/blogs/johngossman/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps</span>
<span class="token inserted">+[^4]: https://martinfowler.com/bliki/HumbleObject.html</span>
<span class="token inserted">+[^5]: https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html</span>
<span class="token inserted">+[^6]: またはHeuristics of Software TestabilityにおけるControllability/Decomposability.</span>
</code></pre></div></div></details></div><div class="Comments_comment__WxfzD" role="comment"><h2 class="Comments_title__YENiL">Comments</h2><div id="github-comment-container"></div></div></div><aside class="slug_aside__gL3UH"><nav class="Toc_toc__nav__rl0h7" role="navigation"><ul class="Toc_toc__Y4dWA"></ul></nav></aside></div></main><footer class="Footer_footer__FDcZZ"><small>Code snippets licensed under MIT, unless otherwise noted.</small></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slug":"2021-10-20-testable-architecture-flutter","title":"テスト容易性を考慮したFlutterのアーキテクチャ考察","categories":["Programming"],"image":"https://koka831.github.io/img/icon.png","tags":["Flutter"],"content":"\u003cp\u003eここ半年ほどFlutterを書いていて，アプリケーションのアーキテクチャで試行錯誤してます．状態管理ムズくない？\u003cbr\u003e\nなのでいっそ表に出して意見もらえたらな，と思ったので書きます．\u003c/p\u003e\n\u003cp\u003e本記事では，Flutterアプリケーションにおいてテスト容易性を向上するためにはどうすればいいか，サンプルアプリケーションを例題にアーキテクチャレベルで検討します．\u003c/p\u003e\n\u003ch2 id=\"アーキテクチャの目的\"\u003e\u003ca href=\"#アーキテクチャの目的\"\u003eアーキテクチャの目的\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e今回は\u003cstrong\u003eテスト容易性\u003c/strong\u003eを主軸に置いたアーキテクチャ選定を行いました．\n特にFlutterの単体テストはネットワークリクエストが遮断されるので，副作用を伴う処理を行うレイヤを適切に分離し，テストが容易になるよう設計を行うこととしました．\u003c/p\u003e\n\u003cp\u003eアーキテクチャは何かしら課題を解決するために設計されるもの(だと思っている)なので，今回示す例が必ずしもベストなものとは限らないです．\u003c/p\u003e\n\u003ch3 id=\"テスト容易性とは\"\u003e\u003ca href=\"#テスト容易性とは\"\u003eテスト容易性とは\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eテスト容易性とは，James Bachが提唱した\u003ca href=\"https://www.satisfice.com/download/heuristics-of-software-testability\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003eHeuristics of Software Testability\u003c/a\u003e(テスタビリティ・テスト容易性のモデル)に示される，テストの品質を測る指標です．\nそれぞれの説明は\u003ca href=\"https://www.praha-inc.com/lab/posts/testability\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e優れたテスト容易性を実現するためのポイント - PrAha ENGINEER LAB\u003c/a\u003eに詳しいです．\u003cbr\u003e\nこちらの記事でも示されている通り，テスト容易性の向上にはテスト容易性を低下させる要因を抑えることが必要不可欠です．そしてその要因はコードレベルに留まらずアーキテクチャレベルで抑えることが求められます．\u003c/p\u003e\n\u003ch2 id=\"全体像\"\u003e\u003ca href=\"#全体像\"\u003e全体像\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eざっくり以下の機能を持つアプリケーションを例にとります．\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eAPIサーバからデータ\u003ccode\u003eFoo\u003c/code\u003eのリストを取得してデータを描画する\u003c/li\u003e\n\u003cli\u003eデータ\u003ccode\u003eFoo\u003c/code\u003eを作成し，描画されるリストを更新する\u003c/li\u003e\n\u003cli\u003epull-to-refreshでのデータ再取得機能を持つ\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eまた，今回用いるレイヤは以下のようになります;\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eAPI Client\u003c/strong\u003e: APIサーバからのデータ取得+モデルへのdeserializeを行う\n\u003cul\u003e\n\u003cli\u003e実装: \u003ccode\u003eGetRequestProtocol\u003c/code\u003e + \u003ccode\u003eListFooRequest\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRepository\u003c/strong\u003e: API Client(+\u003ca href=\"https://pub.dev/packages/shared_preferences\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003eshared_preferences\u003c/a\u003e)を利用してデータ取得・更新を行う\n\u003cul\u003e\n\u003cli\u003e実装: \u003ccode\u003eFooRepository\u003c/code\u003e + \u003ccode\u003efooRepositoryProvider\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eService\u003c/strong\u003e: ドメインロジック担当(もしくはTransaction Script)\n\u003cul\u003e\n\u003cli\u003e実装は省略\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eViewModel\u003c/strong\u003e: Viewの描画以外の責務全て\n\u003cul\u003e\n\u003cli\u003e実装: \u003ccode\u003eFooViewModel\u003c/code\u003e + \u003ccode\u003efooViewModelProvider\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eView\u003c/strong\u003e: 描画+イベントとViewModelのイベントハンドラの糊付け\n\u003cul\u003e\n\u003cli\u003e実装は省略\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eテスト容易性を念頭に置いた際にどのレイヤの分割が必要か判断した結果，基本的なMVVMアーキテクチャとなりました．\u003cbr\u003e\nテスト容易性のためには特にViewをいかに薄く保てるかがキモで，そのためにViewModelはやや責務過多になる傾向にあります．\nしたがってViewModelの肥大化を防ぐためにドメインロジックをViewModelからServiceクラスへ委譲し，また描画用のデータ管理とステートレスなドメインロジックを分離してテストできるようにします．\u003cbr\u003e\nViewModelと共に扱われることの多い，StreamやReactiveな双方向データバインディングは扱いません．\u003c/p\u003e\n\u003cp\u003e以下では各レイヤ毎に簡易実装及びそのテストコードを示し，そのレイヤにおける責務と設計基準を説明します．\u003cbr\u003e\n実際の設計時はテストコードから書いて書き心地を試しつつの実装を行いましたが，説明の都合で実装-\u003eテストの順で示します．\u003c/p\u003e\n\u003cp\u003eまた，Widgetについての設計はここでは述べません．\nテスト容易性の観点からViewを薄く保つことを念頭に置いているため，ViewはViewModelまでの設計と異なる目的での設計を取りうるためです．\u003c/p\u003e\n\u003ch2 id=\"api-client\"\u003e\u003ca href=\"#api-client\"\u003eAPI Client\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eAPIクライアントクラスはネットワーク越しのリクエストを行い，アプリ内でのモデルへのdeserializeを行います．\u003c/p\u003e\n\u003cp\u003eここではREST APIを仮定したクラス設計を行いますが，gRPCやGraphQLの場合でも実装が異なるだけで責務自体は変わらないと思います．\u003cbr\u003e\nAPIレスポンスは対応するモデルクラスにマッピングし，\u003ccode\u003edynamic\u003c/code\u003e型として存在する期間を極力短く保ちます．\u003c/p\u003e\n\u003cp\u003eモデルクラスは適当な集約単位で作成し，レスポンスを正規化して持つようにします．\n\u003ca href=\"https://pub.dev/packages/json_serializable\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ejson_serializable\u003c/a\u003eと組み合わせて\u003ccode\u003edeserialize\u003c/code\u003eの実装をModelのconstructorとして任せると楽です．\u003c/p\u003e\n\u003cp\u003e\u003cdiv class=\"remark-container info\"\u003e\u003cdiv class=\"remark-container__title\"\u003eimmutable\u003c/div\u003eDartで構造体や関数以外への型エイリアスが定義できないのでclassとして定義するしかない．\nただ内部状態を変更できるクラスメソッドを書けてしまうと変更検知が辛くなってしまう．\u003c/div\u003e\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre data-file=\"foo.dart\" class=\"language-dart  line-numbers\"\u003e\u003ccode class=\"language-dart\"\u003e\u003cspan class=\"token metadata symbol\"\u003e@freezed\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eFoo\u003c/span\u003e \u003cspan class=\"token keyword\"\u003ewith\u003c/span\u003e _$\u003cspan class=\"token class-name\"\u003eFoo\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token keyword\"\u003efactory\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eFoo\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003efromJson\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eMap\u003c/span\u003e\u003cspan class=\"token generics\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eString\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token keyword\"\u003edynamic\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e json\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e _$\u003cspan class=\"token class-name\"\u003eFooFromJson\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ejson\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan aria-hidden=\"true\" class=\"line-numbers-rows\"\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eAPIリクエストクラスは，実際のリクエスト処理の隠蔽及びテスト時のDIインターフェース統一のためにプロトコルで縛るようにします．\nプロトコルはmixinとして定義し，リクエスト処理を行う\u003ccode\u003erequest\u003c/code\u003eメソッドのみmixin側に実装します．\u003cbr\u003e\nここでは簡単のため\u003ccode\u003eurl\u003c/code\u003e以外の定義を省略していますが，クエリパラメータやヘッダなど，想定されるユースケースに応じた設定が行えるようにインターフェースを設計します．\u003c/p\u003e\n\u003cp\u003e今回はGETリクエストを想定した\u003ccode\u003eGetRequestProtocol\u003c/code\u003eを定義し，またそのユースケースとして\u003ccode\u003eListFooRequest\u003c/code\u003eを実装します．\u003cbr\u003e\nまた，\u003ccode\u003eHttpClient\u003c/code\u003eはHTTPリクエストを担う\u003ca href=\"https://pub.dev/packages/http\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ehttp\u003c/a\u003eや\u003ca href=\"https://pub.dev/packages/dio\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003edio\u003c/a\u003e，またはいずれかをwrapしたクラスです．\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre data-file=\"api_protocol.dart\" class=\"language-dart  line-numbers\"\u003e\u003ccode class=\"language-dart\"\u003e\u003cspan class=\"token comment\"\u003e// `package:meta` に [@mustOverride] annotation が入ったら嬉しい\u003c/span\u003e\n\u003cspan class=\"token comment\"\u003e// @see: \u003ca href=\"https://github.com/dart-lang/sdk/issues/30175\" class=\"token url-link\"\u003ehttps://github.com/dart-lang/sdk/issues/30175\u003c/a\u003e\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003emixin\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eGetRequestProtocol\u003c/span\u003e\u003cspan class=\"token generics\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eM\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token metadata symbol\"\u003e@protected\u003c/span\u003e\n  \u003cspan class=\"token class-name\"\u003eString\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eget\u003c/span\u003e url \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"token keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eUnimplementedError\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n  \u003cspan class=\"token class-name\"\u003eFuture\u003c/span\u003e\u003cspan class=\"token generics\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eM\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"token function\"\u003erequest\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eHttpClient\u003c/span\u003e client\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003efinal\u003c/span\u003e json \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eawait\u003c/span\u003e client\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token keyword\"\u003eget\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token comment\"\u003e/* api request */\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"token function\"\u003e_deserialize\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ejson\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\n  \u003cspan class=\"token metadata symbol\"\u003e@protected\u003c/span\u003e\n  \u003cspan class=\"token class-name\"\u003eM\u003c/span\u003e \u003cspan class=\"token function\"\u003e_deserialize\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eResponse\u003c/span\u003e json\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan aria-hidden=\"true\" class=\"line-numbers-rows\"\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eユースケース側は\u003ccode\u003eGetRequestProtocol\u003c/code\u003eを取り込んだRequestクラスを定義し，\u003ccode\u003erequest\u003c/code\u003eメソッドが返すレスポンスをモデルへ変換する\u003ccode\u003edeserialize\u003c/code\u003eメソッドを実装します．\u003c/p\u003e\n\u003cp\u003eここでは簡単のため\u003ccode\u003eurl\u003c/code\u003eを固定値としていますが，実際には\u003ca href=\"https://pub.dev/packages/flutter_dotenv\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003eflutter_dotenv\u003c/a\u003eを用いて環境変数としてAPIエンドポイントの管理を行います．\nこれは設定と実装の分離の観点からももちろん好ましいのですが，読み込む\u003ccode\u003e.env\u003c/code\u003eファイルをテスト時に差し替えられる利点が大きいです．詳細は後述します．\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre data-file=\"list_foo_request.dart\" class=\"language-dart  line-numbers\"\u003e\u003ccode class=\"language-dart\"\u003e\u003cspan class=\"token keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eListFooRequest\u003c/span\u003e \u003cspan class=\"token keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eGetRequestProtocol\u003c/span\u003e\u003cspan class=\"token generics\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eList\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eFoo\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token metadata symbol\"\u003e@override\u003c/span\u003e\n  \u003cspan class=\"token class-name\"\u003eString\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eget\u003c/span\u003e url \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"token string\"\u003e'\u003ca href=\"https://example.com/foos\" class=\"token url-link\"\u003ehttps://example.com/foos\u003c/a\u003e'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n  \u003cspan class=\"token metadata symbol\"\u003e@override\u003c/span\u003e\n  \u003cspan class=\"token class-name\"\u003eList\u003c/span\u003e\u003cspan class=\"token generics\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eFoo\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"token function\"\u003e_deserialize\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eResponse\u003c/span\u003e json\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token comment\"\u003e// レスポンスのJSONが`foos`をキーとして[Foo]の配列を持つと仮定\u003c/span\u003e\n    \u003cspan class=\"token comment\"\u003e// constructor の tear-off が入ると `.map(Foo.fromJson)`のようにかける\u003c/span\u003e\n    \u003cspan class=\"token comment\"\u003e// @see: \u003ca href=\"https://twitter.com/remi_rousselet/status/1438207417154686980?s=20\" class=\"token url-link\"\u003ehttps://twitter.com/remi_rousselet/status/1438207417154686980?s=20\u003c/a\u003e\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ejson\u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"token string\"\u003e'foos'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e \u003cspan class=\"token operator\"\u003eas\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eList\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n      \u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003emap\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ef\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eFoo\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003efromJson\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ef \u003cspan class=\"token operator\"\u003eas\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eMap\u003c/span\u003e\u003cspan class=\"token generics\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eString\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token keyword\"\u003edynamic\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n      \u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003etoList\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan aria-hidden=\"true\" class=\"line-numbers-rows\"\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch3 id=\"test\"\u003e\u003ca href=\"#test\"\u003etest\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eAPIクライアントクラスはネットワークリクエストを行い，レスポンスをモデルに変換するところまでを責務としました．\u003cbr\u003e\nFlutterのテストライブラリ\u003ca href=\"https://api.flutter.dev/flutter/flutter_test/flutter_test-library.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003eflutter_test\u003c/a\u003eではネットワークリクエストが遮断されるため，APIクライアントクラスに対するテストは\u003ccode\u003erequest\u003c/code\u003eメソッドの返り値が対応するモデルインスタンスであるかどうかを評価することになります．\u003cbr\u003e\nモックのアプローチとしては以下の2パターンが考えられます;\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eA. \u003ca href=\"https://pub.dev/packages/mockito\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003emockito\u003c/a\u003eを用いて\u003ccode\u003eHttpClient\u003c/code\u003eのモックオブジェクトを生成し，対応するレスポンスをスタブする\u003c/li\u003e\n\u003cli\u003eB. \u003ca href=\"https://pub.dev/packages/mock_web_server\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003emock_http_server\u003c/a\u003eを用いてテスト用APIサーバを構築し，閉じたネットワークでのテストを行う\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003emockitoを用いる場合，今回の例題では\u003ccode\u003eHttpClient\u003c/code\u003eクラスの\u003ccode\u003eget\u003c/code\u003eメソッドをスタブすれば良さそうですが，HTTPリクエストを担うレイヤはinterceptorなどの機構を用いてロガーやエラーハンドラなどを注入するケースが多々あります．\u003cbr\u003e\nそのためテスト時に生成される\u003ccode\u003eHttpClient\u003c/code\u003eのモックオブジェクトと実際のリクエスト時に渡される\u003ccode\u003eHttpClient\u003c/code\u003eのインスタンスはスタブされている箇所以外にも設定が異なってしまうことが懸念されます．\nしたがって\u003ccode\u003eHttpClient\u003c/code\u003eの挙動がランタイムと乖離しないように，ネットワークリクエスト先をすげ替えるBの方針を取ることにします．\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre data-file=\"list_foo_request_test.dart\" class=\"language-dart  line-numbers\"\u003e\u003ccode class=\"language-dart\"\u003e\u003cspan class=\"token keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"token function\"\u003emain\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token keyword\"\u003efinal\u003c/span\u003e server \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eMockWebServer\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eport\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e8081\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n  \u003cspan class=\"token function\"\u003esetUp\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token comment\"\u003e// APIエンドポイントを[MockWebServer]にすげ替えるためにテスト用の.envファイルを読み込む．\u003c/span\u003e\n    \u003cspan class=\"token comment\"\u003e// HttpClientがbaseUrlを保持するパターンもあるが，全てのAPIが単一のbaseUrlからされない場合もあるので\u003c/span\u003e\n    \u003cspan class=\"token comment\"\u003e// このようにしておく．\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003eawait\u003c/span\u003e dotenv\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eload\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003efileName\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token string\"\u003e'.env.test'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n    server\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003estart\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n  \u003cspan class=\"token function\"\u003etearDown\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eserver\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eshutdown\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n  \u003cspan class=\"token comment\"\u003e// エラー時のテストケースについては，エラーハンドラを`request`メソッドの実装に持たせたり\u003c/span\u003e\n  \u003cspan class=\"token comment\"\u003e// interceptorで挟んだりするためHttpClientやmixinのテストで記述する．\u003c/span\u003e\n  \u003cspan class=\"token comment\"\u003e// したがって個々のRequestクラスのテストケースはシンプルに保つことができる．\u003c/span\u003e\n  \u003cspan class=\"token function\"\u003etest\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e'ListFooRequest returns list of Foo'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token comment\"\u003e// ここではJSONの構築に[dart:convert#jsonEncode]を用いた．\u003c/span\u003e\n    \u003cspan class=\"token comment\"\u003e// `json_serializable` が生成する`toJson`メソッドで適当なレスポンスを組み立ててもよい．\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003efinal\u003c/span\u003e body \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e \u003cspan class=\"token string\"\u003e'foos'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\u003cspan class=\"token comment\"\u003e/* Foo モデル */\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n    server\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eenqueue\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ehttpCode\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e200\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e body\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token function\"\u003ejsonEncode\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ebody\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003efinal\u003c/span\u003e response \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eListFooRequest\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003erequest\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ehttpClient\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n    \u003cspan class=\"token function\"\u003eexpect\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eresponse\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e isA\u003cspan class=\"token generics\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eList\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eFoo\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan aria-hidden=\"true\" class=\"line-numbers-rows\"\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch2 id=\"repository\"\u003e\u003ca href=\"#repository\"\u003eRepository\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eRepositoryクラスはデータ取得及びデータの更新操作を行います．\u003cbr\u003e\nここではAPIからのリモートデータリソースのみを扱っていますが，\u003ca href=\"https://pub.dev/packages/shared_preferences\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003eshared_preferences\u003c/a\u003eやKeychain/KeyStoreを利用したローカルデータソースに対する操作も責務に含まれます．\u003c/p\u003e\n\u003cp\u003eRepositoryクラスはViewModelレイヤから利用されるのですが，Repositoryクラスはネットワークアクセスが行われるためViewModelクラスの内部でRepositoryクラスを初期化してしまうとViewModelのテストが困難になります．\u003cbr\u003e\nかといってViewModelクラスのコンストラクタにRepositoryクラスを引数として渡す場合，そのViewModelクラスを利用するViewでRepositoryクラスを作成してViewModelを得る必要が出てしまい，レイヤ跨ぎ(View -\u003e Repository)が発生してしまいます．\u003c/p\u003e\n\u003cp\u003eこれを解消するためにDI(Dependency Injection)を用いて各レイヤ間の結合をDIプロバイダに委任します．\u003c/p\u003e\n\u003cp\u003eRepositoryインスタンスには\u003ca href=\"https://pub.dev/packages/riverpod\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003eriverpod\u003c/a\u003eの提供する\u003ccode\u003eProvider\u003c/code\u003eを介してアクセスするようにします．\nそのために\u003ccode\u003eFooRepository\u003c/code\u003eにはパブリックなコンストラクタを実装せずプライベートコンストラクタ\u003ccode\u003e._()\u003c/code\u003eのみを定義し，外部ファイルから\u003ccode\u003eFooRepository\u003c/code\u003eインスタンスを直接立ち上げることを禁止します．\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre data-file=\"foo_repository.dart\" class=\"language-dart\"\u003e\u003ccode class=\"language-dart\"\u003e\u003cspan class=\"token keyword\"\u003efinal\u003c/span\u003e fooRepositoryProvider \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eProvider\u003c/span\u003e\u003cspan class=\"token generics\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eFooRepository\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eref\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eFooRepository\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003e_\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eref\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eread\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eまた，(一般的なアーキテクチャにおける)Repositoryクラスは永続化層と表現されることもあり，その文脈ではキャッシュ機構を持つことがあります．\u003cbr\u003e\n仮に\u003ccode\u003eFooRepository\u003c/code\u003eがキャッシュ機構を持つとした場合，そのテストがどのように記述されるべきかを見ていきます．\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eFooRepository\u003c/code\u003eがキャッシュ機構を持つ場合，リモートデータソースとキャッシュとの整合性の不一致が生じえます．\n例えば\u003ccode\u003ecreate\u003c/code\u003eを呼んだ後に\u003ccode\u003elist\u003c/code\u003eを実行すると，\u003ccode\u003ecreate\u003c/code\u003eしたデータが含まれないキャッシュが返されるなどが考えられます．\u003cbr\u003e\nデータの整合性を担保するにはいくつか方法がありますが，ここではシンプルにキャッシュの破棄操作を行う実装を行うとしましょう．\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre data-file=\"foo_repository.dart\" class=\"language-dart\"\u003e\u003ccode class=\"language-dart\"\u003e\u003cspan class=\"token keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eFooRepository\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token comment\"\u003e// @see \u003ca href=\"https://pub.dev/documentation/riverpod/latest/riverpod/Ref/read.html\" class=\"token url-link\"\u003ehttps://pub.dev/documentation/riverpod/latest/riverpod/Ref/read.html\u003c/a\u003e\u003c/span\u003e\n  \u003cspan class=\"token class-name\"\u003eFooRepository\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003e_\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eReader\u003c/span\u003e read\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e _httpClient \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003eread\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ehttpClientProvider\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n  \u003cspan class=\"token keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eHttpClient\u003c/span\u003e _httpClient\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"token class-name\"\u003eList\u003c/span\u003e\u003cspan class=\"token generics\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eFoo\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token operator\"\u003e?\u003c/span\u003e _cache\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n  \u003cspan class=\"token class-name\"\u003eFuture\u003c/span\u003e\u003cspan class=\"token generics\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eList\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eFoo\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"token function\"\u003elist\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e_cache \u003cspan class=\"token operator\"\u003e!=\u003c/span\u003e \u003cspan class=\"token keyword\"\u003enull\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e _cache\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n    _cache \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eListFooRequest\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003erequest\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e_httpClient\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003ereturn\u003c/span\u003e _cache\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\n  \u003cspan class=\"token comment\"\u003e// Requestクラスの説明では省略した[CreateFooRequest]を用いて\u003c/span\u003e\n  \u003cspan class=\"token comment\"\u003e// [Foo]レコードを作成するリクエストを行う．\u003c/span\u003e\n  \u003cspan class=\"token comment\"\u003e// [CreateFoo]クラスは[Foo]レコードを作成する際のDTO.\u003c/span\u003e\n  \u003cspan class=\"token class-name\"\u003eFuture\u003c/span\u003e\u003cspan class=\"token generics\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eFoo\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"token function\"\u003ecreate\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eCreateFoo\u003c/span\u003e createFoo\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    _cache \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token keyword\"\u003enull\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eCreateFooRequest\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ecreateFoo\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003erequest\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e_httpClient\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch3 id=\"test-1\"\u003e\u003ca href=\"#test-1\"\u003etest\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eRepositoryクラスはデータ取得・更新操作を行い，データの整合性を担保します．\nRepositoryクラスのユースケースにおいては，その内部にキャッシュ機構があるかどうか，またはインメモリデータベースを利用しているかどうかは隠蔽されているべきです．\nしたがって実装の詳細には触れず，その振る舞いのみを保証するにはテストデータ更新後に最新のデータを返すかどうかを確認すれば良さそうです．\u003c/p\u003e\n\u003cp\u003e次にテスト容易性を主軸にRepositoryクラスをどのように提供するか考察します．\u003cbr\u003e\nRepositoryクラスはその責務上複数のAPIクライアントクラスを操作するため，テストのタイミングではAPIクライアントクラスもしくはその処理のモックが必要となります．\nRepositoryクラスにおいてもどのレイヤーをモックするかが設計のポイントとなるのですが，Repositoryクラスのコンストラクタに渡される\u003ccode\u003eHttpClient\u003c/code\u003eをモックする方針をとります．\u003cbr\u003e\n判断に至った思考仮定は次のようなものです;\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eA. APIクライアントのテストのようにAPIサーバをモックする場合\u003c/strong\u003e\u003cbr\u003e\nこの場合Repositoryクラスが扱う各APIクライアントクラスに対するモックAPIサーバの設定を記述する必要があります．\nこの設定にはエンドポイントのURLやレスポンスのJSONスキーマ定義など，APIクライアントクラスの責務となる詳細部分が必要なので，\nAPIクライアントの実装を変更することでRepositoryクラスのテストがfailする可能性があり，修正に脆いテストとなり得ます．\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eB. 個々のAPIクライアントクラスをモックする場合\u003c/strong\u003e\u003cbr\u003e\n先に示した\u003ccode\u003eFooRepository\u003c/code\u003eクラスの実装ではAPIクライアントクラスをハードコードして利用しています．\u003cbr\u003e\nAPIクライアントクラスをモックする場合には各APIクライアントクラスをDIするかコンストラクタの引数として受け取るような実装をする必要が生じます．\u003cbr\u003e\n(callerの直接の)コンストラクタでの引数渡しについては先に述べたとおり抽象化レイヤを跨いでしまうため避けたいです．\u003cbr\u003e\nまたAPIクライアントクラスはRepositoryクラスにとってStatic Dependency\u003csup\u003e\u003ca href=\"#user-content-fn-1\" id=\"user-content-fnref-1\" data-footnote-ref aria-describedby=\"footnote-label\"\u003e1\u003c/a\u003e\u003c/sup\u003eであり，また各APIクライアントクラスをDIすることはOver-Injection\u003csup\u003e\u003ca href=\"#user-content-fn-2\" id=\"user-content-fnref-2\" data-footnote-ref aria-describedby=\"footnote-label\"\u003e2\u003c/a\u003e\u003c/sup\u003eに繋がるのでこれもベストとは言い難いです．\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eC. HttpClientをモックする場合\u003c/strong\u003e\u003cbr\u003e\nAではネットワーク先，BではAPIクライアントの振る舞いをそれぞれスタブする方針でした．\u003cbr\u003e\nAPIクライアントクラスが利用する\u003ccode\u003eHttpClient\u003c/code\u003eをモックすることで，APIクライアントのネットワークリクエスト処理のみをスタブすることができます．\u003cbr\u003e\nAPIクライアントクラスが\u003ccode\u003eHttpClient\u003c/code\u003eを利用する処理はmixinとして実装を与えてあるため，個々のAPIクライアントクラスの振る舞いには左右されず修正に強いテストが期待できます．\nまたBと比較してもDIする対象が1つで済むため適切であると言えます．\u003c/p\u003e\n\u003cp\u003eテストコードで\u003ccode\u003eHttpClient\u003c/code\u003eをProviderから受け取るには\u003ccode\u003eProviderContainer\u003c/code\u003eを利用します．\u003cbr\u003e\n\u003ccode\u003eProviderContainer\u003c/code\u003eの引数にDIプロバイダのオーバーライド設定を指定することで，テスト内では\u003ccode\u003emockHttpClient\u003c/code\u003eを利用するRepositoryクラスを利用することができます．\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre data-file=\"foo_repository_test.dart\" class=\"language-dart\"\u003e\u003ccode class=\"language-dart\"\u003e\u003cspan class=\"token keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"token function\"\u003emain\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token keyword\"\u003efinal\u003c/span\u003e container \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eProviderContainer\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\n    overrides\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003ehttpClientProvider\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eoverrideWithValue\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003emockHttpClient\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"token keyword\"\u003efinal\u003c/span\u003e repository \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e container\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eread\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003efooRepositoryProvider\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eデータ整合性のテストはユースケースを元に，\u003ccode\u003ecreate\u003c/code\u003eメソッド実行後に\u003ccode\u003elist\u003c/code\u003eメソッドの実行結果が\u003ccode\u003ecreate\u003c/code\u003eしたデータを含むかどうかを確認します．\u003c/p\u003e\n\u003cp\u003e\u003csmall\u003eもちろん\u003ccode\u003elist\u003c/code\u003eメソッド単体のテストは書く前提です.\u003c/small\u003e\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre data-file=\"foo_repository_test.dart\" class=\"language-dart\"\u003e\u003ccode class=\"language-dart\"\u003e\u003cspan class=\"token keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"token function\"\u003emain\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token comment\"\u003e// omitted\u003c/span\u003e\n\n  \u003cspan class=\"token comment\"\u003e// HttpClientの挙動をスタブ\u003c/span\u003e\n  \u003cspan class=\"token function\"\u003ewhen\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003emockHttpClient\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token keyword\"\u003eget\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eany\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ethenAnswer\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e_\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e listFooResponse\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"token keyword\"\u003evar\u003c/span\u003e response \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eawait\u003c/span\u003e repository\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003elist\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"token comment\"\u003e// verify(mockHttpClient.get(any)) として\u003c/span\u003e\n  \u003cspan class=\"token comment\"\u003e// **内部でmockHttpClientが呼ばれた**ことをテストすることも可能だが，\u003c/span\u003e\n  \u003cspan class=\"token comment\"\u003e// ここではRepositoryクラスの振る舞いを見ることを主軸に置くためテストに含めない．\u003c/span\u003e\n  \u003cspan class=\"token comment\"\u003e// 実際のユースケースではRepositoryクラスはProvider経由で利用され，\u003c/span\u003e\n  \u003cspan class=\"token comment\"\u003e// HttpClientはProvider内部で渡されるため利用する側からはHttpClientはされている.\u003c/span\u003e\n  \u003cspan class=\"token comment\"\u003e// あくまでテストにおいてのみRepositoryクラスがHttpClientを利用していることを知る必要が生じている．\u003c/span\u003e\n  \u003cspan class=\"token comment\"\u003e//\u003c/span\u003e\n  \u003cspan class=\"token comment\"\u003e// ListFooRequestの結果が返される\u003c/span\u003e\n  \u003cspan class=\"token function\"\u003eexpect\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eresponse\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e listFooResponse\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n  \u003cspan class=\"token comment\"\u003e// create時の挙動をスタブ\u003c/span\u003e\n  \u003cspan class=\"token function\"\u003ewhen\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003emockHttpClient\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003epost\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eany\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ethenAnswer\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e_\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e createResponse\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"token keyword\"\u003efinal\u003c/span\u003e createFoo \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eCreateFoo\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token comment\"\u003e/* */\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  response \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eawait\u003c/span\u003e repository\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ecreate\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ecreateFoo\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"token function\"\u003eexpect\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eresponse\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e createResponse\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n  \u003cspan class=\"token comment\"\u003e// 再度Listした際に更新されたResponseが返される\u003c/span\u003e\n  \u003cspan class=\"token function\"\u003ewhen\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003emockHttpClient\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token keyword\"\u003eget\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eany\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ethenAnswer\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e_\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e updatedListResponse\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  response \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eawait\u003c/span\u003e repository\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003elist\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"token function\"\u003eexpect\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eresponse\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e updatedListResponse\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch2 id=\"viewmodel\"\u003e\u003ca href=\"#viewmodel\"\u003eViewModel\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eViewModelはViewが利用するデータ及びロジックを提供します．\u003cbr\u003e\nここが一番責務をどこにおくか悩むところだと思うので，ViewModelの定義について John Gossman. (2005)\u003csup\u003e\u003ca href=\"#user-content-fn-3\" id=\"user-content-fnref-3\" data-footnote-ref aria-describedby=\"footnote-label\"\u003e3\u003c/a\u003e\u003c/sup\u003eを紹介します．\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThe UI may want to perform complex operations that must be implemented in code which doesn't make sense in our strict definition of the View but are too specific to be included in the Model (or didn't come with the pre-existing model).\nFinally we need a place to put view state such as selection or modes.\u003c/p\u003e\n\u003cp\u003eThe ViewModel is responsible for these tasks.\nThe term means \"Model of a View\", and can be thought of as abstraction of the view,\nbut it also provides a specialization of the Model that the View can use for data-binding.\nIn this latter role the ViewModel contains data-transformers that convert Model types into View types, and it contains Commands the View can use to interact with the Model.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eここで示したいのはViewModelはViewとのデータバインディングだけではなく，Viewが行う複雑な操作(=ドメインロジック)をも責務に含むという点です．\nこれは逆にViewにそのような処理をもたせてはいけないというだけなので，ViewModelまたはServiceレイヤに持たせるようにします．\u003cbr\u003e\nViewModelからはViewでの操作のハンドラを提供し，ViewからServiceクラスを直接呼ぶことのないようにします．\u003cbr\u003e\n例外的にpull-to-refreshのように描画・アニメーションがメインとなるロジックや，\u003ccode\u003eBuildContext\u003c/code\u003eを介する処理(例: \u003ccode\u003eNavigator.push\u003c/code\u003e等)についてはView側の責務となります．\u003c/p\u003e\n\u003cp\u003eまた，テスト容易性の観点からはMartin Fowler氏のHumble Object\u003csup\u003e\u003ca href=\"#user-content-fn-4\" id=\"user-content-fnref-4\" data-footnote-ref aria-describedby=\"footnote-label\"\u003e4\u003c/a\u003e\u003c/sup\u003eをイメージするとViewとViewModelとのそれぞれの責務の切り分けがしやすいかと思います．\u003c/p\u003e\n\u003cp\u003eViewのテストを考慮すると，View内部でViewModelをイニシャライズするとViewModelのモックがやや手間になります．\u003cbr\u003e\nしたがってViewModelにおいてもProviderを利用して提供します．\u003c/p\u003e\n\u003cp\u003eここで，ViewModelのライフサイクルをどうするか検討しましょう．\u003cbr\u003e\nViewModelがViewを参照しない・してはならないことからもわかるように，ViewModelとViewとのライフサイクルは異なります．\nしかしViewインスタンスが破棄された後にViewModelが生き続けると，再度Viewが生成された際にその(中途半端な状態を持つ)ViewModelが参照されると困るケースもあります．\nそういったケースでは\u003ccode\u003eStateNotifierProvider.autoDispose\u003c/code\u003eを用いてViewModelのライフサイクルをViewに揃え，Viewが生成されるタイミングでViewModelを生成してデータの整合性を担保するようにします．\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre data-file=\"view_model.dart\" class=\"language-dart\"\u003e\u003ccode class=\"language-dart\"\u003e\u003cspan class=\"token keyword\"\u003efinal\u003c/span\u003e fooViewModelProvider \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eStateNotifierProvider\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eautoDispose\u003cspan class=\"token generics\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eFooViewModel\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eFooState\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eref\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eWaitingListViewModel\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eref\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eread\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eViewModelが持つ状態はたとえ変数が1つであってもクラスとして切り出し，内包する状態が増えた際に変更に対して閉じるようにします．\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre data-file=\"view_model.dart\" class=\"language-dart\"\u003e\u003ccode class=\"language-dart\"\u003e\u003cspan class=\"token metadata symbol\"\u003e@freezed\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eFooState\u003c/span\u003e \u003cspan class=\"token keyword\"\u003ewith\u003c/span\u003e _$\u003cspan class=\"token class-name\"\u003eFooState\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"token keyword\"\u003efactory\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eFooState\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003e_\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    required \u003cspan class=\"token class-name\"\u003eAsyncValue\u003c/span\u003e\u003cspan class=\"token generics\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eList\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eFoo\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e foos\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e _FooState\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e今回はViewがpull-to-refresh機能を提供するとして設計します．\nその場合，Viewで必要となるロジックは以下のようなデータ及びイベントハンドラが考えられます；\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eViewで描画するデータ(\u003ccode\u003eList\u0026#x3C;Foo\u003e\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003eView作成時のViewModelの初期化処理(\u003ccode\u003eonInit\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003epull-to-refresh実行時のリフレッシュ処理(\u003ccode\u003eonRefresh\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eFoo\u003c/code\u003eの追加処理(\u003ccode\u003ecreateFoo(CreateFoo foo)\u003c/code\u003e)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eまた描画するデータ\u003ccode\u003eList\u0026#x3C;Foo\u003e\u003c/code\u003eはAPIから取得するため，初期状態はデータを保持しておらずローディング中・ローディング失敗の状態も考えられます．\nそういったケースに対応するため\u003ccode\u003eFuture\u003c/code\u003eの値の変化を検知・通知できる\u003ca href=\"https://pub.dev/documentation/riverpod/latest/riverpod/AsyncValue-class.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003e\u003ccode\u003eAsyncValue\u003c/code\u003e\u003c/a\u003eを利用します．\u003c/p\u003e\n\u003cp\u003eそれぞれを実装におとすと次のようになります．\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre data-file=\"view_model.dart\" class=\"language-dart\"\u003e\u003ccode class=\"language-dart\"\u003e\u003cspan class=\"token keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eFooViewModel\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eStateNotifier\u003c/span\u003e\u003cspan class=\"token generics\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eFooState\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token class-name\"\u003eFooViewModel\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eReader\u003c/span\u003e read\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n      \u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e _repository \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003eread\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003efooRepositoryProvider\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n        \u003cspan class=\"token keyword\"\u003esuper\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eFooState\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003e_\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003efoos\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eAsyncValue\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eloading\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token comment\"\u003e// construct時に初期化処理`onInit`を実行\u003c/span\u003e\n    \u003cspan class=\"token function\"\u003eonInit\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\n  \u003cspan class=\"token keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eFooRepository\u003c/span\u003e _repository\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n  \u003cspan class=\"token class-name\"\u003eFuture\u003c/span\u003e\u003cspan class=\"token generics\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token keyword\"\u003evoid\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"token function\"\u003eonInit\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token comment\"\u003e// 今回の例では簡単のため`onRefresh`を呼ぶだけ\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"token function\"\u003eonRefresh\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\n  \u003cspan class=\"token class-name\"\u003eFuture\u003c/span\u003e\u003cspan class=\"token generics\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token keyword\"\u003evoid\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"token function\"\u003ecreateFoo\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eCreateFoo\u003c/span\u003e foo\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003eawait\u003c/span\u003e _repository\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ecreate\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003efoo\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ethen\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eres\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n      \u003cspan class=\"token keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"token function\"\u003eonRefresh\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ecatchError\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ee\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n      \u003cspan class=\"token comment\"\u003e// TODO\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\n  \u003cspan class=\"token class-name\"\u003eFuture\u003c/span\u003e\u003cspan class=\"token generics\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token keyword\"\u003evoid\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"token function\"\u003eonRefresh\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003eawait\u003c/span\u003e _repository\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003elist\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ethen\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eres\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n      state \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e state\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ecopyWith\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003efoos\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eAsyncValue\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003edata\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eres\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ecatchError\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ee\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n      state \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e state\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ecopyWith\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003efoos\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eAsyncValue\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eerror\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ee \u003cspan class=\"token operator\"\u003eas\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eObject\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch3 id=\"test-2\"\u003e\u003ca href=\"#test-2\"\u003etest\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eViewModelはViewが利用するデータ及びロジックの提供を責務とします．\u003cbr\u003e\nViewModelのテストですが，単体でのテストを行うかViewと組み合わせたテストを行うか正直自分の中で答えを出せていません．\nViewの持つロジックを極力薄くすることで，擬似的にViewの取りうる振る舞いをViewModelでテストすることは可能です．ただViewModelの取りうる状態に応じた描画はViewでのテストでしか担保することができず，かつそれらは無視できる量・質のものとは言い難いです．\u003cbr\u003e\nそのためViewはViewのテストが必要となりますが，ViewModelが示す状態に沿う描画ができているかを検査すればよいので，ある程度宣言的にテストを記述できます．\u003c/p\u003e\n\u003cp\u003e実際，実機での\u003ca href=\"https://flutter.dev/docs/cookbook/testing/integration/introduction\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003eintegration_test\u003c/a\u003eや回帰テストを行う\u003ca href=\"https://pub.dev/packages/golden_toolkit\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003egolden toolkit\u003c/a\u003eなどViewを対象としたテストツールも充実してきておりそれらを用いることで描画内容にとどまらないデザインのテストをも行うことが可能となってきています．\u003c/p\u003e\n\u003cp\u003eただ，そこに実際のViewModelを持ち込むかモックしたViewModelを持ち込むかは明確な判断理由を持てていません．\u003cbr\u003e\nここではテスト容易性を主軸においたアーキテクチャの紹介を行い，いわゆるUIテストについては上記の説明に留めることとします．\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e先程実装した\u003ccode\u003eFooRepository\u003c/code\u003eはProvider経由のみのアクセスとするためにパブリックなコンストラクタを公開していませんでした．\n直接インスタンスを生成できないというのも理由のひとつですが，\u003ccode\u003eFooRepository\u003c/code\u003eは内部でネットワークリクエストを行うためどのみちそのまま扱うことができません．\u003cbr\u003e\nそのため\u003ccode\u003eFooRepository\u003c/code\u003eのモックオブジェクトを生成し，\u003ccode\u003efooRepositoryProvider\u003c/code\u003eに注入して\u003ccode\u003eFooViewModel\u003c/code\u003eから\u003ccode\u003eMockFooRepository\u003c/code\u003eが参照されるように設定します．\u003c/p\u003e\n\u003cp\u003e今回利用するモックライブラリ\u003ca href=\"https://pub.dev/packages/mockito\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003emockito\u003c/a\u003eが生成するモックは，次のように対象のクラスを\u003ccode\u003eimplements\u003c/code\u003eする形で実装されます．\u003cbr\u003e\nパブリックなコンストラクタを自動で生成してくれるので，\u003ccode\u003eMockFooRepository\u003c/code\u003eインスタンスを用いて\u003ccode\u003efooRepositoryProvider\u003c/code\u003eを上書きできます．\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre data-file=\"foo_repository.mocks.dart\" class=\"language-dart  line-numbers\"\u003e\u003ccode class=\"language-dart\"\u003e\u003cspan class=\"token keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eMockFooRepository\u003c/span\u003e \u003cspan class=\"token keyword\"\u003eextends\u003c/span\u003e _i1\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eMock \u003cspan class=\"token keyword\"\u003eimplements\u003c/span\u003e _i2\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eFooRepository \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token class-name\"\u003eMockFooRepository\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    _i1\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ethrowOnMissingStub\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword\"\u003ethis\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\n  \u003cspan class=\"token metadata symbol\"\u003e@override\u003c/span\u003e\n  _i3\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eFuture\u003cspan class=\"token generics\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eList\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eFoo\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e \u003cspan class=\"token function\"\u003elist\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token comment\"\u003e/* omitted */\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan aria-hidden=\"true\" class=\"line-numbers-rows\"\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e今回はViewModelとViewを共に扱いテストを行います．\nここでは\u003ccode\u003eFooViewModel\u003c/code\u003eを利用するViewを\u003ccode\u003eFooView\u003c/code\u003eとします．\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre data-file=\"foo_view_model_test.dart\" class=\"language-dart  line-numbers\"\u003e\u003ccode class=\"language-dart\"\u003e\u003cspan class=\"token keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"token function\"\u003emain\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token keyword\"\u003efinal\u003c/span\u003e repository \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eMockFooRepository\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"token keyword\"\u003efinal\u003c/span\u003e container \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eProviderContainer\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\n    overrides\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003efooRepositoryProvider\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eoverrideWithValue\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003erepository\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n  \u003cspan class=\"token comment\"\u003e// repositoryのmock等を行う\u003c/span\u003e\n\n  \u003cspan class=\"token function\"\u003etestWidgets\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e'FooViewModel smoke test with view'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eWidgetTester\u003c/span\u003e tester\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n    \u003cspan class=\"token keyword\"\u003efinal\u003c/span\u003e widget \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eProviderScope\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\n      overrides\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003efooRepositoryProvider\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eoverrideWithValue\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003erepository\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      child\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eMaterialApp\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003ehome\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eFooView\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n    \u003cspan class=\"token keyword\"\u003eawait\u003c/span\u003e tester\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003erunAsync\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n      \u003cspan class=\"token keyword\"\u003eawait\u003c/span\u003e tester\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003epumpWidget\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n      \u003cspan class=\"token comment\"\u003e// 初期状態の確認.\u003c/span\u003e\n      \u003cspan class=\"token comment\"\u003e// APIリクエストが完了していないのでデータローディングの旨を表示したい\u003c/span\u003e\n      \u003cspan class=\"token function\"\u003eexpect\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003efind\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003etext\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e'データ読み込み中'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e findsOneWidget\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n      \u003cspan class=\"token comment\"\u003e// 描画更新を更新.\u003c/span\u003e\n      \u003cspan class=\"token comment\"\u003e// APIリクエストが完了している(ようレスポンスをスタブする)ので\u003c/span\u003e\n      \u003cspan class=\"token comment\"\u003e// ローディングが完了しデータが描画されていることを確認\u003c/span\u003e\n      \u003cspan class=\"token comment\"\u003e// (レスポンスはListViewで描画しているとする)\u003c/span\u003e\n      \u003cspan class=\"token function\"\u003eexpect\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003efind\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003etext\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token string\"\u003e'データ読み込み中'\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e findsNothing\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n      \u003cspan class=\"token function\"\u003eexpect\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003efind\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ebyType\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eListView\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e findsOneWidget\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n      \u003cspan class=\"token comment\"\u003e// pull to refresh 実行\u003c/span\u003e\n      \u003cspan class=\"token comment\"\u003e// pull to refreshをテスト上でimitateする処理は以下を参照\u003c/span\u003e\n      \u003cspan class=\"token comment\"\u003e// @see: \u003ca href=\"https://github.com/flutter/flutter/blob/d62f75dde1cb6f04fadb9aff48896491ff0e2163/packages/flutter/test/material/refresh_indicator_test.dart#L119-L122\" class=\"token url-link\"\u003ehttps://github.com/flutter/flutter/blob/d62f75dde1cb6f04fadb9aff48896491ff0e2163/packages/flutter/test/material/refresh_indicator_test.dart#L119-L122\u003c/a\u003e\u003c/span\u003e\n      \u003cspan class=\"token function\"\u003ewhen\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003erepository\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003elist\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ethenAnswer\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e_\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"token comment\"\u003e/* response */\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n      \u003cspan class=\"token keyword\"\u003eawait\u003c/span\u003e tester\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003efling\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003efind\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003ebyType\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eListView\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eOffset\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token number\"\u003e0\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e300\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token number\"\u003e1000\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n      \u003cspan class=\"token keyword\"\u003eawait\u003c/span\u003e tester\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003epump\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n      \u003cspan class=\"token keyword\"\u003eawait\u003c/span\u003e tester\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003epump\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eDuration\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eseconds\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e3\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n      \u003cspan class=\"token comment\"\u003e// responseが更新されていることを確認\u003c/span\u003e\n      \u003cspan class=\"token function\"\u003eexpect\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token comment\"\u003e/* */\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n    \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan aria-hidden=\"true\" class=\"line-numbers-rows\"\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003cspan class=\"\"\u003e\u003c/span\u003e\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e同様にしてRepositoryから\u003ccode\u003eFuture.error\u003c/code\u003eを返すことでWidgetのエラー時の描画のテストを行うことが可能です．\u003c/p\u003e\n\u003ch3 id=\"viewmodelとservice-class\"\u003e\u003ca href=\"#viewmodelとservice-class\"\u003eViewModelとService class\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eViewModelの処理をどのタイミングでServiceクラスへ委譲するかの基準は，\u003ca href=\"https://docs.microsoft.com/en-us/visualstudio/test/unit-test-basics?view=vs-2019#write-your-tests\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003eArrange-Act-Assert\u003c/a\u003eにおけるArrange\u003csup\u003e\u003ca href=\"#user-content-fn-6\" id=\"user-content-fnref-6\" data-footnote-ref aria-describedby=\"footnote-label\"\u003e5\u003c/a\u003e\u003c/sup\u003eのコストを一つの目安とすることができます．\u003cbr\u003e\nテストの準備の記述(Arrange)が少なくない割合を占める場合，テスト対象が状態や責務を持ちすぎている可能性があります．\nそうなった場合にはArrangeの記述及びViewModelのメソッドの処理からテスト(の準備が)しづらいメソッドを探しだしてServiceクラスへ抽出します．\nそうすることでテスト容易性を高め，かつテスト対象の関心の対象を絞ることで壊れづらいテストコードを保つことが可能です．\u003c/p\u003e\n\u003cp\u003e\u003csmall\u003eこのアプローチは実際テスト対象とレイヤーの異なる責務を見分けて分離するには便利な手法だと感じています\u003c/small\u003e\u003c/p\u003e\n\u003cp\u003e補足:\u003cbr\u003e\nSOLID原則の\u003ca href=\"https://en.wikipedia.org/wiki/Single-responsibility_principle\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003eSingle-responsibility principle\u003c/a\u003eは\"1つのクラスは1つの責務\"といった説明がされがちですが，真意は\"1つのクラスは1つの(アクターに対し)責務(を負う)\"ということです．\u003cbr\u003e\nViewModelは責務が多くなりがちですが，対応するViewに対してのみ責務を追っているためSRPの観点からは適切です．\u003cbr\u003e\nただしViewModelのメソッドの処理をテストする際にViewModelがServiceクラスのアクターになれる場合においては，それはメソッドの処理をServiceクラスへと切り出すタイミングだと思います．\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e以上，テスト容易性を意識したFlutterアプリケーションのアーキテクチャを考察していきました．\n長くなってスマン.\u003c/p\u003e\n\u003cp\u003eDartの型システムは比較的緩いので，そういった言語特性も含めテストでカバーしていきたい気持ちがあり今回このような検討を行いました．\u003cbr\u003e\n結合度と凝集度など関数レベルでの設計やTDDなどのプラクティスはもちろん，アーキテクチャレベルで考慮することで更にテスト容易性を向上することができ，またソフトウェアの品質を担保することに繋がります．\u003c/p\u003e\n\u003csmall\u003e\n  半年とか経ったら振り返りをしようと考えています．  \n\u003c/small\u003e\n\u003chr\u003e\n\u003ch3 id=\"2021-11-15-追記\"\u003e\u003ca href=\"#2021-11-15-追記\"\u003e2021-11-15 追記:\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eご指摘をいただき，\u003ccode\u003exxxProvider\u003c/code\u003e内で\u003ccode\u003eref.read\u003c/code\u003eを呼ぶ代わりに\u003ccode\u003eref.read\u003c/code\u003eを渡すように修正しました．\u003cbr\u003e\n元々の設計意図はDIフレームワークを各レイヤの実装内部に持ち込みたくなかったというのがあります．\nRiverpodでは以下のように記述することで(後述するパフォーマンスの問題を除けば)Provider内部で別のProviderの値を取得することが可能です．\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-dart\"\u003e\u003ccode class=\"language-dart\"\u003e\u003cspan class=\"token comment\"\u003e// bad\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003efinal\u003c/span\u003e fooViewModelProvider \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eStateNotifierProvider\u003c/span\u003e\u003cspan class=\"token generics\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eref\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eFooViewModel\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003erepository\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e ref\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token function\"\u003eread\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003efooRepositoryProvider\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e\u003ccode\u003efooViewModelProvider\u003c/code\u003eを\u003ccode\u003eFooViewModel\u003c/code\u003eと\u003ccode\u003efooRepositoryProvider\u003c/code\u003eの糊付けとして用いることで，\u003ccode\u003eFooViewModel\u003c/code\u003eの実装内部にRiverpodを持ち込まなくて済みます．\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-dart\"\u003e\u003ccode class=\"language-dart\"\u003e\u003cspan class=\"token keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eFooViewModel\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token comment\"\u003e// 修正前は`fooViewModelProvider`を糊付けとして利用して`FooViewModel`にRiverpodのコードを入れないようにしていた.\u003c/span\u003e\n  \u003cspan class=\"token class-name\"\u003eFooViewModel\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003erequired \u003cspan class=\"token class-name\"\u003eFooRepository\u003c/span\u003e repository\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eただ\u003ca href=\"https://riverpod.dev/docs/concepts/combining_providers/#can-i-read-a-provider-without-listening-to-it\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003eこちら\u003c/a\u003eにもあるように\u003ccode\u003eref.read\u003c/code\u003eをProvider内部で呼ぶことは不要なリビルドを招くため，次のように\u003ccode\u003eReader\u003c/code\u003e関数を渡すように修正しました．\u003c/p\u003e\n\u003cp\u003e個人的には\u003ccode\u003eReader\u003c/code\u003eを引数にとるのはService Locatorパターンだと考えているので，\u003ccode\u003eReader\u003c/code\u003eをメンバとして保持しないようにコンストラクタで取得後破棄するようにしています．\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-dart\"\u003e\u003ccode class=\"language-dart\"\u003e\u003cspan class=\"token comment\"\u003e// good\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003efinal\u003c/span\u003e fooViewModelProvider \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eStateNotifierProvider\u003c/span\u003e\u003cspan class=\"token generics\"\u003e\u003cspan class=\"token punctuation\"\u003e\u0026#x3C;\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\n  \u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eref\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eFooViewModel\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003eref\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eread\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n\u003cspan class=\"token keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eFooViewModel\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n  \u003cspan class=\"token comment\"\u003e// `ref.read`を受取り，コンストラクタで`read`する\u003c/span\u003e\n  \u003cspan class=\"token class-name\"\u003eFooViewModel\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003e\u003cspan class=\"token class-name\"\u003eReader\u003c/span\u003e reader\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e _repository \u003cspan class=\"token operator\"\u003e=\u003c/span\u003e \u003cspan class=\"token function\"\u003eread\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003efooRepositoryProvider\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\n  \u003cspan class=\"token keyword\"\u003efinal\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eFooRepository\u003c/span\u003e _repository\u003cspan class=\"token punctuation\"\u003e;\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e正直修正後もベストかどうか自信がないので，引き続き試行錯誤していこうと思います．\u003c/p\u003e\n\u003cp\u003e改めてご指摘頂いた方々には感謝しています．ありがとうございます．\u003c/p\u003e\n\u003csection data-footnotes class=\"footnotes\"\u003e\u003ch2 id=\"footnote-label\" class=\"sr-only\"\u003e\u003ca href=\"#footnote-label\"\u003eFootnotes\u003c/a\u003e\u003c/h2\u003e\n\u003col\u003e\n\u003cli id=\"user-content-fn-1\"\u003e\n\u003cp\u003e\u003ca href=\"https://livebook.manning.com/book/dependency-injection-principles-practices-patterns/about-this-book/1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003eDependency Injection principles, Manning\u003c/a\u003e. volatile dependency/static dependency \u003ca href=\"#user-content-fnref-1\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\"\u003e↩\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"user-content-fn-2\"\u003e\n\u003cp\u003e\u003ca href=\"https://blog.ploeh.dk/2018/08/27/on-constructor-over-injection/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ehttps://blog.ploeh.dk/2018/08/27/on-constructor-over-injection/\u003c/a\u003e \u003ca href=\"#user-content-fnref-2\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\"\u003e↩\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"user-content-fn-3\"\u003e\n\u003cp\u003e\u003ca href=\"https://docs.microsoft.com/en-us/archive/blogs/johngossman/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ehttps://docs.microsoft.com/en-us/archive/blogs/johngossman/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps\u003c/a\u003e \u003ca href=\"#user-content-fnref-3\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\"\u003e↩\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"user-content-fn-4\"\u003e\n\u003cp\u003e\u003ca href=\"https://martinfowler.com/bliki/HumbleObject.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ehttps://martinfowler.com/bliki/HumbleObject.html\u003c/a\u003e \u003ca href=\"#user-content-fnref-4\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\"\u003e↩\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli id=\"user-content-fn-6\"\u003e\n\u003cp\u003eまたはHeuristics of Software TestabilityにおけるControllability/Decomposability. \u003ca href=\"#user-content-fnref-6\" data-footnote-backref class=\"data-footnote-backref\" aria-label=\"Back to content\"\u003e↩\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003c/section\u003e","description":"MVVM architecture with Repository pattern, state_notifier and riverpod","commits":[{"title":"refac: use Reader","date":"2021-11-16 00:41:55","hash":"27de1553","diff":"\u003cdiv class=\"remark-highlight\"\u003e\u003cpre data-file=\"27de1553.patch\" class=\"language-git  language-diff\"\u003e\u003ccode class=\"language-git\"\u003e\u003cspan class=\"token commit-sha1\"\u003ecommit 27de15535be63d9f250f908627bb68497c8d9699\u003c/span\u003e\nAuthor: koka \u0026#x26;\u003ca href=\"mailto:lt;koka.code@gmail.com\" class=\"token email-link\"\u003elt;koka.code@gmail.com\u003c/a\u003e\u0026#x26;gt;\nDate:   Tue Nov 16 00:41:55 2021 +0900\n\n  refac: use Reader\n\ndiff --git a/_posts/2021-10-20-testable-architecture-flutter.md b/_posts/2021-10-20-testable-architecture-flutter.md\nindex 81bc4d0..da2f4a5 100644\n\u003cspan class=\"token deleted\"\u003e--- a/_posts/2021-10-20-testable-architecture-flutter.md\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+++ b/_posts/2021-10-20-testable-architecture-flutter.md\u003c/span\u003e\n@@ -182,7 +182,7 @@ Repositoryインスタンスには[riverpod][riverpod]の提供する`Provider`\n\n\\```dart[data-file=\u003cspan class=\"token string\"\u003e\"foo_repository.dart\"\u003c/span\u003e]\nfinal fooRepositoryProvider = Provider\u0026#x26;lt;FooRepository\u0026#x26;gt;(\n\u003cspan class=\"token deleted\"\u003e-  (ref) =\u0026#x26;gt; FooRepository._(ref.read(httpClientProvider)),\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  (ref) =\u0026#x26;gt; FooRepository._(ref.read),\u003c/span\u003e\n);\n\\```\n\n@@ -195,7 +195,8 @@ final fooRepositoryProvider = Provider\u0026#x26;lt;FooRepository\u0026#x26;gt;(\n\n\\```dart[data-file=\u003cspan class=\"token string\"\u003e\"foo_repository.dart\"\u003c/span\u003e]\nclass FooRepository {\n\u003cspan class=\"token deleted\"\u003e-  FooRepository._(this._httpClient);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  // @see https://pub.dev/documentation/riverpod/latest/riverpod/Ref/read.html\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  FooRepository._(Reader read) : _httpClient = read(httpClientProvider);\u003c/span\u003e\n\n final HttpClient _httpClient;\n List\u0026#x26;lt;Foo\u0026#x26;gt;? _cache;\n@@ -245,10 +246,6 @@ APIクライアントクラスが利用する`HttpClient`をモックするこ\nAPIクライアントクラスが`HttpClient`を利用する処理はmixinとして実装を与えてあるため，個々のAPIクライアントクラスの振る舞いには左右されず修正に強いテストが期待できます．\nまたBと比較してもDIする対象が1つで済むため適切であると言えます．\n\n\u003cspan class=\"token deleted\"\u003e-::: warn FooRepositoryのコンストラクタについて\u003c/span\u003e\n\u003cspan class=\"token deleted\"\u003e-FooRepository内部で直接ProviderをService Locatorとして利用することを避けるために，HttpClientをコンストラクタの引数として渡すような設計になっています．\u003c/span\u003e\n\u003cspan class=\"token deleted\"\u003e-:::\u003c/span\u003e\n\u003cspan class=\"token deleted\"\u003e-\u003c/span\u003e\nテストコードで`HttpClient`をProviderから受け取るには`ProviderContainer`を利用します．  \n`ProviderContainer`の引数にDIプロバイダのオーバーライド設定を指定することで，テスト内では`mockHttpClient`を利用するRepositoryクラスを利用することができます．\n\n@@ -325,9 +322,7 @@ ViewModelがViewを参照しない・してはならないことからもわか\n\n\\```dart[data-file=\u003cspan class=\"token string\"\u003e\"view_model.dart\"\u003c/span\u003e]\nfinal fooViewModelProvider = StateNotifierProvider.autoDispose\u0026#x26;lt;FooViewModel, FooState\u0026#x26;gt;(\n\u003cspan class=\"token deleted\"\u003e-  (ref) =\u0026#x26;gt; WaitingListViewModel(\u003c/span\u003e\n\u003cspan class=\"token deleted\"\u003e-    fooRepository: ref.read(fooRepositoryProvider),\u003c/span\u003e\n\u003cspan class=\"token deleted\"\u003e-  ),\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  (ref) =\u0026#x26;gt; WaitingListViewModel(ref.read),\u003c/span\u003e\n);\n\\```\n\n@@ -357,8 +352,8 @@ class FooState with _$FooState {\n\n\\```dart[data-file=\u003cspan class=\"token string\"\u003e\"view_model.dart\"\u003c/span\u003e]\nclass FooViewModel extends StateNotifier\u0026#x26;lt;FooState\u0026#x26;gt; {\n\u003cspan class=\"token deleted\"\u003e-  FooViewModel({required FooRepository fooRepository})\u003c/span\u003e\n\u003cspan class=\"token deleted\"\u003e-      : _repository = fooRepository,\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  FooViewModel(Reader read)\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      : _repository = read(fooRepositoryProvider),\u003c/span\u003e\n       super(const FooState._(foos: AsyncValue.loading())) {\n   // construct時に初期化処理`onInit`を実行\n   onInit();\n@@ -493,6 +488,52 @@ Dartの型システムは比較的緩いので，そういった言語特性も\n 半年とか経ったら振り返りをしようと考えています．  \n\u0026#x26;lt;/small\u0026#x26;gt;\n\n\u003cspan class=\"token inserted\"\u003e+---\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+### 2021-11-15 追記:\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ご指摘をいただき，`xxxProvider`内で`ref.read`を呼ぶ代わりに`ref.read`を渡すように修正しました．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+元々の設計意図はDIフレームワークを各レイヤの実装内部に持ち込みたくなかったというのがあります．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+Riverpodでは以下のように記述することで(後述するパフォーマンスの問題を除けば)Provider内部で別のProviderの値を取得することが可能です．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```dart\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+// bad\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+final fooViewModelProvider = StateNotifierProvider\u0026#x26;lt;...\u0026#x26;gt;(\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  (ref) =\u0026#x26;gt; FooViewModel(repository: ref.read(fooRepositoryProvider)),\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+`fooViewModelProvider`を`FooViewModel`と`fooRepositoryProvider`の糊付けとして用いることで，`FooViewModel`の実装内部にRiverpodを持ち込まなくて済みます．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```dart\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+class FooViewModel {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  // 修正前は`fooViewModelProvider`を糊付けとして利用して`FooViewModel`にRiverpodのコードを入れないようにしていた.\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  FooViewModel({required FooRepository repository});\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+}\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ただ[こちら][provider_read]にもあるように`ref.read`をProvider内部で呼ぶことは不要なリビルドを招くため，次のように`Reader`関数を渡すように修正しました．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+個人的には`Reader`を引数にとるのはService Locatorパターンだと考えているので，`Reader`をメンバとして保持しないようにコンストラクタで取得後破棄するようにしています．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```dart\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+// good\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+final fooViewModelProvider = StateNotifierProvider\u0026#x26;lt;...\u0026#x26;gt;(\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  (ref) =\u0026#x26;gt; FooViewModel(ref.read)\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+class FooViewModel {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  // `ref.read`を受取り，コンストラクタで`read`する\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  FooViewModel(Reader reader) : _repository = read(fooRepositoryProvider);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  final FooRepository _repository;\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+}\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+正直修正後もベストかどうか自信がないので，引き続き試行錯誤していこうと思います．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+改めてご指摘頂いた方々には感謝しています．ありがとうございます．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n[praha_test]: \u003ca href=\"https://www.praha-inc.com/lab/posts/testability\" class=\"token url-link\"\u003ehttps://www.praha-inc.com/lab/posts/testability\u003c/a\u003e\n[testability]: \u003ca href=\"https://www.satisfice.com/download/heuristics-of-software-testability\" class=\"token url-link\"\u003ehttps://www.satisfice.com/download/heuristics-of-software-testability\u003c/a\u003e\n[shared_preferences]: \u003ca href=\"https://pub.dev/packages/shared_preferences\" class=\"token url-link\"\u003ehttps://pub.dev/packages/shared_preferences\u003c/a\u003e\n@@ -514,6 +555,7 @@ Dartの型システムは比較的緩いので，そういった言語特性も\n\n[aaa]: \u003ca href=\"https://docs.microsoft.com/en-us/visualstudio/test/unit-test-basics?view=vs-2019#write-your-tests\" class=\"token url-link\"\u003ehttps://docs.microsoft.com/en-us/visualstudio/test/unit-test-basics?view=vs-2019#write-your-tests\u003c/a\u003e\n[srp]: \u003ca href=\"https://en.wikipedia.org/wiki/Single-responsibility_principle\" class=\"token url-link\"\u003ehttps://en.wikipedia.org/wiki/Single-responsibility_principle\u003c/a\u003e\n\u003cspan class=\"token inserted\"\u003e+[provider_read]: https://riverpod.dev/docs/concepts/combining_providers/#can-i-read-a-provider-without-listening-to-it\u003c/span\u003e\n\n\n[^1]: [Dependency Injection principles, Manning][di_principles]. volatile dependency/static dependency\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e"},{"title":"fix","date":"2021-10-26 12:59:58","hash":"04af4b49","diff":"\u003cdiv class=\"remark-highlight\"\u003e\u003cpre data-file=\"04af4b49.patch\" class=\"language-git  language-diff\"\u003e\u003ccode class=\"language-git\"\u003e\u003cspan class=\"token commit-sha1\"\u003ecommit 04af4b49794e94e2e6766510580c29c00a2c257a\u003c/span\u003e\nAuthor: koka \u0026#x26;\u003ca href=\"mailto:lt;koka.code@gmail.com\" class=\"token email-link\"\u003elt;koka.code@gmail.com\u003c/a\u003e\u0026#x26;gt;\nDate:   Tue Oct 26 12:59:58 2021 +0900\n\n  fix\n\ndiff --git a/_posts/2021-10-20-testable-architecture-flutter.md b/_posts/2021-10-20-testable-architecture-flutter.md\nindex 90ba4f9..81bc4d0 100644\n\u003cspan class=\"token deleted\"\u003e--- a/_posts/2021-10-20-testable-architecture-flutter.md\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+++ b/_posts/2021-10-20-testable-architecture-flutter.md\u003c/span\u003e\n@@ -326,7 +326,7 @@ ViewModelがViewを参照しない・してはならないことからもわか\n\\```dart[data-file=\u003cspan class=\"token string\"\u003e\"view_model.dart\"\u003c/span\u003e]\nfinal fooViewModelProvider = StateNotifierProvider.autoDispose\u0026#x26;lt;FooViewModel, FooState\u0026#x26;gt;(\n (ref) =\u0026#x26;gt; WaitingListViewModel(\n\u003cspan class=\"token deleted\"\u003e-    insuranceRepository: ref.read(insuranceRepositoryProvider),\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    fooRepository: ref.read(fooRepositoryProvider),\u003c/span\u003e\n ),\n);\n\\```\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e"},{"title":"fix publish date","date":"2021-10-25 23:27:04","hash":"c6cee325","diff":"\u003cdiv class=\"remark-highlight\"\u003e\u003cpre data-file=\"c6cee325.patch\" class=\"language-git  language-diff\"\u003e\u003ccode class=\"language-git\"\u003e\u003cspan class=\"token commit-sha1\"\u003ecommit c6cee325763ea715072dc0671967db3042ca63c2\u003c/span\u003e\nAuthor: koka \u0026#x26;\u003ca href=\"mailto:lt;koka.code@gmail.com\" class=\"token email-link\"\u003elt;koka.code@gmail.com\u003c/a\u003e\u0026#x26;gt;\nDate:   Mon Oct 25 23:27:04 2021 +0900\n\n  fix publish date\n\ndiff --git a/_posts/2021-10-20-testable-architecture-flutter.md b/_posts/2021-10-20-testable-architecture-flutter.md\nindex 0fd6cde..90ba4f9 100644\n\u003cspan class=\"token deleted\"\u003e--- a/_posts/2021-10-20-testable-architecture-flutter.md\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+++ b/_posts/2021-10-20-testable-architecture-flutter.md\u003c/span\u003e\n\u003cspan class=\"token coord\"\u003e@@ -1,6 +1,6 @@\u003c/span\u003e\n\u003cspan class=\"token deleted\"\u003e---\u003c/span\u003e\ntitle: テスト容易性を考慮したFlutterのアーキテクチャ考察\n\u003cspan class=\"token deleted\"\u003e-date: 2021-10-20\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+date: 2021-10-25\u003c/span\u003e\ncategories:\n\u003cspan class=\"token deleted\"\u003e- Programming\u003c/span\u003e\ntags:\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e"},{"title":"publish: テスト容易性を考慮したFlutterのアーキテクチャ考察","date":"2021-10-25 23:22:57","hash":"77ea8468","diff":"\u003cdiv class=\"remark-highlight\"\u003e\u003cpre data-file=\"77ea8468.patch\" class=\"language-git  language-diff\"\u003e\u003ccode class=\"language-git\"\u003e\u003cspan class=\"token commit-sha1\"\u003ecommit 77ea846835d033ba818e33830a7a6e2be156553e\u003c/span\u003e\nAuthor: koka \u0026#x26;\u003ca href=\"mailto:lt;koka.code@gmail.com\" class=\"token email-link\"\u003elt;koka.code@gmail.com\u003c/a\u003e\u0026#x26;gt;\nDate:   Mon Oct 25 23:22:57 2021 +0900\n\n  publish: テスト容易性を考慮したFlutterのアーキテクチャ考察\n\ndiff --git a/_posts/2021-10-20-testable-architecture-flutter.md b/_posts/2021-10-20-testable-architecture-flutter.md\nnew file mode 100644\nindex 0000000..0fd6cde\n\u003cspan class=\"token deleted\"\u003e--- /dev/null\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+++ b/_posts/2021-10-20-testable-architecture-flutter.md\u003c/span\u003e\n\u003cspan class=\"token coord\"\u003e@@ -0,0 +1,524 @@\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+---\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+title: テスト容易性を考慮したFlutterのアーキテクチャ考察\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+date: 2021-10-20\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+categories:\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+- Programming\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+tags:\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+- Flutter\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+description: MVVM architecture with Repository pattern, state_notifier and riverpod\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+---\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ここ半年ほどFlutterを書いていて，アプリケーションのアーキテクチャで試行錯誤してます．状態管理ムズくない？  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+なのでいっそ表に出して意見もらえたらな，と思ったので書きます．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+本記事では，Flutterアプリケーションにおいてテスト容易性を向上するためにはどうすればいいか，サンプルアプリケーションを例題にアーキテクチャレベルで検討します．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+## アーキテクチャの目的\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+今回は**テスト容易性**を主軸に置いたアーキテクチャ選定を行いました．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+特にFlutterの単体テストはネットワークリクエストが遮断されるので，副作用を伴う処理を行うレイヤを適切に分離し，テストが容易になるよう設計を行うこととしました．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+アーキテクチャは何かしら課題を解決するために設計されるもの(だと思っている)なので，今回示す例が必ずしもベストなものとは限らないです．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+### テスト容易性とは\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+テスト容易性とは，James Bachが提唱した[Heuristics of Software Testability][testability](テスタビリティ・テスト容易性のモデル)に示される，テストの品質を測る指標です．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+それぞれの説明は[優れたテスト容易性を実現するためのポイント - PrAha ENGINEER LAB][praha_test]に詳しいです．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+こちらの記事でも示されている通り，テスト容易性の向上にはテスト容易性を低下させる要因を抑えることが必要不可欠です．そしてその要因はコードレベルに留まらずアーキテクチャレベルで抑えることが求められます．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+## 全体像\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ざっくり以下の機能を持つアプリケーションを例にとります．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+- APIサーバからデータ`Foo`のリストを取得してデータを描画する\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+- データ`Foo`を作成し，描画されるリストを更新する\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+- pull-to-refreshでのデータ再取得機能を持つ\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+また，今回用いるレイヤは以下のようになります;\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+- **API Client**: APIサーバからのデータ取得+モデルへのdeserializeを行う\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  - 実装: `GetRequestProtocol` + `ListFooRequest`\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+- **Repository**: API Client(+[shared_preferences][shared_preferences])を利用してデータ取得・更新を行う\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  - 実装: `FooRepository` + `fooRepositoryProvider`\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+- **Service**: ドメインロジック担当(もしくはTransaction Script)\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  - 実装は省略\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+- **ViewModel**: Viewの描画以外の責務全て\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  - 実装: `FooViewModel` + `fooViewModelProvider`\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+- **View**: 描画+イベントとViewModelのイベントハンドラの糊付け\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  - 実装は省略\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+テスト容易性を念頭に置いた際にどのレイヤの分割が必要か判断した結果，基本的なMVVMアーキテクチャとなりました．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+テスト容易性のためには特にViewをいかに薄く保てるかがキモで，そのためにViewModelはやや責務過多になる傾向にあります．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+したがってViewModelの肥大化を防ぐためにドメインロジックをViewModelからServiceクラスへ委譲し，また描画用のデータ管理とステートレスなドメインロジックを分離してテストできるようにします．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ViewModelと共に扱われることの多い，StreamやReactiveな双方向データバインディングは扱いません．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+以下では各レイヤ毎に簡易実装及びそのテストコードを示し，そのレイヤにおける責務と設計基準を説明します．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+実際の設計時はテストコードから書いて書き心地を試しつつの実装を行いましたが，説明の都合で実装-\u0026#x26;gt;テストの順で示します．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+また，Widgetについての設計はここでは述べません．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+テスト容易性の観点からViewを薄く保つことを念頭に置いているため，ViewはViewModelまでの設計と異なる目的での設計を取りうるためです．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+## API Client\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+APIクライアントクラスはネットワーク越しのリクエストを行い，アプリ内でのモデルへのdeserializeを行います．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ここではREST APIを仮定したクラス設計を行いますが，gRPCやGraphQLの場合でも実装が異なるだけで責務自体は変わらないと思います．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+APIレスポンスは対応するモデルクラスにマッピングし，`dynamic`型として存在する期間を極力短く保ちます．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+モデルクラスは適当な集約単位で作成し，レスポンスを正規化して持つようにします．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+[json_serializable][json_serializable]と組み合わせて`deserialize`の実装をModelのconstructorとして任せると楽です．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+::: info immutable\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+Dartで構造体や関数以外への型エイリアスが定義できないのでclassとして定義するしかない．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ただ内部状態を変更できるクラスメソッドを書けてしまうと変更検知が辛くなってしまう．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+:::\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```dart[class=\"line-numbers\"][data-file=\"foo.dart\"]\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+@freezed\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+class Foo with _$Foo {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  factory Foo.fromJson(Map\u0026#x26;lt;String, dynamic\u0026#x26;gt; json) =\u0026#x26;gt; _$FooFromJson(json);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+}\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+APIリクエストクラスは，実際のリクエスト処理の隠蔽及びテスト時のDIインターフェース統一のためにプロトコルで縛るようにします．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+プロトコルはmixinとして定義し，リクエスト処理を行う`request`メソッドのみmixin側に実装します．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ここでは簡単のため`url`以外の定義を省略していますが，クエリパラメータやヘッダなど，想定されるユースケースに応じた設定が行えるようにインターフェースを設計します．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+今回はGETリクエストを想定した`GetRequestProtocol`を定義し，またそのユースケースとして`ListFooRequest`を実装します．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+また，`HttpClient`はHTTPリクエストを担う[http][http]や[dio][dio]，またはいずれかをwrapしたクラスです．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```dart[class=\"line-numbers\"][data-file=\"api_protocol.dart\"]\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+// `package:meta` に [@mustOverride] annotation が入ったら嬉しい\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+// @see: https://github.com/dart-lang/sdk/issues/30175\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+mixin GetRequestProtocol\u0026#x26;lt;M\u0026#x26;gt; {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  @protected\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  String get url =\u0026#x26;gt; throw UnimplementedError();\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  Future\u0026#x26;lt;M\u0026#x26;gt; request(HttpClient client) async {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    final json = await client.get(/* api request */);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    return _deserialize(json);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  }\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  @protected\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  M _deserialize(Response json) {}\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+}\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ユースケース側は`GetRequestProtocol`を取り込んだRequestクラスを定義し，`request`メソッドが返すレスポンスをモデルへ変換する`deserialize`メソッドを実装します．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ここでは簡単のため`url`を固定値としていますが，実際には[flutter_dotenv][dotenv]を用いて環境変数としてAPIエンドポイントの管理を行います．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+これは設定と実装の分離の観点からももちろん好ましいのですが，読み込む`.env`ファイルをテスト時に差し替えられる利点が大きいです．詳細は後述します．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```dart[class=\"line-numbers\"][data-file=\"list_foo_request.dart\"]\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+class ListFooRequest with GetRequestProtocol\u0026#x26;lt;List\u0026#x26;lt;Foo\u0026#x26;gt;\u0026#x26;gt; {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  @override\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  String get url =\u0026#x26;gt; 'https://example.com/foos';\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  @override\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  List\u0026#x26;lt;Foo\u0026#x26;gt; _deserialize(Response json) {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    // レスポンスのJSONが`foos`をキーとして[Foo]の配列を持つと仮定\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    // constructor の tear-off が入ると `.map(Foo.fromJson)`のようにかける\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    // @see: https://twitter.com/remi_rousselet/status/1438207417154686980?s=20\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    return (json['foos'] as List)\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      .map((f) =\u0026#x26;gt; Foo.fromJson(f as Map\u0026#x26;lt;String, dynamic\u0026#x26;gt;))\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      .toList();\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  }\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+}\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+### test\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+APIクライアントクラスはネットワークリクエストを行い，レスポンスをモデルに変換するところまでを責務としました．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+Flutterのテストライブラリ[flutter_test][flutter_test]ではネットワークリクエストが遮断されるため，APIクライアントクラスに対するテストは`request`メソッドの返り値が対応するモデルインスタンスであるかどうかを評価することになります．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+モックのアプローチとしては以下の2パターンが考えられます;\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+- A. [mockito][mockito]を用いて`HttpClient`のモックオブジェクトを生成し，対応するレスポンスをスタブする\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+- B. [mock_http_server][mock_http_server]を用いてテスト用APIサーバを構築し，閉じたネットワークでのテストを行う\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+mockitoを用いる場合，今回の例題では`HttpClient`クラスの`get`メソッドをスタブすれば良さそうですが，HTTPリクエストを担うレイヤはinterceptorなどの機構を用いてロガーやエラーハンドラなどを注入するケースが多々あります．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+そのためテスト時に生成される`HttpClient`のモックオブジェクトと実際のリクエスト時に渡される`HttpClient`のインスタンスはスタブされている箇所以外にも設定が異なってしまうことが懸念されます．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+したがって`HttpClient`の挙動がランタイムと乖離しないように，ネットワークリクエスト先をすげ替えるBの方針を取ることにします．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```dart[class=\"line-numbers\"][data-file=\"list_foo_request_test.dart\"]\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+void main() {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  final server = MockWebServer(port: 8081);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  setUp(() async {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    // APIエンドポイントを[MockWebServer]にすげ替えるためにテスト用の.envファイルを読み込む．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    // HttpClientがbaseUrlを保持するパターンもあるが，全てのAPIが単一のbaseUrlからされない場合もあるので\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    // このようにしておく．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    await dotenv.load(fileName: '.env.test');\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    server.start();\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  });\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  tearDown(server.shutdown);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  // エラー時のテストケースについては，エラーハンドラを`request`メソッドの実装に持たせたり\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  // interceptorで挟んだりするためHttpClientやmixinのテストで記述する．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  // したがって個々のRequestクラスのテストケースはシンプルに保つことができる．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  test('ListFooRequest returns list of Foo', () async {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    // ここではJSONの構築に[dart:convert#jsonEncode]を用いた．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    // `json_serializable` が生成する`toJson`メソッドで適当なレスポンスを組み立ててもよい．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    final body = { 'foos': [/* Foo モデル */] };\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    server.enqueue(httpCode: 200, body: jsonEncode(body));\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    final response = await ListFooRequest().request(httpClient);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    expect(response, isA\u0026#x26;lt;List\u0026#x26;lt;Foo\u0026#x26;gt;\u0026#x26;gt;);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  });\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+}\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+## Repository\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+Repositoryクラスはデータ取得及びデータの更新操作を行います．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ここではAPIからのリモートデータリソースのみを扱っていますが，[shared_preferences][shared_preferences]やKeychain/KeyStoreを利用したローカルデータソースに対する操作も責務に含まれます．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+RepositoryクラスはViewModelレイヤから利用されるのですが，Repositoryクラスはネットワークアクセスが行われるためViewModelクラスの内部でRepositoryクラスを初期化してしまうとViewModelのテストが困難になります．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+かといってViewModelクラスのコンストラクタにRepositoryクラスを引数として渡す場合，そのViewModelクラスを利用するViewでRepositoryクラスを作成してViewModelを得る必要が出てしまい，レイヤ跨ぎ(View -\u0026#x26;gt; Repository)が発生してしまいます．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+これを解消するためにDI(Dependency Injection)を用いて各レイヤ間の結合をDIプロバイダに委任します．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+Repositoryインスタンスには[riverpod][riverpod]の提供する`Provider`を介してアクセスするようにします．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+そのために`FooRepository`にはパブリックなコンストラクタを実装せずプライベートコンストラクタ`._()`のみを定義し，外部ファイルから`FooRepository`インスタンスを直接立ち上げることを禁止します．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```dart[data-file=\"foo_repository.dart\"]\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+final fooRepositoryProvider = Provider\u0026#x26;lt;FooRepository\u0026#x26;gt;(\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  (ref) =\u0026#x26;gt; FooRepository._(ref.read(httpClientProvider)),\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+また，(一般的なアーキテクチャにおける)Repositoryクラスは永続化層と表現されることもあり，その文脈ではキャッシュ機構を持つことがあります．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+仮に`FooRepository`がキャッシュ機構を持つとした場合，そのテストがどのように記述されるべきかを見ていきます．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+`FooRepository`がキャッシュ機構を持つ場合，リモートデータソースとキャッシュとの整合性の不一致が生じえます．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+例えば`create`を呼んだ後に`list`を実行すると，`create`したデータが含まれないキャッシュが返されるなどが考えられます．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+データの整合性を担保するにはいくつか方法がありますが，ここではシンプルにキャッシュの破棄操作を行う実装を行うとしましょう．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```dart[data-file=\"foo_repository.dart\"]\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+class FooRepository {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  FooRepository._(this._httpClient);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  final HttpClient _httpClient;\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  List\u0026#x26;lt;Foo\u0026#x26;gt;? _cache;\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  Future\u0026#x26;lt;List\u0026#x26;lt;Foo\u0026#x26;gt;\u0026#x26;gt; list() async {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    if (_cache != null) return _cache;\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    _cache = ListFooRequest().request(_httpClient);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    return _cache;\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  }\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  // Requestクラスの説明では省略した[CreateFooRequest]を用いて\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  // [Foo]レコードを作成するリクエストを行う．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  // [CreateFoo]クラスは[Foo]レコードを作成する際のDTO.\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  Future\u0026#x26;lt;Foo\u0026#x26;gt; create(CreateFoo createFoo) async {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    _cache = null;\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    await CreateFooRequest(createFoo).request(_httpClient);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  }\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+}\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+### test\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+Repositoryクラスはデータ取得・更新操作を行い，データの整合性を担保します．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+Repositoryクラスのユースケースにおいては，その内部にキャッシュ機構があるかどうか，またはインメモリデータベースを利用しているかどうかは隠蔽されているべきです．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+したがって実装の詳細には触れず，その振る舞いのみを保証するにはテストデータ更新後に最新のデータを返すかどうかを確認すれば良さそうです．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+次にテスト容易性を主軸にRepositoryクラスをどのように提供するか考察します．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+Repositoryクラスはその責務上複数のAPIクライアントクラスを操作するため，テストのタイミングではAPIクライアントクラスもしくはその処理のモックが必要となります．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+Repositoryクラスにおいてもどのレイヤーをモックするかが設計のポイントとなるのですが，Repositoryクラスのコンストラクタに渡される`HttpClient`をモックする方針をとります．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+判断に至った思考仮定は次のようなものです;\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+**A. APIクライアントのテストのようにAPIサーバをモックする場合**  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+この場合Repositoryクラスが扱う各APIクライアントクラスに対するモックAPIサーバの設定を記述する必要があります．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+この設定にはエンドポイントのURLやレスポンスのJSONスキーマ定義など，APIクライアントクラスの責務となる詳細部分が必要なので，\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+APIクライアントの実装を変更することでRepositoryクラスのテストがfailする可能性があり，修正に脆いテストとなり得ます．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+**B. 個々のAPIクライアントクラスをモックする場合**  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+先に示した`FooRepository`クラスの実装ではAPIクライアントクラスをハードコードして利用しています．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+APIクライアントクラスをモックする場合には各APIクライアントクラスをDIするかコンストラクタの引数として受け取るような実装をする必要が生じます．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+(callerの直接の)コンストラクタでの引数渡しについては先に述べたとおり抽象化レイヤを跨いでしまうため避けたいです．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+またAPIクライアントクラスはRepositoryクラスにとってStatic Dependency[^1]であり，また各APIクライアントクラスをDIすることはOver-Injection[^2]に繋がるのでこれもベストとは言い難いです．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+**C. HttpClientをモックする場合**  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+Aではネットワーク先，BではAPIクライアントの振る舞いをそれぞれスタブする方針でした．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+APIクライアントクラスが利用する`HttpClient`をモックすることで，APIクライアントのネットワークリクエスト処理のみをスタブすることができます．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+APIクライアントクラスが`HttpClient`を利用する処理はmixinとして実装を与えてあるため，個々のAPIクライアントクラスの振る舞いには左右されず修正に強いテストが期待できます．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+またBと比較してもDIする対象が1つで済むため適切であると言えます．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+::: warn FooRepositoryのコンストラクタについて\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+FooRepository内部で直接ProviderをService Locatorとして利用することを避けるために，HttpClientをコンストラクタの引数として渡すような設計になっています．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+:::\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+テストコードで`HttpClient`をProviderから受け取るには`ProviderContainer`を利用します．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+`ProviderContainer`の引数にDIプロバイダのオーバーライド設定を指定することで，テスト内では`mockHttpClient`を利用するRepositoryクラスを利用することができます．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```dart[data-file=\"foo_repository_test.dart\"]\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+void main() {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  final container = ProviderContainer(\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    overrides: [httpClientProvider.overrideWithValue(mockHttpClient)],\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  );\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  final repository = container.read(fooRepositoryProvider);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+}\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+データ整合性のテストはユースケースを元に，`create`メソッド実行後に`list`メソッドの実行結果が`create`したデータを含むかどうかを確認します．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u0026#x26;lt;small\u0026#x26;gt;もちろん`list`メソッド単体のテストは書く前提です.\u0026#x26;lt;/small\u0026#x26;gt;\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```dart[data-file=\"foo_repository_test.dart\"]\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+void main() {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  // omitted\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  // HttpClientの挙動をスタブ\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  when(mockHttpClient.get(any)).thenAnswer((_) async =\u0026#x26;gt; listFooResponse);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  var response = await repository.list();\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  // verify(mockHttpClient.get(any)) として\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  // **内部でmockHttpClientが呼ばれた**ことをテストすることも可能だが，\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  // ここではRepositoryクラスの振る舞いを見ることを主軸に置くためテストに含めない．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  // 実際のユースケースではRepositoryクラスはProvider経由で利用され，\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  // HttpClientはProvider内部で渡されるため利用する側からはHttpClientはされている.\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  // あくまでテストにおいてのみRepositoryクラスがHttpClientを利用していることを知る必要が生じている．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  //\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  // ListFooRequestの結果が返される\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  expect(response, listFooResponse);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  // create時の挙動をスタブ\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  when(mockHttpClient.post(any)).thenAnswer((_) async =\u0026#x26;gt; createResponse);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  final createFoo = CreateFoo(/* */);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  response = await repository.create(createFoo);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  expect(response, createResponse);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  // 再度Listした際に更新されたResponseが返される\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  when(mockHttpClient.get(any)).thenAnswer((_) async =\u0026#x26;gt; updatedListResponse);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  response = await repository.list();\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  expect(response, updatedListResponse);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+}\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+## ViewModel\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ViewModelはViewが利用するデータ及びロジックを提供します．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ここが一番責務をどこにおくか悩むところだと思うので，ViewModelの定義について John Gossman. (2005)[^3]を紹介します．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u0026#x26;gt; The UI may want to perform complex operations that must be implemented in code which doesn't make sense in our strict definition of the View but are too specific to be included in the Model (or didn't come with the pre-existing model).\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u0026#x26;gt; Finally we need a place to put view state such as selection or modes.\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u0026#x26;gt;\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u0026#x26;gt; The ViewModel is responsible for these tasks.\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u0026#x26;gt; The term means \"Model of a View\", and can be thought of as abstraction of the view,\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u0026#x26;gt; but it also provides a specialization of the Model that the View can use for data-binding.\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u0026#x26;gt; In this latter role the ViewModel contains data-transformers that convert Model types into View types, and it contains Commands the View can use to interact with the Model.\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ここで示したいのはViewModelはViewとのデータバインディングだけではなく，Viewが行う複雑な操作(=ドメインロジック)をも責務に含むという点です．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+これは逆にViewにそのような処理をもたせてはいけないというだけなので，ViewModelまたはServiceレイヤに持たせるようにします．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ViewModelからはViewでの操作のハンドラを提供し，ViewからServiceクラスを直接呼ぶことのないようにします．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+例外的にpull-to-refreshのように描画・アニメーションがメインとなるロジックや，`BuildContext`を介する処理(例: `Navigator.push`等)についてはView側の責務となります．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+また，テスト容易性の観点からはMartin Fowler氏のHumble Object[^4]をイメージするとViewとViewModelとのそれぞれの責務の切り分けがしやすいかと思います．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+Viewのテストを考慮すると，View内部でViewModelをイニシャライズするとViewModelのモックがやや手間になります．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+したがってViewModelにおいてもProviderを利用して提供します．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ここで，ViewModelのライフサイクルをどうするか検討しましょう．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ViewModelがViewを参照しない・してはならないことからもわかるように，ViewModelとViewとのライフサイクルは異なります．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+しかしViewインスタンスが破棄された後にViewModelが生き続けると，再度Viewが生成された際にその(中途半端な状態を持つ)ViewModelが参照されると困るケースもあります．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+そういったケースでは`StateNotifierProvider.autoDispose`を用いてViewModelのライフサイクルをViewに揃え，Viewが生成されるタイミングでViewModelを生成してデータの整合性を担保するようにします．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```dart[data-file=\"view_model.dart\"]\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+final fooViewModelProvider = StateNotifierProvider.autoDispose\u0026#x26;lt;FooViewModel, FooState\u0026#x26;gt;(\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  (ref) =\u0026#x26;gt; WaitingListViewModel(\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    insuranceRepository: ref.read(insuranceRepositoryProvider),\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  ),\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ViewModelが持つ状態はたとえ変数が1つであってもクラスとして切り出し，内包する状態が増えた際に変更に対して閉じるようにします．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```dart[data-file=\"view_model.dart\"]\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+@freezed\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+class FooState with _$FooState {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  const factory FooState._({\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    required AsyncValue\u0026#x26;lt;List\u0026#x26;lt;Foo\u0026#x26;gt;\u0026#x26;gt; foos,\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  }) = _FooState;\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+}\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+今回はViewがpull-to-refresh機能を提供するとして設計します．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+その場合，Viewで必要となるロジックは以下のようなデータ及びイベントハンドラが考えられます；\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+- Viewで描画するデータ(`List\u0026#x26;lt;Foo\u0026#x26;gt;`)\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+- View作成時のViewModelの初期化処理(`onInit`)\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+- pull-to-refresh実行時のリフレッシュ処理(`onRefresh`)\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+- `Foo`の追加処理(`createFoo(CreateFoo foo)`)\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+また描画するデータ`List\u0026#x26;lt;Foo\u0026#x26;gt;`はAPIから取得するため，初期状態はデータを保持しておらずローディング中・ローディング失敗の状態も考えられます．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+そういったケースに対応するため`Future`の値の変化を検知・通知できる[`AsyncValue`][async_value]を利用します．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+それぞれを実装におとすと次のようになります．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```dart[data-file=\"view_model.dart\"]\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+class FooViewModel extends StateNotifier\u0026#x26;lt;FooState\u0026#x26;gt; {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  FooViewModel({required FooRepository fooRepository})\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      : _repository = fooRepository,\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+        super(const FooState._(foos: AsyncValue.loading())) {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    // construct時に初期化処理`onInit`を実行\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    onInit();\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  }\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  final FooRepository _repository;\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  Future\u0026#x26;lt;void\u0026#x26;gt; onInit() async {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    // 今回の例では簡単のため`onRefresh`を呼ぶだけ\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    await onRefresh();\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  }\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  Future\u0026#x26;lt;void\u0026#x26;gt; createFoo(CreateFoo foo) async {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    await _repository.create(foo).then((res) {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      await onRefresh();\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    }).catchError((e) {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      // TODO\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    });\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  }\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  Future\u0026#x26;lt;void\u0026#x26;gt; onRefresh() async {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    await _repository.list().then((res) {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      state = state.copyWith(foos: AsyncValue.data(res));\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    }).catchError((e) {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      state = state.copyWith(foos: AsyncValue.error(e as Object));\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    });\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  }\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+}\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+### test\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ViewModelはViewが利用するデータ及びロジックの提供を責務とします．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ViewModelのテストですが，単体でのテストを行うかViewと組み合わせたテストを行うか正直自分の中で答えを出せていません．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+Viewの持つロジックを極力薄くすることで，擬似的にViewの取りうる振る舞いをViewModelでテストすることは可能です．ただViewModelの取りうる状態に応じた描画はViewでのテストでしか担保することができず，かつそれらは無視できる量・質のものとは言い難いです．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+そのためViewはViewのテストが必要となりますが，ViewModelが示す状態に沿う描画ができているかを検査すればよいので，ある程度宣言的にテストを記述できます．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+実際，実機での[integration_test][integration_test]や回帰テストを行う[golden toolkit][golden_test]などViewを対象としたテストツールも充実してきておりそれらを用いることで描画内容にとどまらないデザインのテストをも行うことが可能となってきています．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ただ，そこに実際のViewModelを持ち込むかモックしたViewModelを持ち込むかは明確な判断理由を持てていません．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ここではテスト容易性を主軸においたアーキテクチャの紹介を行い，いわゆるUIテストについては上記の説明に留めることとします．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+---\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+先程実装した`FooRepository`はProvider経由のみのアクセスとするためにパブリックなコンストラクタを公開していませんでした．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+直接インスタンスを生成できないというのも理由のひとつですが，`FooRepository`は内部でネットワークリクエストを行うためどのみちそのまま扱うことができません．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+そのため`FooRepository`のモックオブジェクトを生成し，`fooRepositoryProvider`に注入して`FooViewModel`から`MockFooRepository`が参照されるように設定します．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+今回利用するモックライブラリ[mockito][mockito]が生成するモックは，次のように対象のクラスを`implements`する形で実装されます．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+パブリックなコンストラクタを自動で生成してくれるので，`MockFooRepository`インスタンスを用いて`fooRepositoryProvider`を上書きできます．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```dart[class=\"line-numbers\"][data-file=\"foo_repository.mocks.dart\"]\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+class MockFooRepository extends _i1.Mock implements _i2.FooRepository {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  MockFooRepository() {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    _i1.throwOnMissingStub(this);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  }\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  @override\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  _i3.Future\u0026#x26;lt;List\u0026#x26;lt;Foo\u0026#x26;gt;\u0026#x26;gt; list() =\u0026#x26;gt; (/* omitted */);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+}\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+今回はViewModelとViewを共に扱いテストを行います．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ここでは`FooViewModel`を利用するViewを`FooView`とします．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```dart[class=\"line-numbers\"][data-file=\"foo_view_model_test.dart\"]\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+void main() {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  final repository = MockFooRepository();\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  final container = ProviderContainer(\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    overrides: [fooRepositoryProvider.overrideWithValue(repository)],\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  );\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  // repositoryのmock等を行う\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  testWidgets('FooViewModel smoke test with view', (WidgetTester tester) async {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    final widget = ProviderScope(\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      overrides: [fooRepositoryProvider.overrideWithValue(repository)],\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      child: const MaterialApp(home: FooView()),\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    );\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    await tester.runAsync(() async {\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      await tester.pumpWidget();\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      // 初期状態の確認.\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      // APIリクエストが完了していないのでデータローディングの旨を表示したい\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      expect(find.text('データ読み込み中'), findsOneWidget);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      // 描画更新を更新.\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      // APIリクエストが完了している(ようレスポンスをスタブする)ので\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      // ローディングが完了しデータが描画されていることを確認\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      // (レスポンスはListViewで描画しているとする)\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      expect(find.text('データ読み込み中'), findsNothing);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      expect(find.byType(ListView), findsOneWidget);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      // pull to refresh 実行\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      // pull to refreshをテスト上でimitateする処理は以下を参照\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      // @see: https://github.com/flutter/flutter/blob/d62f75dde1cb6f04fadb9aff48896491ff0e2163/packages/flutter/test/material/refresh_indicator_test.dart#L119-L122\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      when(repository.list()).thenAnswer((_) async =\u0026#x26;gt; /* response */);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      await tester.fling(find.byType(ListView), const Offset(0, 300), 1000);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      await tester.pump();\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      await tester.pump(const Duration(seconds: 3));\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      // responseが更新されていることを確認\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+      expect(/* */);\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+    });\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  });\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+}\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\\```\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+同様にしてRepositoryから`Future.error`を返すことでWidgetのエラー時の描画のテストを行うことが可能です．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+### ViewModelとService class\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ViewModelの処理をどのタイミングでServiceクラスへ委譲するかの基準は，[Arrange-Act-Assert][aaa]におけるArrange[^6]のコストを一つの目安とすることができます．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+テストの準備の記述(Arrange)が少なくない割合を占める場合，テスト対象が状態や責務を持ちすぎている可能性があります．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+そうなった場合にはArrangeの記述及びViewModelのメソッドの処理からテスト(の準備が)しづらいメソッドを探しだしてServiceクラスへ抽出します．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+そうすることでテスト容易性を高め，かつテスト対象の関心の対象を絞ることで壊れづらいテストコードを保つことが可能です．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u0026#x26;lt;small\u0026#x26;gt;このアプローチは実際テスト対象とレイヤーの異なる責務を見分けて分離するには便利な手法だと感じています\u0026#x26;lt;/small\u0026#x26;gt;\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+補足:  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+SOLID原則の[Single-responsibility principle][srp]は\"1つのクラスは1つの責務\"といった説明がされがちですが，真意は\"1つのクラスは1つの(アクターに対し)責務(を負う)\"ということです．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ViewModelは責務が多くなりがちですが，対応するViewに対してのみ責務を追っているためSRPの観点からは適切です．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+ただしViewModelのメソッドの処理をテストする際にViewModelがServiceクラスのアクターになれる場合においては，それはメソッドの処理をServiceクラスへと切り出すタイミングだと思います．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+---\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+以上，テスト容易性を意識したFlutterアプリケーションのアーキテクチャを考察していきました．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+長くなってスマン.\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+Dartの型システムは比較的緩いので，そういった言語特性も含めテストでカバーしていきたい気持ちがあり今回このような検討を行いました．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+結合度と凝集度など関数レベルでの設計やTDDなどのプラクティスはもちろん，アーキテクチャレベルで考慮することで更にテスト容易性を向上することができ，またソフトウェアの品質を担保することに繋がります．\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u0026#x26;lt;small\u0026#x26;gt;\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+  半年とか経ったら振り返りをしようと考えています．  \u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u0026#x26;lt;/small\u0026#x26;gt;\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+[praha_test]: https://www.praha-inc.com/lab/posts/testability\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+[testability]: https://www.satisfice.com/download/heuristics-of-software-testability\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+[shared_preferences]: https://pub.dev/packages/shared_preferences\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+[freezed]: https://pub.dev/packages/freezed\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+[riverpod]: https://pub.dev/packages/riverpod\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+[dotenv]: https://pub.dev/packages/flutter_dotenv\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+[json_serializable]: https://pub.dev/packages/json_serializable\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+[http]: https://pub.dev/packages/http\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+[dio]: https://pub.dev/packages/dio\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+[flutter_test]: https://api.flutter.dev/flutter/flutter_test/flutter_test-library.html\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+[mockito]: https://pub.dev/packages/mockito\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+[mock_http_server]: https://pub.dev/packages/mock_web_server\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+[async_value]: https://pub.dev/documentation/riverpod/latest/riverpod/AsyncValue-class.html\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+[di_principles]: https://livebook.manning.com/book/dependency-injection-principles-practices-patterns/about-this-book/1\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+[integration_test]: https://flutter.dev/docs/cookbook/testing/integration/introduction\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+[golden_test]: https://pub.dev/packages/golden_toolkit\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+[aaa]: https://docs.microsoft.com/en-us/visualstudio/test/unit-test-basics?view=vs-2019#write-your-tests\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+[srp]: https://en.wikipedia.org/wiki/Single-responsibility_principle\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+[^1]: [Dependency Injection principles, Manning][di_principles]. volatile dependency/static dependency\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+[^2]: https://blog.ploeh.dk/2018/08/27/on-constructor-over-injection/\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+[^3]: https://docs.microsoft.com/en-us/archive/blogs/johngossman/introduction-to-modelviewviewmodel-pattern-for-building-wpf-apps\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+[^4]: https://martinfowler.com/bliki/HumbleObject.html\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+[^5]: https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html\u003c/span\u003e\n\u003cspan class=\"token inserted\"\u003e+[^6]: またはHeuristics of Software TestabilityにおけるControllability/Decomposability.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e"}],"publishedAt":"2021-10-25","updatedAt":"2021-11-16"}},"__N_SSG":true},"page":"/archives/[slug]","query":{"slug":"2021-10-20-testable-architecture-flutter"},"buildId":"2E6UKlrD16eNIDc8fou7_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>